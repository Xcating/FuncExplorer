401000	Sexy::ButtonListener::ButtonPress(int theClickCount, int theId, ecx = ButtonListener* this)	eax, ecx, edx		默认的按钮监听器监测到按钮以 theClickCount 点击方式按下时，执行忽略点击类型的按钮按下事件。		【虚函数】[[[(ButtonListener*)]+0]+0]
401010	AlmanacDialog::AlmanacDialog(LawnApp* theApp, AlmanacDialog* this)	eax = *this; ecx, edx		初始化创建图鉴对话，并将图鉴调整至索引页。需要一个大小为 0x7E4 的内存区域用于构造 this。
401880	AlmanacDialog::`scalar deleting destructor'(unsigned int flags, ecx = AlmanacDialog* this)	eax = *this; ecx, edx		删除 AlmanacDialog 图鉴对话，当 flags 的第 0 位置 1 时会额外释放图鉴对话本身占用的内存空间。		【虚函数】[[[(AlmanacDialog*)]+0]+0]
4018A0	AlmanacDialog::~AlmanacDialog(ecx = AlmanacDialog* this)	eax, ecx, edx		销毁图鉴对话，删除其中的各个游戏按钮及植物和僵尸。
401970	AlmanacDialog::ClearPlantsAndZombies(eax = AlmanacDialog* this)	eax, ecx, edx		删除图鉴中演示用的植物和僵尸及所有性能测试用僵尸。
401A10	AlmanacDialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = AlmanacDialog* this)	eax, ecx, edx		将图鉴对话移出控件管理器，同时删除对话中的植物和僵尸。		【虚函数】[[[(AlmanacDialog*)]+0]+54]
401A30	AlmanacDialog::SetupPlant(esi = AlmanacDialog* this)	eax, ecx, edx		清除当前所有植物和僵尸，然后根据当前选中的植物类型，在图鉴中创建相应的植物并设定植物的位置。
401B20	Plant::Plant(eax = Plant* this)	eax = *this; ecx, edx		初始化植物基础数据。创建新植物时调用，初始化植物的图像矩形、判定矩形、图层、指针等。
401B70	AlmanacDialog::SetupZombie(esi = AlmanacDialog* this)	eax, ecx, edx		清除当前所有植物和僵尸，然后根据当前选中的僵尸类型，在图鉴中创建相应的僵尸并设定僵尸的位置。
401BE0	AlmanacDialog::SetPage(eax = AlmanacPage thePage, ecx = AlmanacDialog* this)	eax, ecx, edx		设置图鉴当前显示的页面。
401D30	AlmanacDialog::Update(ecx = AlmanacDialog* this)	eax, ecx, edx		图鉴对话更新，更新其中的各个游戏按钮及植物和僵尸，同时更新鼠标光标样式和水面效果。		【虚函数】[[[(AlmanacDialog*)]+0]+58]
401E70	AlmanacDialog::DrawIndex(Graphics* g, AlmanacDialog* this)	eax, ecx, edx		绘制图鉴索引页。
402060	AlmanacDialog::DrawPlants(Graphics* g, AlmanacDialog* this)	eax, ecx, edx		绘制图鉴植物页。
402C00	AlmanacDialog::DrawZombies(Graphics* g, AlmanacDialog* this)	eax, ecx, edx		绘制图鉴僵尸页。
403810	AlmanacDialog::Draw(Graphics* g, ecx = AlmanacDialog* this)	eax, ecx, edx		绘制图鉴，包括绘制图鉴当前页、绘制性能测试僵尸和绘制各个游戏按钮。		【虚函数】[[[(AlmanacDialog*)]+0]+68
403940	AlmanacDialog::SeedHitTest(int y, int x, AlmanacDialog* this)	eax = SeedType aSeedType; ecx, edx		图鉴对话植物页中，获取当前鼠标悬浮的陈列植物类型，若鼠标不位于任何一种植物上则返回 -1。
403A10	AlmanacDialog::ZombieIsShown(ebx = ZombieType theZombieType, AlmanacDialog* this)	al = bool 是否显示僵尸; ecx, edx		判断在图鉴中是否展示 theZombieType 类型的僵尸。
403B30	AlmanacDialog::ZombieHasDescription(ecx = ZombieType theZombieType, eax = AlmanacDialog* this)	al = bool 是否显示描述文本; ecx, edx		判断在图鉴中是否显示 theZombieType 类型的僵尸的描述文本。
403BB0	AlmanacDialog::ZombieHitTest(esi = int y, edi = int x, AlmanacDialog* this)	eax = ZombieType aZombieType; ecx, edx		图鉴对话僵尸页中，获取当前鼠标悬浮的陈列僵尸类型，若鼠标不位于任何一种僵尸上则返回 -1。
403C60	AlmanacDialog::MouseUp(int theClickCount, int y, int x, ecx = AlmanacDialog* this)	eax, ecx, edx		图鉴对话中鼠标松开，根据点击的按钮执行调整图鉴的当前页面或关闭图鉴对话。		【虚函数】[[[(AlmanacDialog*)]+0]+E0]
403D00	AlmanacDialog::MouseDown(int theClickCount, int y, int x, ecx = AlmanacDialog* this)	eax, ecx, edx		图鉴对话中鼠标按下。按下按钮时播放相应按钮的音效，按下植物或僵尸陈列时调整当前展示的植物或僵尸。		【虚函数】[[[(AlmanacDialog*)]+0]+D8]
403E20	std::string::assign;(unsigned int _Count = -1, unsigned int _Roff, const std::string& _Right, ecx = std::string* this)	eax = std::string& this; ecx, edx		以 _Right 字符串的一个指定的子字符串赋值 this，当 _Count = -1 时不限制子字符串长度。
403F00	std::string::erase(unsigned int _Count = -1, unsigned int _Off, ecx = std::string* this)	eax = std::string& this; ecx, edx		删除字符串从 _Off 开始的 _Count 个字符，当 _Count = -1 时删除从 _Off 开始至结尾的所有字符。
403F90	std::_Traits_helper::move_s<std::char_traits<char>>;(unsigned int _Count, const char* _First2, unsigned int _Size, char* _First1)	eax = char* _First1; ecx, edx	0x10	将 _First2 字符串的 _Count 个字符拷贝至 _First1 处，_Size 表示 _First1 处的最大容量。
403FC0	std::string::_Grow(bool _Trim, unsigned int _Newsize, ecx = std::string* this)	al = bool ; ecx, edx		字符串长度增长至 _Newsize。_Trim 指定对于短字符串是否将内存块中的数据迁移至内部缓冲区。
404080	std::string::_Copy(unsigned int _Oldlen, unsigned int _Newsize, ecx = std::string* this)	eax, ecx, edx		重新分配内存使得字符串的容量由 _Oldlen 增长至 _Newsize 或以上，同时迁移字符串中的旧有数据。
4041C0	std::_Allocate<char>(..., char* __formal = nullptr, unsigned int _Count)	eax = void* _Mem; ecx, edx	0x8(+N)	申请 _Count 个字符所需要的内存空间，单个字符占用的内存大小为 0x1。;当 _Count 个字符的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
404220	std::bad_alloc::`scalar deleting destructor'(unsigned int flags, ecx = std::bad_alloc* this)	eax = *this; ecx, edx		释放内存分配失败异常，当 flags 的第 0 位置 1 时会额外释放图鉴对话本身占用的内存空间。		【虚函数】[[[(std::bad_alloc*)]+0]+0]
404250	std::bad_alloc::~bad_alloc(ecx = std::bad_alloc* this)	eax, ecx, edx		销毁内存分配失败异常。
404260	std::bad_alloc::bad_alloc(std::bad_alloc& _that, ecx = std::bad_alloc* this)	eax = *this; ecx, edx		复制 __that 的数据用于构造内存分配失败异常。需要一个大小为 0xC 的内存区域用于构造 this。
404280	std::string::_Tidy(unsigned int _Newsize, bool _Built, ecx = std::string* this)	eax, ecx, edx		重置字符串长度为 _Newsize，即将字符串 _Newsize 位置的字符替换为终止字符。;若指定了 _Built 且字符串原长度大于 15 字节，则先将内存块中的数据迁移至自身的缓冲区中并释放内存块。
4042D0	std::string::c_str(ecx = std::string* this)	eax = const char* _Ptr		C++ 字符串的 c_str() 函数。返回指向字符串文本内容（C 字符串）的指针。
4042E0	std::string::_Eos(unsigned int _Newsize, ecx = std::string* this)	eax, ecx		强制字符串在 _Newsize 位置处结束，并舍弃该位置开始向后的内容。
404300	std::string::assign(const char* _Ptr, ecx = std::string* this)	eax = std::string& this; ecx, edx		以 _Ptr 字符串设置 this 的文本内容。
404330	std::string::assign(unsigned int _Count, const char* _Ptr, ecx = std::string* this)	eax = std::string& this; ecx, edx		截取 _Ptr 字符串的前 _Count 个字符，将其设置为 this 的文本内容。
404400	std::string::basic_string(ecx = std::string* this)	eax = *this; ecx		初始化创建空字符串。需要一个大小为 0x1C 的内存区域用于构造 this。
404420	std::string::~basic_string(ecx = std::string* this)	eax, ecx, edx		销毁字符串，并释放字符串的 c_str 占用的内存空间。
404450	std::string::basic_string(const char* _Ptr, ecx = std::string* this)	eax = *this, ecx, edx		由 C 字符串 _Ptr 创建 C++ 字符串。需要一个大小为 0x1C 的内存区域用于构造 this。
404490	Attachment::Update(ecx = Attachment* this)	eax, ecx, edx		附件更新，更新其中的附属特效并对其中已经消失的特效（若有）做特殊处理。
404610	Attachment::SetPosition(const SexyVector2& thePosition, ecx = Attachment* this)	eax, ecx, edx		将附件移动至二维向量 thePosition 指向的位置。
404780	Attachment::OverrideColor(const Color& theColor, ecx = Attachment* this)	eax, ecx, edx		设置附件中各附属特效的颜色。
404890	Attachment::PropogateColor(const Color& theColor, bool theEnableAdditiveColor, ;                           const Color& theAdditiveColor, bool theEnableOverlayColor, ;                           const Color& theOverlayColor, ecx = Attachment* this)	eax, ecx, edx		将基础颜色、叠加颜色和覆盖颜色应用到附件中所有附属的特效。
404A40	Attachment::OverrideScale(float theScale, ecx = Attachment* this)	eax, ecx, edx		更改附件中各附属特效的尺寸大小。
404B20	Attachment::CrossFade(ebx = Attachment* this)	eax, ecx, edx		令附件中的所有粒子系统交叉混合至“FadeOut”发射器。
404B80	Attachment::SetMatrix(const SexyTransform2D& theMatrix, ecx = Attachment* this)	eax, ecx, edx		计算 theMatrix 作用下各附属特效的偏移矩阵，并以此相应设置附属特效的位置或覆写变换矩阵。
404D10	Attachment::Draw(bool theParentHidden, Graphics* g, ecx = Attachment* this)	eax, ecx, edx		绘制附件。当 theParentHidden 为 1 时，附件中随父物体隐藏的特效将不会被绘制。
404E80	Attachment::Detach(ecx = Attachment* this)	eax, ecx, edx		解除附件，取消绑定其中所有附属的特效，然后令附件本身消失。
404FC0	Attachment::AttachmentDie(ecx = Attachment* this)	eax, ecx, edx		销毁附件，并销毁其中所有附属的特效。
405120	AttachmentHolder::~AttachmentHolder(AttachmentHolder* this)	eax, ecx, edx		释放并销毁附件容器。
4051B0	AttachmentUpdateAndSetMatrix(SexyTransform2D& theMatrix, edi = AttachmentID& theAttachmentID)	eax, ecx, edx	0x4	更新 theAttachmentID 的附件并设置矩阵，若调用时附件不存在则将 theAttachmentID 赋值为 0。
405200	AttachmentUpdateAndMove(float y, float x, edi = AttachmentID& theAttachmentID)	eax, ecx, edx	0x8	更新附件并将附件移动至 (x, y) 位置，若调用时附件不存在则将 theAttachmentID 赋值为 0。
405270	AttachmentReanimTypeDie(eax = AttachmentID& theAttachmentID)	eax, ecx, edx		销毁 theAttachmentID 的附件中所有 0x75 类型的动画（部分僵尸头顶出现的问号动画）。
405300	AttachmentDetachCrossFadeParticleType;(ParticleEffect theParticleEffect, eax = AttachmentID& theAttachmentID)	eax, ecx, edx	0x4	销毁 theAttachmentID 的附件中所有 theParticleEffect 粒子系统，并将 theAttachmentID 赋值为 0。
4053A0	Attachment::Draw(bool theParentHidden, Graphics* g, edx = AttachmentID theAttachmentID)	eax, ecx, edx	0x8	绘制 theAttachmentID 的附件。当 theParentHidden 为 1 时，附件中随父物体隐藏的特效将不会被绘制。
4053E0	AttachmentDie(esi = AttachmentID& theAttachmentID)	eax, ecx, edx		销毁 theAttachmentID 的附件，并销毁其中所有附属的特效，同时将 theAttachmentID 赋值为 0。
405430	AttachmentDetach(esi = AttachmentID& theAttachmentID)	eax, ecx, edx		解除绑定附件中的所有附属特效，使其恢复为独立的特效，并将 theAttachmentID 赋值为 0。
405480	FindReanimAttachment(eax = AttachmentID& theAttachmentID)	eax = Reanmiation*? aReanim; ecx, edx		取得 theAttachmentID 编号的附件上绑定的第一个动画。
405500	FindFirstAttachment(ecx = AttachmentID& theAttachmentID)	eax = AttachEffect*? aAttachEffect; ;ecx, edx		取得 theAttachmentID 编号的附件中的第一个附属效果。
405540	CreateEffectAttachment(float theOffsetY, float theOffsetX, unsigned int theDataID, ;                       EffectType theEffectType, edi = AttachmentID& theAttachmentID)	eax = AttachEffect* aAttachEffect; ecx, edx	0x10	将效果系统中的特效绑定至 theAttachmentID 附件，若附件不存在（theAttachmentID = 0）则创建。;其中 theDataID 为需要绑定的特效在其数据数组中的编号（例如，绑定动画时其即为 ReanimationID）。
4055D0	AttachReanim(float theOffsetY, float theOffsetX, ;             esi = Reanimation* theReanimation, edi = AttachmentID& theAttachmentID)	eax = AttachEffect* aAttachEffect; ecx, edx	0x8	将动画绑定至 theAttachmentID 的附件并设定位置偏移，;若调用时附件不存在（theAttachmentID = 0）则创建。
405600	AttachParticle(float theOffsetY, float theOffsetX, ;               esi = TodParticleSystem* theParticleSystem, edi = AttachmentID& theAttachmentID)	eax = AttachEffect* aAttachEffect; ecx, edx	0x8	将粒子系统绑定至 theAttachmentID 的附件并设定位置偏移，;若调用时附件不存在（theAttachmentID = 0）则创建。
405630	DataArray<Attachment>::DataArrayDispose(eax = DataArray<Attachment>* this)	eax, ecx, edx		销毁附件数据数组中的所有附件并回收其占用的内存区域，然后释放附件数组占用的内存空间。
405660	DataArray<Attachment>::DataArrayAlloc(esi = DataArray<Attachment>* this)	eax = Attachment* aAttachment; ecx, edx		创建附件，在附件数组中申请该附件的内存区域。
405700	DataArray<Attachment>::DataArrayFreeAll(edi = DataArray<Attachment>* this)	eax, ecx, edx		以析构函数销毁并释放附件数据数组中的所有附件及其附属效果。
405780	AwardScreen::AwardScreen(AwardType theAwardType, ecx = LawnApp* theApp, AwardScreen* this)	eax = *this, ecx, edx		初始化创建奖励·便签界面，根据界面类型及当前关卡等相应地延迟加载游戏资源和设定各个游戏按钮。;需要一个大小为 0x9C 的内存区域用于构造 this。
406420	AwardScreen::`scalar deleting destructor'(unsigned int flags, ecx = AwardScreen* this)	eax = *this, ecx, edx		销毁奖励·便签界面，当 flags 的第 0 位置 1 时会额外释放界面本身占用的内存空间。		【虚函数】[[[(AwardScreen*)]+0]+0]
406440	AwardScreen::~AwardScreen(ecx = AwardScreen* this)	eax, ecx, edx		销毁奖励·便签界面，删除开始按钮和菜单按钮。
4064C0	AwardScreen::Resize(int theHeight, int theWidth, int theY, int theX, ecx = AwardScreen* this)	eax, ecx, edx		更改奖励·便签界面的位置及大小。此函数内部直接跳转至 Widget::Resize 函数。		【虚函数】[[[(AwardScreen*)]+0]+A0]
4064D0	AwardScreen::DrawBottom;(const std::string& theMessage, const std::string& theAward, const std::string& theTitle, Graphics* g)	eax, ecx, edx		绘制奖励界面的背景贴图，然后依次绘制奖励标题、奖励内容和奖励描述的文本。
4066A0	AwardScreen::DrawAwardSeed(Graphics* g, ecx = AwardScreen* this)	eax, ecx, edx		获取并绘制奖励界面背景、文本及奖励的植物卡牌。
4068D0	AwardScreen::Draw(Graphics* g, ecx = AwardScreen* this)	eax, ecx, edx		绘制奖励·便签界面。根据界面类型、当前关卡及存档数据等决定绘制奖励界面或绘制便签界面。		【虚函数】[[[(AwardScreen*)]+0]+68]
4076A0	AwardScreen::Update(ecx = AwardScreen* this)	eax, ecx, edx		奖励·便签界面更新，更新其中的各个游戏按钮，同时更新鼠标光标样式和淡入倒计时。		【虚函数】[[[(AwardScreen*)]+0]+58]
407740	AwardScreen::AddedToManager(WidgetManager* theWidgetManager, ecx = AwardScreen* this)	eax, ecx, edx		将奖励·便签界面加入控件管理器。此函数内部直接跳转至 Widget::AddedToManager 函数。		【虚函数】[[[(AwardScreen*)]+0]+50]
407750	AwardScreen::RemovedFromManager(WidgetManager* theWidgetManager, ecx = AwardScreen* this)	eax, ecx, edx		将奖励·便签界面移出控件管理器。此函数内部直接跳转至 Widget::RemovedFromManager 函数。		【虚函数】[[[(AwardScreen*)]+0]+54]
407760	AwardScreen::KeyChar(char theChar, ecx = AwardScreen* this)	eax, ecx, edx		奖励·便签界面中输入 char 字符。若输入空格、换行符或 Esc 字符，则执行按下开始按钮的事件。		【虚函数】[[[(AwardScreen*)]+0]+BC]
407780	AwardScreen::StartButtonPressed(AwardScreen* this)	eax, ecx, edx		奖励·便签界面中点击开始按钮，根据界面类型及当前关卡等判断并执行相应的事件。
4079F0	AwardScreen::MouseDown(int theClickCount, int y, int x, ecx = AwardScreen* this)	eax, ecx, edx		奖励·便签界面中鼠标按下，当以左键单击游戏按钮时，播放按钮点击的音效。		【虚函数】[[[(AwardScreen*)]+0]+D8]
407A70	AwardScreen::MouseUp(int theClickCount, int y, int x, ecx = AwardScreen* this)	eax, ecx, edx		奖励·便签界面中鼠标松开，处理左键单击时开始按钮和菜单按钮的点击事件。		【虚函数】[[[(AwardScreen*)]+0]+E0]
407AE0	FloatRoundToInt(float theFloatValue)	eax = int anIntValue; ecx, edx		将给定的浮点数 theFloatValue 四舍五入取整。
407B10	Distance2D(float y2, float x2, float y1, float x1)	st(0) = aDistance; eax, ecx, edx	0x10	计算位于 2D 平面上的两点 (x1, y1) 与 (x2, y2) 之间的距离。
407B50	Board::Board(ecx = LawnApp* theApp, Board* this)	eax = *this, ecx, edx		初始化关卡界面基础数据，创建并初始化其内部的各成员，并根据当前关卡调整按钮的文本和位置等。;需要一个大小为 0x57B0 的内存区域用于构造 this。
408670	Board::`scalar deleting destructor'(unsigned int flags, ecx = Board* this)	eax = *this, ecx, edx		销毁关卡界面，当 flags 的第 0 位置 1 时会额外释放关卡界面本身占用的内存空间。		【虚函数】[[[(Board*)]+0]+0]
408690	Board::~Board(ecx = Board* this)	eax, ecx, edx		销毁关卡界面，同时销毁其内部的各成员并释放成员占用的内存空间。
408A00	ToolTipWidget::~ToolTipWidget(esi = ToolTipWidget* this)	eax, ecx, edx		销毁鼠标悬浮标签，删除其标题、正文和警告文本的字符串并释放字符串占用的内存空间。
408A70	Board::DisposeBoard(esi = Board* this)	eax, ecx, edx		退出关卡前的清理，触发花园相关关卡退出时的事件，停止雨声音效，清除戴夫，释放效果系统。
408B00	Board::AreEnemyZombiesOnScreen(edx = Board* this)	al = 0(不存在) | 1(存在); ecx		判断场上是否存在存活的未被魅惑的僵尸。用于判断关卡的过关条件。
408B60	Board::CountEnemyZombiesOnScreen(ebx = Board* this)	eax = int aCount; ecx, edx		获取场上存活的未被魅惑的僵尸的数量。当其数量大于一定值时，部分音效可能不会触发。
408BF0	Board::CountUntriggerLawnMowers(edx = Board* this)	eax = int aCount; ecx		取得场上未被触发且未被压扁的小推车的数量。
408C30	Board::TryToSaveGame(Board* this)	eax, ecx, edx		尝试保存关卡存档。包括创建存档文件、暂停背景音乐、写入存档文件、保存生存模式记录等事件。
408DA0	Board::NeedSaveGame(eax = Board* this)	al = bool ; ecx		判断是否需要保存当前关卡的存档。废案关卡、非正式关卡和关卡的非正常游戏阶段将不可存档。
408DE0	Board::LoadGame(eax = const std::string& theFileName, edi = Board* this)	al = bool 是否读档成功; ecx, edx		读取游戏存档，加载场景贴图资源，重置帧率相关记录数据，更新当前各对话的图层。;通过 theFileName 指定需要读取的存档文件的完整路径及文件名。
408E40	Board::GetGriditemAt;(edi = int theGridY, ebx = int theGridX, GridItemType theGridItemType, edx = Board* this)	eax = Griditem*? ; ecx		取得位于指定行和列的 theGridItemType 场地物品，若指定位置不存在指定场地物品则返回 0。
408E90	Board::GetRake(edx = Board* this)	eax = Griditem*? ; ecx		取得场地上编号最小的钉耙。用于决定关卡第一只僵尸的出现位置。
408ED0	Board::CanAddGraveStoneAt(ebx = int theGridY, edi = int theGridX, edx = Board* this)	al = 0(不能) | 1(能); ecx		判断能否在 (theGridX, theGridY) 格子内出现墓碑。
408F40	Board::AddALadder(edi = int theGridY, int theGridX, eax = Board* this)	eax = Griditem* aLadder; ecx, edx		在 (theGridX, theGridY) 格子内架设梯子。
408F80	Board::AddACrater(edi = int theGridY, int theGridX, eax = Board* this)	eax = Griditem* aCrater; ecx, edx		在 (theGridX, theGridY) 格子内创建弹坑。
408FC0	Board::AddGraveStones(MTRand& theLevelRNG, int theCount, eax = int theGridX, Board* this)	eax, ecx, edx		在第 theGridX 列的随机行（由 theLevelRNG 随机取得，且该格子必须可以存在墓碑）创建共 theCount 个墓碑。
409050	Board::GetNumWavesPerFlag(ecx = Board* this)	eax = int aWaveCount		取得当前关卡每两个旗帜波之间的小波数量。;若当前关卡为一周目冒险模式且总波数小于 10 波，则返回当前关卡总波数，否则返回 10。
409080	Board::IsFlagWave(int theWaveNumber, edx = Board* this)	al = bool 是否为旗帜波; ecx, edx		判断第 theWaveNumber 波是否为旗帜波。
4090F0	ZombiePickerInitForWave(eax = ZombiePicker* theZombiePicker)	ecx		初始化僵尸挑选器的僵尸数、僵尸点数及各僵尸类型的当前计数为 0。
409170	ZombiePickerInit(eax = ZombiePicker* theZombiePicker)	ecx		创建新僵尸挑选器，并初始化僵尸数、僵尸点数及各僵尸类型的当前计数和总计数为 0。;需要一个大小为 0x110 的内存区域用于存放 theZombiePicker 的数据。
409240	Board::PutZombieInWave(ecx = ZombiePicker* theZombiePicker, eax = int theWaveNumber, ;                       esi = ZombieType theZombieType, edi = Board* this)	eax, edx		将一只 theZombieType 类型的僵尸加入第 theWaveNumber 波的出怪，并相应调整僵尸挑选器中的相关数据。
409290	Board::PutInMissingZombies(ZombiePicker* theZombiePicker, int theWaveNumber, eax = Board* this)	eax, ecx, edx		冒险模式中，修正最后一波的出怪，补充本关卡内可以出现而最后一波中尚缺的僵尸类型。
4092E0	Board::PickZombieWaves(edi = Board* this)	eax, ecx, edx		设定关卡的总波数，并生成关卡的僵尸出怪列表。
40A110	Board::GetLevelRandSeed(ecx = Board* this)	eax = int aRandSeed; ecx, edx		根据用户序号、关卡固有随机种子、当前关卡、当前波数等，计算一个新的随机数种子。
40A160	Board::LoadBackgroundImages(esi = Board* this)	eax, ecx, edx		根据当前关卡及关卡场景，延迟加载相应组的贴图资源（智慧树关卡为预加载背景动画资源）。
40A550	Board::PickBackground(eax = Board* this)	eax, ecx, edx		根据当前关卡获取场景类型，延迟加载相应场景的贴图资源，设定每行的种植出怪类型和每个格子的类型，;若关卡存在墓碑，则额外在随机位置生成若干个墓碑，并从中随机选取一个表面有刻字的特殊墓碑。
40AB10	Board::InitZombieWavesForLevel(edx = int theForLevel, edi = Board* this)	eax, ecx, edx		设定冒险模式第 theForLevel 关卡的出怪类型数组。;对于冒险模式关卡中的部分特殊关卡，会调用425840的函数进行设定。
40ABB0	Board::InitZombieWaves(eax = Board* this)	eax, ecx, edx		设定关卡的基础初始数据，包括出怪类型数组、出怪列表和第一波僵尸的倒计时等。
40ACB0	Board::FreezeEffectsForCutscene(bl = bool theFreeze, edi = Board* this)	eax, ecx, edx		设置所有吞噬墓碑的粒子特效和植物睡眠动画的冻结与否，若水面未被冻结则设置水面特效的冻结与否。
40AD60	Board::InitSurvivalStage(Board* this)	eax, ecx, edx		生存模式一轮完成后，暂停本轮的进程（暂停音、特效等），并为下一轮的过场和选卡等进行准备。
40AE70	Board::GetShovelButtonRect(eax = _Out_ Rect&& aRect, edx = Board* this)	eax = Rect&& aRect; ecx		取得铲子的范围矩形，用于绘制和鼠标检测等。
40AF00	Board::GetZenButtonRect(edi = Rect& theRect, GameObjectType theObjectType, Board* this)	eax = Rect& theRect; ecx, edx		禅境花园或智慧树关卡中，取得 theObjectType 道具或按钮的范围矩形，用于绘制和鼠标检测等。;需要先调用40AE70的函数取得一个矩形，此函数仅可用于设定和调整上述矩形的横坐标。
40AF90	Board::InitLevel(Board* this)	eax, ecx, edx		初始化关卡信息，设定关卡背景、出怪、初始阳光、浓雾坐标等基础数据及卡槽和部分关卡的固定选卡。
40B9C0	Board::PlaceRake(Board* this)	eax, ecx, edx		放置钉耙。游戏开始时调用，自动计算钉耙出现的位置并创建钉耙场地物品。手动创建可参考创建场地物品。;若玩家无剩余钉耙或关卡不会从右侧刷新僵尸（部分关卡除外），则终止放置钉耙且不会扣除钉耙使用次数。
40BC70	Board::InitLawnMowers(Board* this)	eax, ecx, edx		关卡开始时调用，初始化创建每一行的小推车（部分无小推车的关卡和不出怪的行除外）。
40BD30	Board::ChooseSeedsOnCurrentLevel(edi = Board* this)	al = bool 是否为自选卡关卡; ecx, edx		判断当前关卡是否可以选择卡牌，即：判断当前是否为自选卡关卡。
40BE00	Board::StartLevel(eax = Board* this)	eax, ecx, edx		关卡开始，设定关卡玩法，重新播放音乐、音效和特效。非首轮的生存模式关卡中，额外删除关卡存档文件。
40BF10	Board::GetBottomLawnMower(edx = Board* this)	eax = LawnMower*? aBottomMower; ecx		取得未被触发且未被压扁的小推车中，位于最下方的一辆。
40BF60	Board::UpdateLevelEndSequence(Board* this)	eax, ecx, edx		关卡结束阶段的更新，包括部分关卡进入下一轮的预备、过关音效的生成和小推车向金币的转化等。
40C2C0	Board::CompleteEndLevelSequenceForSaving(Board* this)	eax, ecx, edx		立即完成关卡结束后的过程，然后更新并保存一次用户的存档。;包括：将所有小推车转化为金币并立即完成收取令正在被收集中的物品立即完成收取销毁未被收集的物品。
40C3E0	Board::FadeOutLevel(ecx = Board* this)	eax, ecx, edx		当关卡或关卡的某一阶段完成时，判断是否已完成关卡，并依此开始退出关卡或过渡至下一阶段。
40CA10	Board::DisplayAdviceAgain(ebx = AdviceType theHelpIndex, ecx = MessageStyle theMessageStyle, ;                          edx = const std::string& theAdvice, edi = Board* this)	eax, ecx, edx		无论 theHelpIndex 的提示是否播放过，均重新播放一次该提示的字幕。
40CA50	Board::ClearAdviceImmediately(esi = Board* this)	eax, ecx, edx		无视字幕类型，立即结束当前提示字幕。
40CAB0	Board::ClearAdviceByType(eax = AdviceType theHelpIndex, esi = Board* this)	eax, ecx, edx		若当前字幕类型为 theHelpIndex，则清除字幕。当 theHelpIndex 为 -1 时，表示清除任何字幕。
40CB10	Board::AddCoin(CoinMotion theCoinMotion, CoinType theCoinType, int theY, int theX, ecx = Board* this)	eax = Coin* aCoin; ecx, edx		在 (theX, theY) 处创建并初始化以 theCoinMotion 方式运动的 theCoinType 物品。;一周目的 1-1 关卡中，额外创建点击拾取阳光的提示字幕。
40CCE0	Board::IsPlantInCursor(eax = Board* this)	al = bool ; ecx		判断鼠标手持的物品是否为植物（来自卡槽、卡牌、手套、循环复制器或手推车）。
40CD10	Board::GetSeedTypeInCursor(eax = Board* this)	eax = SeedType aSeedInCursor; ecx, edx		取得鼠标手持的植物类型（若为模仿者则取得模仿的植物类型），若手持手推车则返回手推车中的植物类型。
40CD80	Board::RefreshSeedPacketFromCursor(eax = Board* this)	eax, ecx, edx		鼠标放下卡牌，重置鼠标并令放下的卡牌重新可用。此处的“卡牌”包括来自卡槽和来自掉落物品的卡牌。
40CE00	Board::IsPoolSquare(ecx = int theGridY, eax = int theGridX, edx = Board* this)	al = bool 是否为水池格子; ecx		判断 (theGridX, theGridY) 格子是否为水池。
40CE20	Board::NewPlant;(SeedType theImitaterType = -1, SeedType theSeedType, int theGridY, int theGridX, eax = Board* this)	eax = Plant* aPlant; ecx, edx		[Tag:植物种植,种植植物,生成植物]关卡内创建新植物。此函数不会创建种植的音、特效且不会触发限制种植类关卡种植特定植物的特殊效果。
40CE60	Board::DoPlantingEffects(Plant* thePlant, eax = int theGridY, ecx = int theGridX, edx = Board* this)	eax, ecx, edx		在 (theGridX, theGridY) 格子内创建种植植物的音效和粒子特效。
40D120	Board::AddPlant;(SeedType theImitaterType = -1, SeedType theSeedType, eax = int theGridY, int theGridX, Board* this)	eax = Plant* aPlant; ecx, edx		在 (theGridX, theGridY) 格子处种植 theSeedType 植物，;触发限制种植关卡的相关判定并更新最多时阳光植物数量。
40D1A0	Board::GetPumpkinAt(ebx = int theGridY, int theGridX, edx = Board* this)	eax = Plant*? aPumpkinPlant; ecx		取得位于 (theGridX, theGridY) 格子内的编号最小的南瓜头。
40D220	Board::GetFlowerPotAt(ebx = int theGridY, int theGridX, edx = Board* this)	eax = Plant*? aFlowerPot; ecx		取得位于 (theGridX, theGridY) 格子内的花盆。
40D2A0	Board::GetPlantsOnLawn;(int theGridY, int theGridX, ebx = _Out_ PlantsOnLawn* thePlantOnLawn, edx = Board* this)	eax, ecx		获取 (theGridX, theGridY) 格子内的植物。获取的 thePlantOnLawn 的数据结构为：;其指针 +0、+4、+8、+C 所指向的地址处依次存储格子内的底端、南瓜头、飞行、常规植物的指针;当处于禅境花园时，睡莲将被视作常规植物当格子内不存在对应功能的植物时，该功能位置的返回值为空指针;当格子内同时存在多株对应功能的植物时，该功能位置的返回值为其中编号最大的一株植物的指针。
40D3A0	Board::CountSunFlowers(edx = Board* this)	eax = int aCount; ecx		取得场上阳光生产类植物（向日葵、双子向日葵、阳光菇）的总数量。
40D3F0	Board::CountPlantByType(ebx = SeedType theSeedType, edx = Board* this)	eax = int aCount; ecx		取得场上类型为 SeedType 的植物的数量。
40D430	Board::CountEmptyPotsOrLillies(SeedType theSeedType, edx = Board* this)	eax = int aCount; ecx		取得场上不与任何常规植物位于同一格的 theSeedType 植物数量。常用于获取空置的花盆和睡莲数量。
40D4F0	Board::IsValidCabCannonSpotHelper(esi = int theGridY, edi = int theGridX, edx = Board* this)	al = bool isValid; ecx		判断 (theGridX, theGridY) 格子是否具备种植玉米加农炮的先决条件，即：存在玉米投手且不存在南瓜头。;免费种植模式下，先决条件改为：存在玉米投手或可以种植玉米投手，且不存在南瓜头。
40D550	Board::IsValidCobCannonSpot(int theGridY, int theGridX, ecx = Board* this)	al = bool isValid; ecx, edx		判断 (theGridX, theGridY) 格子是否具备种植玉米加农炮的条件，即：;本格及右一格均满足种植玉米加农炮的先决条件，且两格内均存在或均不存在花盆。
40D5C0	Board::HasValidCobCannonSpot(edi = Board* this)	al = bool hasSpot; edx		判断场上玉米投手所在的格子中，是否存在满足玉米加农炮种植条件的地方。
40D620	Board::AddProjectile;(ProjectileType theProjectileType, int theRow, int theRenderOrder, int theY, int theX, eax = Board* this)	eax = Projectile* aProjectile; ecx, edx		在 (theX, theY) 处发射并初始化属于 theRow 行的 theProjectileType 子弹，;子弹的图像位于 theRenderOrder 图层。
40D660	Board::CanZombieSpawnOnLevel(edx = int theLevel, eax = ZombieType theZombieType)	al = bool canSpawn; ecx		判断 theZombieType 类型的僵尸能否在冒险模式第 theLevel 关卡出现。
40D6F0	Board::GetIntroducedZombieType(eax = Board* this)	eax = ZombieType aZombieType; ecx, edx		一周目冒险模式（1-1 关卡除外）中，取得在当前关卡首次出现的一种僵尸类型。
40D770	Board::PickGraveRisingZombieType(edx = Board* this)	eax = ZombieType aZombieType; ecx, edx		加权随机地获取墓碑冒出/蹦极空投/珊瑚僵尸的僵尸类型，后续会从剩余僵尸点数中扣除该僵尸的点数。;僵尸点数：初始时获得一定量点数，每次冒出/空投僵尸则消耗相当于该僵尸级别的点数，至少保留 1 点数。
40D8A0	Board::PickZombieType(ZombiePicker* theZombiePicker, int theWaveIndex, int theZombiePoints, Board* this)	eax = ZombieType aZombieType; ecx, edx		根据当前波数和剩余的僵尸点数等，随机取得一种可以加入第 theWaveIndex 波出怪列表的僵尸类型。
40DB20	Board::RowCanHaveZombieType(ZombieType theZombieType, int theRow, esi = Board* this)	al = bool canHaveZombieType; ecx, edx		判断第 theRow 行能否出现类型为 theZombieType 的僵尸。
40DC50	Board::PickRowForNewZombie(ZombieType theZombieType, eax = Board* this)	eax = int aRow; ecx, edx		选取新僵尸出现的行数。
40DD90	Board::CanAddBobSled(eax = Board* this)	al = bool canAddBobsled; ecx		判断在场地上是否留有冰道（要求冰道的横坐标小于 700）。用于判断是否可以刷出雪橇僵尸小队。
40DDC0	Board::AddZombieInRow(ebx = int theFromWave, int theRow, ZombieType theZombieType, eax = Board* this)	eax = Zombie* aZombie; ecx, edx		[Tag:种植僵尸,生成僵尸,创建僵尸]在 theRow 行出现一只 theZombieType 类型的僵尸，若为雪橇僵尸小队则额外补齐剩余 3 只小队成员僵尸。
40DEA0	Board::RemoveAllZombies(edi = Board* this)	eax, ecx, edx		移除场上所有未死亡的僵尸。
40DF00	Board::RemoveZombiesForRepick(edi = Board* this)	eax, ecx, edx		移除场上所有横坐标大于 720 的被魅惑的僵尸。
40DF70	Board::RemoveCutsceneZombies(ebx = Board* this)	eax, ecx, edx		清除选卡界面的预览僵尸（清除所有出现的波数为 -2 的僵尸）。
40DFC0	Board::IsIceAt(eax = int theGridY, int theGridX, esi = Board* this)	al = bool isIce; ecx, edx		判断 (theGridX, theGridY) 格子内是否存在冰道覆盖。
40E020	Board::CanPlantAt(SeedType theSeedType, int theGridY, eax = int theGridX, Board* this)	eax = PlantingReason aResult; ecx, edx		判断 theSeedType 植物是否可以种植在 (theGridX, theGridY) 格子处，并返回不能种植的原因：;0(可以种植) | 1(不可种植) | 2(墓碑吞噬者只能种在墓碑上) | 3(水生植物只能种在水中) | 4(土豆地雷只能种在陆地上) | 5(需要花盆) | 6(种子限制) | 7(坚果保龄球放置限制) | 8(紫卡需要底物) | 9(有墓碑) | A(有弹坑) | B(需要睡莲) | C(地刺只能种植在坚硬的地面上) | D(咖啡豆只能种植在睡着的蘑菇上)
40E520	Board::UpdateCursor(edi = Board* this)	eax, ecx, edx		关卡内根据鼠标光标的位置及游戏物体的位置信息等，更新对应的鼠标光标样式。
40E760	Board::MouseMove(int y, int x, ecx = Board* this);Board::MouseDrag(int y, int x, ecx = Board* this)	eax, ecx, edx		关卡界面的鼠标移动和鼠标拖动函数。当鼠标移动或拖动至 (x, y) 位置处时，调用421920的函数。		【虚函数】[[[(Board*)]+0]+D0] & [[[(Board*)]+0]+E8]
40E780	Board::ZombieHitTest(int theMouseY, int theMouseX, Board* this)	eax = Zombie*? aZombieMouseOn; ecx, edx		取得点 (theMouseX, theMouseY) 处存在的僵尸，会自动忽略关卡引入阶段及选卡界面的植物僵尸。;当多只僵尸的图像包含此点时，返回纵坐标较大的僵尸纵坐标相同时，返回编号较大的僵尸。;此函数配合鼠标坐标信息可用于获取鼠标悬浮或点击的僵尸。
40E880	Board::IsPlantInGoldWateringCanRange;(Plant* thePlant, eax = int theMouseY, ecx = int theMouseX, edx = Board* this)	al = bool isInRange; ecx, edx		当鼠标手持黄金水壶位于 (theMouseX, theMouseY) 位置时，判断植物是否可以受到浇灌。;当且仅当植物位于水壶的浇灌范围内，且植物为其所在格子内最优先接受浇灌的植物时，返回“是”。
40E940	Board::HighlightPlantsForMouse(int theMouseY, int theMouseX, edi = Board* this)	eax, ecx, edx		当鼠标手持铲子或禅境花园工具位于 (theMouseX, theMouseY) 位置时，;令该工具能够作用的所有植物（禅境花园中额外令植物下方的花盆）进入高亮状态。
40EAB0	Board::UpdateMousePosition(eax = Board* this)	eax, ecx, edx		关卡内鼠标位置信息及其相应悬浮事件等的总更新，是关卡内其他各更新光标相关函数的外层函数。;包括更新光标样式及悬浮标签，并在满足特定条件时令可能受到鼠标操作影响的游戏对象进入高亮状态。
40EF00	Board::UpdateToolTip(Board* this)	eax, ecx, edx		关卡内根据鼠标光标位置更新鼠标悬浮标签，包括标签的显示或隐藏及标签内容等。
40FC70	Board::MouseDownCobcannonFire(int theClickCount, int y, int x, eax = Board* this)	eax, ecx, edx		手持加农炮靶子按下鼠标时，判断点击类型及目标位置，执行取消发射或开始向目标位置发射玉米加农炮。;在点击玉米加农炮的 30cs 内再次按下鼠标时，若目标位置与点炮位置的距离小于 100，则不会开始发射。
40FD30	Board::MouseDownWithPlant(ecx = int theClickCount, int y, int x, Board* this)	eax, ecx, edx		手持植物卡牌、手套、手推车或僵尸卡牌时的鼠标点击，其中手持僵尸时的点击交由42A210的函数处理。;当植物不可被种植在目标位置时，播放相应的提示字幕否则，种植或放置植物，并设置相关教程状态。;额外地，种植紫卡或包扎坚果前令原植物消失柱子关卡尝试种植一列同种植物保龄球关卡播放滚动音效。
410F70	Board::ToolHitTestHelper(eax = HitResult* theHitResult, ecx = Board* this)	eax = Plant*? aPlant; edx		鼠标碰撞检测结果为植物时，从 theHitResult 中读取碰撞的植物（排除非禅境花园关卡的墓碑吞噬者）。;特别地，当碰撞的植物为墓碑吞噬者且当前关卡不为禅境花园时，返回空指针。
410FA0	Board::TutorialArrowShow(int y, int x, edi = Board* this)	eax = TodParticleSystem* anArrowParticle; ;ecx, edx		先销毁旧有的教程粒子系统，然后在 (x, y) 位置处创建教程相关的指向箭头的粒子特效。
411020	Board::TutorialArrowRemove(esi = Board* this)	eax, ecx, edx		清除教程相关的指向箭头的粒子特效。
411,060	Board::MouseDownWithTool;(CursorType theCursorType, int theClickCount, ecx = int y, edx = int x, eax = Board* this)	eax, ecx, edx		手持 theCursorType 物体（工具），鼠标点击 (x, y) 位置处。;包括禅境花园及智慧树关卡中花园工具的使用，及其他关卡中使用铲子铲除植物的判定和相关处理。
411,280	Board::SpecialPlantHitTest(int y, int x, edi = Board* this)	eax = Plant*? aSpecialPlant; ecx, edx		南瓜头和飞行植物（咖啡豆）的特殊鼠标检测，当鼠标不位于上述特殊植物上时，返回 0。
411,470	Board::MouseHitTestPlant(_Out_ HitResult* theHitResult, int y, int x, esi = Board* this)	al = bool isMouseOnPlant; ecx, edx		关卡内的植物鼠标检测。当鼠标上手持有部分特殊道具时，仅考虑可以受到手持道具影响的植物。;若点 (x, y) 位于满足条件的植物上，则 theHitResult = {Plant*, 3}，否则 theHitResult = {0, 0}。
411,730	Board::MouseHitTest(_Out_ HitResult* theHitResult, int y, int x, Board* this)	al = bool isMouseOnGameObject; ecx, edx		关卡内的鼠标碰撞检测，检测当前鼠标位置的物件。需要一个大小为 0x8 的内存区域存储 theHitResult。;返回 theHitResult 的 +0 和 +4 位置分别存储碰撞到的物件的指针（若存在指针）和碰撞到的物件的类型。
411C10	Board::PickUpTool(edx = GameObjectType theObjectType, ebx = Board* this)	eax, ecx, edx		拿起指定的游戏道具，仅在游戏进行中且未暂停时有效。拿起部分道具时会影响当前教程状态。
411F20	Board::MouseDown(int theClickCount, int y, int x, ecx = Board* this)	eax, ecx, edx		关卡界面内的鼠标按下，其中 theClickCount 的取值范围为：;{ -2(右键双击), -1(右键), 1(左键), 2(左键双击), 3(中键) }。		【虚函数】[[[(Board*)]+0]+D8]
412,330	Board::ClearCursor(edi = Board* this)	eax, ecx, edx		清除部分类型的提示字幕，清除并重置鼠标手持相关数据，更新教程相关状态。
412,490	Board::CanInteractWithBoardButtons(esi = Board* this)	al = 0(不能) | 1(能), ecx, edx		根据当前关卡及游戏状态，判断鼠标能否与关卡内的按钮进行交互。
412,540	Board::MouseUp(int theClickCount, int y, int x, ecx = Board* this)	eax, ecx, edx		关卡界面鼠标松开。主要处理主菜单按钮和商店按钮（谁笑到最后关卡为“开始猛攻”按钮）的点击事件。		【虚函数】[[[(Board*)]+0]+E0]
4127A0	Board::Pause(al = bool thePause, ecx = Board* this)	eax, ecx, edx		关卡暂停或取消暂停时，设置音乐和音效的暂停与否。原版中进入暂停的部分被内联至4502C0的函数内。
412,850	Board::GetGraveStonesCount(edx = Board* this)	eax = int aCount; ecx		取得场上的墓碑数量。
412,890	Board::PickSpecialGraveStone(edx = Board* this)	eax, ecx		将场上所有墓碑中的随机一个转变为带有刻字的特殊墓碑。
4128F0	Board::SpawnZombiesFromPool(Board* this)	eax, ecx, edx		召唤珊瑚僵尸。
412A90	Board::SetupBungeeDrop(eax = BungeeDropGrid* theBungeeDropGrid)	ecx, edx		召唤蹦极空投前的预备，初始化一个 {(mX, mY, 0x2710)[54], mGridArrayCount} 的空投格子场地结构。;格子权重数组从 (4, 0, 10000) 开始至 (8, 4, 10000) 结束，故初始化后的 mGridArrayCount = 25。
412B60	Board::BungeeDropZombie(ZombieType theZombieType, eax = BungeeDropGrid* theBungeeDropGrid, Board* this)	eax, ecx, edx		召唤蹦极在 theBungeeDropGrid 相关加权后的随机格子内空投指定僵尸，并将该格子权重置为 1。
412C30	Board::SpawnZombiesFromSky(ebx = Board* this)	eax, ecx, edx		[Tag:蹦极空投,空投蹦极,空投僵尸]召唤蹦极空投僵尸。
412CE0	Board::SpawnZombiesFromGraves(edi = Board* this)	eax, ecx, edx		非泳池关卡中，召唤全场墓碑出僵尸泳池关卡中，召唤珊瑚僵尸屋顶关卡中，额外召唤蹦极空投僵尸。
412E30	Board::TotalZombiesHealthInWave(int theWaveIndex, ebx = Board* this)	al = int aTotalHealth; ecx, edx		取得于第 theWaveIndex 波出现的所有僵尸（蹦极僵尸、被魅惑的僵尸和被召唤出现的僵尸除外）的当前血量之和。;每只僵尸被计入的血量 = 本体血量 + 一类饰品血量 + 二类饰品血量 * 0.2 + 气球血量。
412EE0	Board::SpawnZombieWave(edi = Board* this)	eax, ecx, edx		关卡进入新的一波，生成本波内的出怪僵尸，并更新当前波数、墓碑僵尸倒计时和旗帜波的旗帜升起倒计时等。
4130D0	Board::UpdateGameObjects(ebx = Board* this)	eax, ecx, edx		关卡内更新各游戏对象数据数组中所有植物、僵尸、子弹、物品、小推车、光标预览、光标对象和卡牌。
413220	Board::StopAllZombieSounds(edi = Board* this)	eax, ecx, edx		停止所有僵尸的自带音效。
413260	Board::GetSurvivalFlagsCompleted(esi = Board* this)	al = int aFlagsCompleted; ecx, edx		取得生存模式或谁笑到最后关卡已完成的旗帜数。此函数仅在生存模式和谁笑到最后关卡调用有效。
413320	Board::SurvivalSaveScore(eax = Board* this)	eax, ecx, edx		尝试保存关卡存档内部调用，用于判断生存模式关卡并写入新的生存模式记录数据。
413390	Board::PuzzleSaveStreak(edx = Board* this)	eax, ecx, edx		解密无尽模式关卡（破罐者无尽和我是僵尸无尽）判断并写入新的最高轮数记录数据。
413400	Board::ZombiesWon(Zombie* theZombie = 0, Board* this)	eax, ecx, edx		关卡僵尸胜利，写入生存模式相关记录数据，进行僵尸进家过场相关预备，部分关卡会直接弹出失败对话。;部分特殊关卡的游戏失败不会经历僵尸进家的流程，但依然由此进行关卡失败的处理且此时僵尸指针为 0。
4138D0	Board::IsFinalScaryPotterStage(edx = Board* this)	al = bool ; ecx		判断当前是否为最后一轮的砸罐子关卡（非无尽模式的破罐者关卡，或冒险模式 4-5 关卡的最后一轮）。
413920	Board::IsFinalSurvivalStage(edi = Board* this)	al = bool ; ecx, edx		判断当前是否为最后一轮的生存模式关卡。
4139E0	Board::IsSurvivalStageWithRepick(eax = Board* this)	al = bool ; ecx, edx		判断当前生存模式关卡是否存在下一轮。
413A10	Board::IsLastStandStageWithRepick(eax = Board* this)	al = bool ; ecx, edx		判断谁笑到最后关卡是否存在下一轮，当前为非谁笑到最后关卡或为关卡的最后一轮则返回“否”。
413A40	Board::HasLevelAwardDropped(eax = Board* this)	al = bool ; ecx		判断当前关卡是否已完成过关奖励的掉落，亦可用于判断当前关卡是否已经过关。
413A70	Board::UpdateSunSpawning(esi = Board* this)	eax, ecx, edx		关卡内阳光掉落的更新。
413C00	Board::NextWaveComing(eax = Board* this)	eax, ecx, edx		即将进入下一波时，创建“最后一波”的动画及下一波来临前的音效等（若需要）。
413D00	Board::UpdateZombieSpawning(ecx = Board* this)	eax, ecx, edx		关卡内波数刷新及相关倒计时等的更新，及倒计时中的特定时刻的特殊事件的触发。
414100	Board::UpdateIce(Board* this)	eax, ecx, edx		关卡内更新每一行冰道相关的粒子系统的位置和颜色等。
414270	Board::UpdateProgressMeter(eax = Board* this)	eax, ecx, edx		关卡内计算并更新当前关卡进程的进度条长度。
4144E0	Board::UpdateTutorial(Board* this)	eax, ecx, edx		关卡内更新教程倒计时及部分冒险模式初期的教程相关的提示字幕和教程箭头等的播放。
414CB0	Board::SetTutorialState(TutorialState theTutorialState, Board* this)	eax, ecx, edx		设置当前进行的教程，并根据需求播放相应的提示字幕和教程箭头等。
415920	Board::UpdateGame(ecx = Board* this)	eax, ecx, edx		关卡内游戏玩法的主更新，包括更新游戏对象、浓雾、阳光掉落、僵尸刷新、冰道、水面冻结和关卡进度条等。
415D40	Board::Update(ecx = Board* this)	eax, ecx, edx		关卡界面的总更新函数。是关卡内各种更新函数的外层函数。		【虚函数】[[[(Board*)]+0]+58]
416080	Board::UpdateLayers(Board* this)	eax, ecx, edx		关卡界面调用程序的控件管理器，更新游戏内所有对话的图层位置，并将所有子控件标记为已变更。
416110	Board::RowCanHaveZombies(eax = int theRow, ecx = Board* this)	al = bool ; edx		判断当前关卡第 theRow 行能否刷出僵尸。
416140	Board::DrawIce(eax = int theRow, Graphics* g, ecx = Board* this)	eax, ecx, edx		绘制第 theRow 行的冰道的贴图。
416290	Board::DrawBackdrop(Graphics* g, Board* this)	eax, ecx, edx		绘制关卡的地图背景和舞台效果。
416690	RenderItemSortFunc(const RenderItem& theItem2, const RenderItem& theItem1)	al = theItem1 < theItem2; ecx, edx	0x8	渲染排序函数。当返回 al = 1 时，表示 theItem1 排列于 theItem2 前，反之同理。;函数比较 theItem1 与 theItem2 的渲染顺序，渲染顺序较小者排序较前渲染顺序相同时地址较小者排序较前。
4166C0	Board::AddBossRenderItem;(eax = RenderItem* theRenderList, int& theCurRenderItem, Zombie* theBossZombie, Board* this)	eax, ecx, edx		依次将僵王博士机甲的外侧腿、身体、内侧腿、内侧手臂及冰火球动画（若有）以适当的图层写入渲染列表。;其中，theCurRenderItem 在调用来源处表示当前渲染列表中渲染物品的数量，在函数内表示每次写入的项的索引。
416880	Board::DrawGameObjects(Graphics* g, Board* this)	eax, ecx, edx		按照图层顺序依次绘制关卡界面内所有游戏对象、场景布局、效果和 UI 等。
4173C0	Board::HasProgressMeter(edx = Board* this)	al = bool ; ecx, edx		判断关卡当前是否显示进度条。
417450	Board::ProgressMeterHasFlags(edx = Board* this)	al = bool ; ecx, edx		判断当前关卡的进度条上是否存在标示旗帜波的旗帜标志。
417500	Board::DrawProgressMeter(Graphics* g, Board* this)	eax, ecx, edx		绘制关卡的进度条。
417C80	Board::DrawHouseDoorBottom(eax = Graphics* g, ecx = Board* this)	eax, ecx, edx		僵尸进家的场景下，绘制打开的门位于僵尸图层下方的一部分。仅在前院和后院有实际绘制。
417CF0	Board::DrawHouseDoorTop(eax = Graphics* g, ecx = Board* this)	eax, ecx, edx		僵尸进家的场景下，绘制烟囱或打开的门位于僵尸图层上方的一部分。仅在前院、后院和屋顶有实际绘制。
417DA0	Board::DrawLevel(Graphics* g, Board* this)	eax, ecx, edx		关卡中绘制右下角关卡名称的字符串。
4182D0	Board::DrawZenWheelBarrowButton(int theOffsetY, Graphics* g, Board* this)	eax, ecx, edx		绘制禅境花园的手推车及手推车中的盆栽植物（若有）。
418500	Board::DrawZenButtons(Graphics* g, Board* this)	eax, ecx, edx		绘制禅境花园中的各花园道具，并绘制有使用次数限制的道具的剩余数量。
418B70	Board::DrawShovel(Graphics* g, Board* this)	eax, ecx, edx		非禅境花园和智慧树关卡中，若存在铲子则绘制铲子禅境花园或智慧树关卡中，绘制花园道具。
418C70	Board::DrawDebugText(Graphics* g, edi = Board* this)	eax, ecx, edx		Debug 模式下绘制调试文本。汉化版由于一些汉化遗留问题导致调试字体不可用（会引起绘制时崩溃）。
419AE0	Board::DrawDebugObjectRects(Graphics* g, Board* this)	eax, ecx, edx		Debug 碰撞调试模式下绘制各游戏对象（植物、僵尸、小推车、子弹）的攻击和受伤判定范围矩形。
419EB0	Board::DrawFadeOut(ebx = Graphics* g, eax = Board* this)	eax, ecx, edx		绘制关卡过关后用于淡出关卡界面的白色（冒险模式 X-9 关卡为黑色）闪光效果。
419F60	Board::DrawTopRightUI(Graphics* g, ebx = Board* this)	eax, ecx, edx		绘制关卡内的上层 UI，包括主菜单按钮和禅境花园的商店按钮。上层 UI 会被游戏内的部分对象遮挡。
41A0A0	Board::DrawUIBottom(edi = Graphics* g, Board* this)	eax, ecx, edx		绘制关卡内的底层 UI，包括部分光效（禅境花园光照效果等）和交互对象（卡槽等）的绘制。;特别地，虽然一般字幕属于顶层 UI，但老虎机上的文字会被与卡槽视为一体，故亦在此进行绘制。;当处于黑暗的暴风雨夜、隐形食脑者或非浓雾场景的关卡（即：关卡无浓雾）时，额外绘制关卡内的上层 UI。
41A2A0	Board::DrawUICoinBank(edi = Graphics* g, Board* this)	eax, ecx, edx		关卡内绘制金钱栏及玩家金钱数量。
41A430	Board::ClearFogAroundPlant(ebx = int theSize, Plant* thePlant, Board* this)	eax, ecx, edx		植物开雾，降低植物周围一定大小的区域内的雾的浓度。
41A5D0	Board::UpdateFog(Board* this)	eax, ecx, edx		含有浓雾的关卡中，更新每个格子内的雾的浓度。
41A730	Board::DrawFog(*Graphics, Board* this)	eax, ecx, edx		绘制关卡内的浓雾。当开启 3D 加速时，每一片雾会使用一种独立的、随时间周期性变化的色彩变调。
41AA00	Board::IsScaryPotterDaveTalking(edx = Board* this)	al = bool ; ecx		判断当前是否为破罐者关卡且戴夫正在说话。
41AA40	Board::DrawUITop(Graphics* g, Board* this)	eax, ecx, edx		绘制关卡内的顶层 UI。若当前关卡含有浓雾，则会先绘制关卡内的上层 UI。;顶层 UI 包括部分基础显示（进度条等）、交互对象（戴夫等）、文本（悬浮标签、调试文本等）和光标。;谁笑到最后关卡的“开始猛攻”按钮，以及除老虎机上的文字以外的字幕，也属于顶层 UI 且在此绘制。
41ACF0	Board::Draw(Graphics* g, ecx = Board* this)	eax, ecx, edx		绘制关卡界面，并更新绘制相关的数据记录。		【虚函数】[[[(Board*)]+0]+68]
41AE60	Board::SetMustacheMode(bl = bool theEnableMustache, edi = Board* this)	eax, ecx, edx		启用或禁用 [MUSTACHE] 模式，并依此设置场上所有僵尸胡子的显示与否。
41AF00	Board::SetFutureMode(bl = bool theEnableFuture, edi = Board* this)	eax, ecx, edx		启用或禁用 [FUTURE] 模式，并依此设置场上所有僵尸时尚墨镜的显示与否。
41AF60	Board::SetPinataMode(bl = bool theEnablePinata, esi = Board* this)	eax, ecx, edx		启用或禁用 [PINATA] 模式。
41AFD0	Board::SetDanceMode(bl = bool theEnableDance, Board* this)	eax, ecx, edx		启用或禁用 [DANCE] 模式，并依此设置场上所有未死亡僵尸的动作。
41B0D0	Board::SetSuperMowerMode(bl = bool theEnableSuperMower, edi = Board* this)	eax, ecx, edx		启用或禁用 [TRICKEDOUT] 的超级小推车模式，并依此设置场上所有草坪小推车的形态。
41B1D0	Board::DoTypingCheck(ecx = KeyCode theKey, edx = Board* this)	eax, ecx, edx		游戏关卡内的指令检测函数，内部对 future、pinata 等指令及按键情况进行了判断和记录。
41B820	Board::KeyDown(KeyCode theKey, ecx = Board* this)	eax, ecx, edx		关卡界面键盘按键按下，进行游戏关卡内的按键检测。关卡内的所有按键（指令、暂停键等）均在此处检测。		【虚函数】[[[(Board*)]+0]+C0]
41B950	Board::KeyChar(char theChar, ecx = Board* this)	此函数不改变任何寄存器		【废弃函数】关卡界面输入 theChar 字符，内测版中进行对应的作弊操作，正式版中不进行任何操作。		【虚函数】[[[(Board*)]+0]+BC]
41B960	Board::AddSunMoney(ecx = int theAmount, eax = Board* this)	ecx		增加 theAmount 点阳光，若增加后的阳光数量超过 9990 则将阳光数量重置为 9990 点。
41B980	Board::CountSunBeingCollected(edx = Board* this)	eax = int aCount; ecx		取得场上正在被收集中的阳光的价值总和。
41B9F0	Board::CountCoinsBeingCollected(edx = Board* this)	eax = int aCount; ecx		取得场上正在被收集中的钱币的价值总和。
41BA60	Board::TakeSunMoney(ebx = int theAmount, edi = Board* this)	al = bool canTakeSunMoney; ecx, edx		若当前可以承担 theAmount 点阳光的支出，则减少 theAmount 阳光否则，触发阳光数量闪红的音效和特效。
41BAB0	Board::CanTakeSunMoney(int theAmount, edx = Board* this)	al = bool canTakeSunMoney; ecx		判断当前阳光数量及正在收集中的阳光数量之和能否承担 theAmount 点阳光的支出。
41BAD0	Board::ProcessDeleteQueue(esi = Board* this)	eax, ecx, edx		处理被删除的游戏对象，以默认析构函数销毁对象并在对应的数据数组中回收其占用的序列和编号。
41BE50	Board::IsConveyorBeltLevel(eax = Board* this)	al = bool ; ecx, edx		判断当前关卡是否为传送带关卡。
41BEE0	Board::GetNumSeedsInBank(edi = Board* this)	eax = int aNumSeeds; ecx, edx		根据关卡的卡槽格数限制或当前已购买的卡槽格数等，取得应有的卡槽格数。
41C010	Board::StageIsNight(eax = Board* this)	al = bool isNight		判断当前关卡是否为夜晚模式。
41C040	Board::StageHasGraveStones(edx = Board* this)	al = bool hasGraveStones; ecx		判断当前关卡是否在开局出现墓碑。
41C0B0	Board::StageHasRoof(eax = Board* this)	al = bool hasRoof		判断当前场景是否为屋顶上（屋顶或月夜场景）。
41C0D0	Board::StageHasPool(eax = Board* this)	al = bool hasPool		判断当前场景是否为后院（泳池或浓雾场景）。
41C0F0	Board::StageHasZombieWalkInFromRight(eax = Board* this)	al = bool ; ecx, edx		判断当前关卡是否会从场地最右侧刷新出现僵尸。
41C170	Board::StageHasFog(edx = Board* this)	al = bool hasFog; ecx		判断当前场景是否存在浓雾。
41C1C0	Board::LeftFogColumn(ecx = Board* this)	eax = int 浓雾的起始列		取得当前关卡雾的起始列。
41C210	Board::GetSeedPacketPositionX(edi = int theIndex, eax = Board* this)	eax = int aPosX; ecx, edx		获取卡槽中的第 theIndex 张卡牌位于卡槽中的正确位置的横坐标。
41C290	Board::GetSeedBankExtraWidth(eax = Board* this)	eax = int anExtraWidth; ecx		根据当前卡槽格数，取得卡槽相较于基础宽度（即 6 槽时的宽度）延伸出的额外宽度。
41C2D0	Board::PlantingPixelToGridX(edx = int theY, int theX, eax = SeedType theSeedType, ecx = Board* this)	eax = int aGridX; ecx, edx		根据给定的坐标和卡牌类型，计算种植的列数。此函数内部根据卡牌类型修正纵坐标后调用了41C4C0的函数。
41C320	Board::PlantingPixelToGridY(int theY, int theX, eax = SeedType theSeedType, esi = Board* this)	eax = int aGridY; ecx, edx		根据给定的坐标和卡牌类型，计算种植的行数。
41C4C0	Board::PixelToGridX(edi = int theY, eax = int theX, ecx = Board* this)	eax = int aGridX; ecx, edx		根据指定的坐标，计算该点位于地图中的列数。其中，参数 theY 仅在禅境花园关卡内有实用。
41C530	Board::PixelToGridXKeepOnBoard(eax = int theY, esi = int theX, ebx = Board* this)	eax = int aGridX; ecx, edx		根据指定的坐标，计算该点位于地图中的列数。当计算结果的列数 ≤ 0 时，返回 0。
41C550	Board::PixelToGridY(ecx = int theY, eax = int theX, edx = Board* this)	eax = int aGridY; ecx, edx		根据指定的坐标，计算该点位于地图中的行数。对于地图外的点，返回 -1。
41C650	Board::PixelToGridYKeepOnBoard(edi = int theY, eax = int theX, ebx = Board* this)	eax = int aGridY; ecx, edx		根据指定的坐标，计算该点位于地图中的行数。;当参数中的 theX 不足 80 时，以 80 计算。当计算结果的行数 ≤ 0 时，返回 0。
41C680	Board::GridToPixelX(esi = int theGridY, eax = int theGridX, ecx = Board* this)	eax = int aPixelX; ecx, edx		根据指定的行和列，结合当前地图等要素取得相应的横坐标。对于非禅境花园相关场景，参数 esi 无实用。
41C6C0	Board::GetPosYBasedOnRow(ecx = int theRow, float thePosX, eax = Board* this)	st(0) = aPosY; eax, ecx, edx		根据行和横坐标计算浮点型的纵坐标。
41C740	Board::GridToPixelY(eax = int theGridY, ecx = int theGridX, ebx = Board* this)	eax = int aPixelY; ecx, edx		根据指定的行数和列数，结合当前地图等要素取得格子的纵坐标返回给 eax。
41C7F0	Board::ZombieTryToGet(ecx = ZombieID theZombieID, edx = Board* this)	eax = Zombie*? aZombie; edx		在僵尸数据数组中取得指定编号的僵尸，若该编号的僵尸不存在则返回 0。
41C820	GetRectOverlap(ecx = const Rect& rect2, edi = const Rect& rect1)	eax = 横向重叠部分宽度(有重叠部分) | ;      横向间距的相反数(无重叠部分); ;ecx, edx		取得两个矩形横向重叠部分的长度，若其横向无重叠部分则返回其横向间距的相反数。
41C850	GetCircleRectOverlap(eax = const Rect& theRect, int theRadius, edx = int theCircleY, ecx = int theCircleX)	al = bool overlap; ecx, edx	0x4	判断矩形 theRect 是否与以 (theCircleX, theCircleY) 为圆心、theRadius 为半径的圆有重叠部分。
41C8F0	Board::IterateZombies(esi = Zombie*& theZombie, edx = Board* this)	al = 0(未找到) | 1(找到); ecx		【用于遍历僵尸】;在僵尸数据数组中取得 [esi] 地址处的僵尸的下一只僵尸，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一只僵尸的指针写入 [esi] 地址处。
41C950	Board::IteratePlants(esi = Plant*& thePlant, edx = Board* this)	al = 0(未找到) | 1(找到); ecx		【用于遍历植物】;在植物数据数组中取得 [esi] 地址处的植物的下一株植物，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一株植物的指针写入 [esi] 地址处。
41C9B0	Board::IterateProjectiles(esi = Projectile*& theProjectile, edx = Board* this)	al = 0(未找到) | 1(找到); ecx		【用于遍历子弹】;在子弹数据数组中取得 [esi] 地址处的子弹的下一个子弹，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一个子弹的指针写入 [esi] 地址处。
41CA10	Board::IterateCoins(esi = Coin*& theCoin, edx = Board* this)	al = 0(未找到) | 1(找到); ecx		【用于遍历掉落物品】;在物品数据数组中取得 [esi] 地址处的物品的下一个物品，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一个物品的指针写入 [esi] 地址处。
41CA70	Board::IterateLawnMowers(esi = LawnMower*& theLawnMower, edx = Board* this)	al = 0(未找到) | 1(找到); ecx		【用于遍历小推车】;在小推车数据数组中取得 [esi] 地址处的小推车的下一辆小推车，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一辆小推车的指针写入 [esi] 地址处。
41CAD0	Board::IterateGriditems(esi = GridItem*& theGridItem, edx = Board* this)	al = 0(未找到) | 1(找到); ecx		【用于遍历场地物品】;在场地物品数据数组中取得 [esi] 地址处的场地物品的下一个场地物品，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一个场地物品的指针写入 [esi] 地址处。
41CB30	Board::IterateParticleSystems(esi = TodParticleSystem*& theParticle, eax = Board* this)	al = 0(未找到) | 1(找到); ecx, edx		【用于遍历粒子系统】;在粒子系统数据数组中取得 [esi] 地址处的粒子系统的下一个粒子系统，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一个粒子系统的指针写入 [esi] 地址处。
41CB90	Board::IterateReanimations(esi = Reanimation*& theReanimation, eax = Board* this)	al = 0(未找到) | 1(找到); ecx, edx		【用于遍历动画】;在动画数据数组中取得 [esi] 地址处的动画的下一个动画，并将其指针写入 [esi] 地址处。;若调用前 [esi] 地址处的值为空指针，则将指向当前第一个动画的指针写入 [esi] 地址处。
41CBF0	Board::KillAllPlantsInRadius(int theX, ebx = int theY, edi = Board* this)	eax, ecx, edx		在 (theX, theY) 处创建爆炸。此爆炸仅对植物有效且爆炸范围在函数内部已经固定。
41CC60	Board::SeedNotRecommendedForLevel(esi = SeedType theSeedType, edx = Board* this)	eax = unsigned int aNotRecFlags		判断 theSeedType 卡牌是否推荐在当前关卡携带，并返回不推荐携带的原因。 => enum NotRecommend
41CD70	Board::CountCoinByType(ebx = CoinType theCoinType, edx = Board* this)	eax = int aCount; ecx		取得场上类型为 theCoinType 的物品的数量。
41CDB0	Board::DropLootPiece(int theDropFactor, int thePosY, int thePosX, edi = Board* this)	eax, ecx, edx		在可能范围内一定程度地随机掉落奖励物品，一般地，theDropFactor 的值越大，掉落较高级物品的概率越高。;部分固定掉落的物品（如小游戏模式礼盒等）不受概率影响，部分物品的掉落存在上限限制（如花园植物等）。
41D2C0	Board::CanDropLoot(edx = Board* this)	al = bool ; ecx, edx		判断能否掉落物品。一般地，在冒险模式 2-1 关卡开启之后才可以触发掉落。
41D320	Board::BungeeIsTargetingCell(edi = int theGridY, ebx = int theGridX, edx = Board* this)	al = bool ; ecx		判断是否存在以 (theGridX, theGridY) 格子为目标的蹦极僵尸。
41D390	Board::GetBossZombie(edx = Board* this)	eax = Zombie*? aBossZombie; ecx		取得当前编号最小的僵王博士。若当前不存在僵王博士，则返回 0。
41D3D0	Board::FindUnbrellaPlant(edi = int theGridY, ebx = int theGridX, edx = Board* this)	eax = Plant*? anUmbrellaPlant; ecx		取得 (theGridX, theGridY) 格子 3×3 范围内编号最小的叶子保护伞植物。
41D450	Board::DoFwoosh(int theRow, ebx = Board* this)	eax, ecx, edx		创建第 theRow 行一整行的 12 个火爆辣椒火焰动画，并刷新场上现存的所有辣椒火焰的持续时间。
41D630	Board::UpdateFwoosh(ebx = Board* this)	eax, ecx, edx		更新辣椒火焰的持续时间和每一行火焰的淡出动画的触发。
41D730	Board::UpdateGridItems(edi = Board* this)	eax, ecx, edx		关卡界面更新数据数组中的所有场地物品。
41D7D0	Board::PlantingRequirementsMet(eax = SeedType theSeedType, edx = Board* this)	al = bool ; ecx, edx		判断 theSeedType 紫卡植物种植需要的条件是否满足，对于非紫卡植物总是返回“是”。
41D8A0	Board::KillAllZombiesInRadius(int theDamageRangeFlags, bool theBurn, int theRowRange, ;                              int theRadius, int theY, int theX, int theRow, Board* this)	eax, ecx, edx		在 theRow 行 (theX, theY) 位置处创建半径为 theRadius 的攻击能力类型为 theDamageRangeFlags 的爆炸。;theBurn 表示爆炸是否对僵尸触发灰烬效果。爆炸有效范围为从爆炸所在行开始向上下各 theRowRange 行。;会清除以爆炸所在格子为中心 theRowRange×theRowRange 范围内的梯子。此爆炸仅对僵尸和梯子有效。
41DA10	Board::GetNumWavesPerSurvivalStage(eax = Board* this)	eax = int aWaveCount; ecx, edx		取得当前生存模式或谁笑到最后关卡每一轮的波数。
41DA50	Board::RemoveParticleSystemByType(edi = ParticleEffect theEffectType, ebx = Board* this)	eax, ecx, edx		销毁所有类型为 theEffectType 的粒子系统。
41DA90	Board::PlantUsesAcceleratedPricing(eax = SeedType theSeedType, Board* this)	al = bool ; ecx		判断植物是否应用价格提升。当且仅当植物为紫卡植物且当前为无尽生存模式时，返回“是”。
41DAE0	Board::GetCurrentPlantCost;(edx = SeedType theImitaterType, eax = SeedType theSeedType, edi = Board* this)	eax = int aCost; ecx, edx		取得植物的当前价格。
41DB40	Board::CanUseGameObject(ecx = GameObjectType theGameObject, eax = Board* this)	al = 0(不可用) | 1(可用); ecx, edx		禅境花园或智慧树关卡中，判断 theGameObject 的道具或按钮功能是否可用。不可用的功能将被隐藏。
41DC40	Sexy::TRect<int>::Contains(esi = int theY, edx = int theX, eax = Rect* this)	eax = 0(否) | 1(是); ecx		判断点 (theX, theY) 是否位于矩形内。
41DC70	std::string::append(unsigned int _Count, unsigned int _Roff, const std::string& _Right, ecx = std::string* this)	eax = *this; ecx, edx		将字符串 _Right 的一个从 _Roff 位置开始 _Count 长度的子字符串连接在字符串 *this 之后。
41DD70	DataArray<Zombie>::DataArrayDispose(eax = DataArray<Zombie>* this)	eax, ecx, edx		释放僵尸数据数组，释放其中的所有僵尸，并释放僵尸区域占用的内存空间。
41DDA0	DataArray<Zombie>::DataArrayAlloc(esi = DataArray<Zombie>* this)	eax = Zombie* aZombie; ecx, edx		初始化创建一个不包含任何数据的新僵尸，在僵尸数组中申请该僵尸的内存区域。
41DE20	DataArray<Zombie>::DataArrayTryToGet(ecx = unsigned int theId, edx = DataArray<Zombie>* this)	eax = Zombie*? aZombie; edx		取得指定编号的僵尸的指针给 eax。若该编号的僵尸不存在则返回 eax = 0。
41DE50	DataArray<Plant>::DataArrayDispose(esi = DataArray<Plant>* this)	eax, ecx, edx		释放植物数据数组，释放其中的所有植物，并释放植物区域占用的内存空间。
41DE80	DataArray<Plant>::DataArrayAlloc(esi = DataArray<Plant>* this)	eax = Plant* aPlant; ecx, edx		初始化创建一个不包含任何数据的新植物，在植物数组中申请该植物的内存区域。
41DF00	DataArray<Plant>::DataArrayTryToGet(ecx = unsigned int theId, edx = DataArray<Plant>* this)	eax = Plant*? aPlant; edx		取得指定编号的植物的指针给 eax。若该编号的植物不存在则返回 eax = 0。
41DF30	DataArray<Projectile>::DataArrayDispose(eax = DataArray<Projectile>* this)	eax, ecx, edx		释放子弹数据数组，释放其中的所有子弹，并释放子弹区域占用的内存空间。
41DF60	DataArray<Projectile>::DataArrayAlloc(esi = DataArray<Projectile>* this)	eax = Projectile* aProjectile; ecx, edx		创建子弹，在子弹数组中申请该子弹的内存区域。
41E010	DataArray<Coin>::DataArrayDispose(eax = DataArray<Coin>* this)	eax, ecx, edx		释放物品数据数组，释放其中的所有物品，并释放物品区域占用的内存空间。
41E040	DataArray<Coin>::DataArrayAlloc(edi = DataArray<Coin>* this)	eax = Coin* aCoin; ecx, edx		创建物品，在物品数组中申请该物品的内存区域。
41E0F0	DataArray<LawnMower>::DataArrayDispose(esi = DataArray<LawnMower>* this)	eax, ecx, edx		释放小推车数据数组，释放其中的所有小推车，并释放小推车区域占用的内存空间。
41E120	DataArray<LawnMower>::DataArrayAlloc(esi = DataArray<LawnMower>* this)	eax = LawnMower* aLawnMower; ecx, edx		创建小推车，在小推车数组中申请该小推车的内存区域。
41E190	DataArray<GridItem>::DataArrayDispose(esi = DataArray<GridItem>* this)	eax, ecx, edx		释放场地物品数据数组，释放其中的所有场地物品，并释放场地物品区域占用的内存空间。
41E1C0	DataArray<GridItem>::DataArrayAlloc(esi = DataArray<GridItem>* this)	eax = GridItem* aGridItem; ecx, edx		创建场地物品，在场地物品数组中申请该场地物品的内存区域。
41E240	DataArray<GridItem>::IterateNext(esi = GridItem*& theItem, edx = DataArray<GridItem>* this>	al = 0(未找到) | 1(找到); ecx, edx		遍历取得 theItem 场地物品的下一个场地物品。
41E290	std::operator+<char>(edi = const char* _Right, const std::string& _Left, esi = _Out_ std::string&& _Result)	eax = std::string&& _Result; ecx, edx	0x4	将字符数组 _Right 连接在字符串 _Left 之后，返回连接后的新的字符串。
41E340	std::operator+<char>(const std::string& _Right, const std::string& _Left, esi = _Out_ std::string&& _Result)	eax = std::string&& _Result; ecx, edx	0x8	将字符串 _Right 连接在字符串 _Left 之后，返回连接后的新的字符串。
41E3E0	std::string::append(unsigned int _Count, const char* _Ptr, ecx = std::string* this)	eax = *this; ecx, edx		将字符数组 _Ptr 的前 _Count 长度的字符连接在字符串后，返回连接后的原字符串。
41E4D0	DataArray<Zombie>::DataArrayFreeAll(edi = DataArray<Zombie>* this)	eax, ecx, edx		以析构函数销毁并释放僵尸数据数组中的所有僵尸。
41E590	DataArray<Plant>::DataArrayFreeAll(eax = DataArray<Plant>* this)	eax, ecx, edx		以析构函数销毁并释放植物数据数组中的所有植物。
41E600	DataArray<Projectile>::DataArrayFreeAll(edi = DataArray<Projectile>* this)	eax, ecx, edx		以析构函数销毁并释放子弹数据数组中的所有子弹。
41E6B0	DataArray<Coin>::DataArrayFreeAll(edi = DataArray<Coin>* this)	eax, ecx, edx		以析构函数销毁并释放物品数据数组中的所有物品。
41E760	DataArray<LawnMower>::DataArrayFreeAll(eax = DataArray<LawnMower>* this)	eax, ecx, edx		以析构函数销毁并释放小推车数据数组中的所有小推车。
41E7D0	DataArray<GridItem>::DataArrayFreeAll(eax = DataArray<GridItem>* this)	eax, ecx, edx		以析构函数销毁并释放场地物品数据数组中的所有场地物品。
41E840	std::_Sort<RenderItem*>(bool (*_Pred)(RenderItem&, RenderItem&), int _Ideal, ;                       RenderItem* _Last, RenderItem* _First)	eax, ecx, edx	0x10	根据给定的规则函数 _Pred 对渲染项目数组进行排序。首次调用时，一般令 _Ideal = 渲染项目数量。;函数默认递归调用自身，每次递归令 _Ideal /= 2, _Ideal += _Ideal / 2 后将其传递给下一次调用。;当 _ideal 的值减少至零时，将被认为递归的深度太深，函数将停止递归调用而转为调用堆排序。;此函数原用于绘图时的渲染排序，组成渲染项目数组的元素只能是 (a, b, c) 形式的 RenderItem;若要自定义规则函数，需保证两个参数均为 push 入栈，且函数仅使用 ret 返回，返回值为布尔型 al。
41E980	std::_Unguarded_partition<RenderItem*>;(bool (*_Pred)(RenderItem&, RenderItem&), RenderItem* _Last, ; RenderItem* _First, _Out_ std::pair<RenderItem, RenderItem>&& _Result)	eax = &&_Result(_MinItem, _MaxItem); ;ecx, edx	0x10	根据给定的规则函数将排序数组进行划分，返回划分结果的上下界组成的数值对。在给定的规则下，其满足：;_MinItem ≤ _MidItem ＜ _MaxItem，即所有与中值相等的项目都被包含在该数值对的两项之间。
41EC40	std::_Insertion_sort<RenderItem*>;(bool (*_Pred)(RenderItem&, RenderItem&), RenderItem* _Last, RenderItem* _First)	eax, ecx, edx	0xC	根据给定的规则函数 _Pred 对 _First 和 _Last 之间的 RenderItem 进行插入排序。;此函数仅在需要参与排序的项目数量较少（不超过 0x20 个）时被使用，用于提高排序的效率。
41ECD0	std::_Median<RenderItem*>(bool (*_Pred)(RenderItem&, RenderItem&), RenderItem* _Last, ;                         RenderItem* _Medium, eax = RenderItem* _First)	eax = RenderItem* _Mid; ecx, edx	0xC	当数组大小不大于 0x28 时，函数仅对数组首、中、尾的三个项目进行排序并返回中间值;当数组大小大于 0x28 时，将所有 RenderItem 分隔为 8 段，并将其 9 个顶点的项目分 3 组进行排序，;然后将排序后的 3 组项目中每组的中间值再次进行排序，返回最终排序结果的中间值。
41ED80	std::_Make_heap<RenderItem*>;(bool (*_Pred)(RenderItem&, RenderItem&), eax = RenderItem* _Last, ecx = RenderItem* _First)	eax, ecx, edx	0x4	将 _First 和 _Last 之间的 RenderItem 的数组转化为堆，排序规则函数决定了生成的堆为大堆顶或小堆顶。;在排序函数中，当 QuickSort 递归过深时，将转为使用堆排序，此函数为进行堆排序前的预备。
41EDF0	std::_Sort_heap<RenderItem*>;(bool (*_Pred)(RenderItem&, RenderItem&), ecx = RenderItem* _Last, eax = RenderItem* _First)	eax, ecx, edx	0x4	根据给定的排序规则函数 _Pred 对 _First 和 _Last 之间的渲染项目堆进行排序。
41EE80	std::_Med3<RenderItem*>(bool (*_Pred)(RenderItem&, RenderItem&), esi = RenderItem* _Last, ;                       eax = RenderItem* _Medium, edi = RenderItem* _First)	eax, ecx, edx	0x4	将特定的 3 个 RenderItem 进行排序。
41EF10	std::_Adjust_heap<RenderItem*>(bool (*_Pred)(RenderItem&, RenderItem&), RenderItem _Val, ;                              int _Bottom, eax = int _Hole, ebx = RenderItem* _First)	eax, ecx, edx	0x14	根据排序规则函数调整堆中的一个元素的位置：函数先令其下溯至堆底，再将其上溯至合适的位置。;其中，_First 指向堆顶，_Val 为调整的元素，_Hole 表示其原位置距离堆顶的高度，_Bottom 为堆高度。
41EFC0	std::_Push_heap<RenderItem*>;(bool (*_Pred)(RenderItem&, RenderItem&), RenderItem _Val, int _Top, eax = int _Hole, RenderItem* _First)	eax, ecx, edx	0x18	将 _Val 上溯至堆中合适的位置（完全二叉树中合适的节点处），且最高不能超过 _Top 指明的位置。;其中，参数的 _First 指向堆顶，_Hole 为该元素在经过下溯过程后所处于的位置距离堆顶的高度。;此函数在 _Adjust_heap() 的下溯过程完成后调用，参数的 _Top 的值等于传入该函数的 _Top。;即：元素可上溯至的最大高度，等于该元素在被调整之前位于堆中的高度。
41F050	std::_Rotate<RenderItem*>(RenderItem* _Last, eax = RenderItem* _Mid, RenderItem* _First)	eax, ecx, edx	0x8	将 [_First, _Last) 区间内的所有 RenderItem 进行左旋转（类似循环左移），使得 _Mid 成为新的首项。
41F160	std::string::basic_string(const std::string& _Right, ecx = std::string* this)	eax = *this; ecx, edx		字符串复制。需要一个大小为 0x1C 的内存区域用于构造 this。
41F190	TodCurveSineWave(float theTime)	st(0) = result; eax	0x4	以弧度制计算 theTime 的正弦值。
41F1B0	Challenge::Challenge(edi = Challenge* this)	eax = *this; ecx, edx		初始化关卡属性基础数据，老虎机关卡额外创建老虎机拉杆的动画。;需要一个大小为 0xBC 的内存区域用于构造 this。
41F320	Challenge::LoadBeghouledBoardState(ebx = BeghouledBoardState* theBoardState, Challenge* this)	eax, ecx, edx		将场上每个格子中的植物类型载入 theBoardState（本质为一个 9 列 × 6 行的植物类型数组）中。
41F380	Challenge::InitLevel(edi = Challenge* this)	eax, ecx, edx		初始化关卡，进行关卡基础场面和部分游戏对象的布局（包括背景音效、传送带初始卡牌设置、解谜布置等）。
41F6E0	Challenge::StartLevel(Challenge* this)	eax, ecx, edx		关卡开始，设定关卡的部分特殊机制，创建玩法相关的提示字幕，并对关卡的状态和预设等进行适当的微调。
420150	Challenge::BeghouledTwistValidMove;(ecx = BeghouledBoardState* theBoardState, edx = int theGridY, eax = int theGridX)	al = bool isValidMove		宝石迷阵转转看关卡，判断是否能以 (theGridX, theGridY) 格子为起点进行尝试转动。;能够转动要求 (theGridX, theGridY) 格子自身及其右一格、下一格、右下一格的四个格子内均存在植物。
420190	Challenge::BeghouledTwistMoveCausesMatch;(edi = BeghouledBoardState* theBoardState, ecx = int theGridY, eax = int theGridX)	al = bool causesMatch; ecx, edx		宝石迷阵转转看关卡，判断一次以 (theGridX, theGridY) 格子为起点的转动是否会形成可消除的匹配。
420220	Challenge::BeghouledTwistSquareFromMouse;(int& theGridY, ebx = int& theGridX, eax = int theY, ecx = int theX, Challenge* this)	al = bool 是否位于可移动区域范围内; ;ecx, edx		宝石迷阵转转看关卡，取得点 (theX, theY) 所在的行数和列数分别赋值给 theGridY 和 theGridX。;若给定的点位于可移动范围（从 (0, 0) 至 (3, 6) 的 28 个格子）之外，则令 theGridX, theGridY = -1。
420280	Challenge::BeghouledTwistMouseDown(int y, int x, Challenge* this)	eax, ecx, edx		宝石迷阵转转看关卡，鼠标点击 (x, y) 位置，判断能否移动和能否配对，并依此执行相应的事件。
420670	Challenge::BeghouledStartFalling(eax = ChallengeState theState, ecx = Challenge* this)	eax, ecx, edx		宝石迷阵关卡设置关卡状态和倒计时，同时清除“没有配对的植物”提示字幕。
4206E0	Challenge::BeghouledIsValidMove;(esi = BeghouledBoardState* theBoardState, int theToRow, ecx = int theToColumn, int theFromRow, ; eax = int theFromColumn, edx = Challenge* this)	al = bool isValidMove; ecx, edx		宝石迷阵关卡，判断从当前格子至目标格子的移动是否成立及是否会形成可消除的匹配。
420760	Challenge::BeghouledDragUpdate(edx = int y, eax = int x, Challenge* this)	eax, ecx, edx		宝石迷阵关卡鼠标拖动的更新，当拖动达到一定距离时执行植物移动和配对相关的判定和事件。
420A50	Challenge::BeghouledRemoveHorizontalMatch;(eax = BeghouledBoardState* theBoardState, int theGridY, ecx = int theGridX, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，移除从 (theGridX, theGridY) 格子处开始水平向右的配对的所有植物。
420B60	Challenge::BeghouledRemoveVerticalMatch;(BeghouledBoardState* theBoardState, eax = int theGridY, esi = int theGridX, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，移除从 (theGridX, theGridY) 格子处开始竖直向下的配对的所有植物。
420C60	Challenge::BeghouledFallIntoSquare;(BeghouledBoardState* theBoardState, int theGridY, int theGridX, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，令 (theGridX, theGridY) 格子竖直上方的第一株植物掉落至格子处。
420D50	Challenge::BeghouledMakePlantsFall(BeghouledBoardState* theBoardState, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，根据场地上的空置格子情况令各植物掉落至正确的位置。
420DB0	Challenge::BeghouledUpdateCraters(eax = Challenge* this)	eax, ecx, edx		宝石迷阵关卡根据场上弹坑的存在与否设置第 4 格卡牌（填补弹坑）的可用与否。仅卡槽格数为 5 时有效。
420E10	Challenge::BeghouledClearCrater(Challenge* this)	eax, ecx, edx		宝石迷阵关卡，填补 1 个弹坑，并更新弹坑卡牌的可用与否。
420EF0	Challenge::BeghouledScore;(bool theIsHorizontal, int theNumPlants, int theGridY, int theGridX, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，当完成一次 (theGridX, theGridY) 格子处开始的 theNumPlants 连消除时，设置合适的卡槽和提示字幕。当总消除次数未达到过关需求时，在适当的位置创建若干阳光掉落否则，触发过关事件。
421430	Challenge::BeghouledRemoveMatches(eax = BeghouledBoardState* theBoardState, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，消除场上所有可消除的配对并获得相应的得分。
4214C0	Challenge::BeghouledHorizontalMatchLength;(edi = BeghouledBoardState* theBoardState, edx = int theGridY, ecx = int theGridX)	eax = int aMatchLength; ecx, edx		取得从指定格子开始向右的水平方向连续匹配的个数。当该格子不是向右连续匹配的起点时，返回 0。
421520	Challenge::BeghouledVerticalMatchLength;(ecx = BeghouledBoardState* theBoardState, edx = int theGridY, eax = int theGridX)	eax = int aMatchLength; ecx, edx		取得从指定格子开始向下的竖直方向连续匹配的个数。当该格子不是向下连续匹配的起点时，返回 0。
421590	Challenge::BeghouledBoardHasMatch(eax = BeghouledBoardState* theBoardState)	al = bool hasMatch; ecx, edx		宝石迷阵关卡判断当前是否存在可以消除的匹配。
4215E0	Challenge::BeghouledPickSeed(bool theAllowMatches, BeghouledBoardState* theBoardState, int theGridY, ;                             eax = int theGridX, Challenge* this)	al = SeedType aSeedType; ecx, edx		宝石迷阵关卡，随机选取一种新出现并掉落至 (theGridX, theGridY) 格子处的植物的类型。;其中，theAllowMatches 表示是否允许掉落填充后的局面本身存在可消除的配对。
4216E0	Challenge::BeghouledFillHoles(bool theAllowMatches, BeghouledBoardState* theBoardState, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，分别随机选取新出现的植物的类型并用于填补所有不存在植物且不存在弹坑的格子。
421750	Challenge::BeghouledCreatePlants;(eax = BeghouledBoardState* theNewBoardState, ecx = BeghouledBoardState* theOldBoardState, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，对比新旧的 BeghouledBoardState，在所有产生新植物的格子创建植物掉落。
421810	Challenge::BeghouledPopulateBoard(edi = Challenge* this)	eax, ecx, edx		宝石迷阵关卡，填充所有空缺植物的格子，并根据填充的结果创建掉落的植物。
421890	Challenge::BeghouledCheckForPossibleMoves(BeghouledBoardState* theBoardState, Challenge* this)	al = bool hasPossibleMoves; ecx, edx		宝石迷阵关卡，判断当前是否存在能够产生可消除的匹配的移动操作。
421920	Challenge::MouseMove(edx = int y, eax = int x, esi = Challenge* this)	al = bool isBeghouledMouseOnPlant; ecx,edx		当鼠标移动时，更新宝石迷阵关卡的鼠标拖动和禅境花园的挂机状态恢复。
4219B0	Challenge::UpdateToolTip(ecx = int theY, edx = int theX, edi = Challenge* this)	al = bool isOnSlotMachineHandle; ecx, edx		更新老虎机拉杆的鼠标悬浮标签。
421B10	Challenge::MouseDownWhackAZombie(int theY, int theX, Challenge* this)	eax, ecx, edx		锤僵尸关卡鼠标按下，寻找并攻击目标僵尸。
421E10	Challenge::AdvanceCrazyDaveDialog(eax = Challenge* this)	eax, ecx, edx		破罐者关卡推进戴夫进度，当戴夫不存在下一句话时则令戴夫离场。
421F10	Challenge::MouseDown(eax = HitResult* theHitResult, int theClickCount, int y, int x, Challenge* this)	al = bool 是否为有特殊意义的鼠标按下; ;ecx, edx		当鼠标按下时，根据关卡和状态等分别执行不同的鼠标按下事件。
4221B0	Challenge::SlotMachineGetHandleRect(eax = _Out_ Rect&& aSlotMachineHandleRect, ecx = Challenge* this)	eax = Rect&& aSlotMachineHandleRect		老虎机关卡，取得老虎机拉杆的判定范围矩形。
4221E0	Challenge::MouseUp(edi = Challenge* this)	al = 0; ecx, edx		宝石迷阵关卡鼠标松开，取消按住的植物并播放点击拖拽的提示字幕。
422290	Challenge::ClearCursor(edx = Challenge* this)	eax, ecx, edx		宝石迷阵和锤僵尸关卡重置鼠标状态的记录和鼠标手持物。
4222F0	Challenge::UpdateBeghouledPlant(Plant* thePlant, Challenge* this)	al = bool isPlantMoving; ecx, edx		宝石迷阵关卡更新植物移动相关的位置数据，当植物在更新后仍未处于正确的位置则返回 true。
422,480	Challenge::BeghouledFlashPlant(edx = int theToY, ecx = int theToX, int theFromY, eax = int theFromX, ;                               int theFlashY, int theFlashX, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，当一次从 (theFromX, theFromY) 格子至 (theToX, theToY) 格子的拖动产生可消除的匹配时，;令拖动后位于 (theFlashX, theFlashY) 格子内的植物闪光。
422,510	Challenge::BeghouledTwistFlashMatch;(eax = int theGridY, int theGridX, ecx = BeghouledBoardState* theBoardState, Challenge* this)	al = bool isMoveCausesMatch; ecx, edx		宝石迷阵转转看关卡，判断从 (theGirdX, theGridY) 格子开始的一次转动能否产生可消除的匹配。;若能，则令转动涉及的四株植物闪光。
422,770	Challenge::BeghouledFlashFromBoardState(int theToY, int theToX, int theFromY, ebx = int theFromX, ;                                        eax = BeghouledBoardState* theBoardState, Challenge* this)	al = bool isMoveCausesMatch; ecx, edx		宝石迷阵关卡，判断从 (theFromX, theFromY) 至 (theToX, theToY) 格子的一次移动能否产生可消除的匹配。;若能，则令移动产生匹配的三株植物闪光。
4228E0	Challenge::BeghouledCancelMatchFlashing(edi = Challenge* this)	eax, ecx, edx		取消提示闪烁，淡出场上所有植物的闪光效果。
422930	Challenge::BeghouledFlashAMatch(Challenge* this)	eax, ecx, edx		令场上一组只经过一次操作即可形成可消除的匹配的植物闪光。
4229F0	Challenge::UpdateBeghouled(ecx = Challenge* this)	eax, ecx, edx		【关卡特性函数】宝石迷阵、宝石迷阵转转看关卡的特性更新函数。
422CD0	Challenge::UpdateConveyorBelt(Challenge* this)	eax, ecx, edx		关卡传送带的更新。
4234A0	Challenge::UpdateRainingSeeds(Challenge* this)	eax, ecx, edx		【关卡特性函数】雨中种植物关卡的特性更新函数。
423,670	Challenge::UpdateStormyNight(edi = Challenge* this)	eax, ecx, edx		【关卡特性函数】黑暗的暴风雨夜关卡的特性更新函数。
423,800	Challenge::UpdateSlotMachine(Challenge* this)	eax, ecx, edx		【关卡特性函数】老虎机关卡的特性更新函数。
4244C0	Challenge::BeghouledCheckStuckState(esi = Challenge* this)	eax, ecx, edx		宝石迷阵关卡，检测当前是否存在可触发消除的移动。若无解，则播放相应的提示字幕并设置关卡状态。
424,590	Challenge::ZombieAtePlant(ecx = Plant* thePlant, Challenge* this)	eax, ecx, edx		宝石迷阵关卡中，当僵尸吃掉一株植物后，标记该植物所在格子存在弹坑，并更新相关的提示字幕和关卡状态。
4246B0	Challenge::Update(eax = Challenge* this)	eax, ecx, edx		关卡玩法及特性相关的总更新。
4249F0	Challenge::GetArtChallengeSeed(eax = int theGridY, edx = int theGridX, ecx = Challenge* this)	eax = SeedType anArtSeed; ecx, edx		取得限制种植类关卡 (theGridX, theGridY) 格子内限制的种子类型。非此类关卡或非限制格子则返回 -1。
424A40	Challenge::SpawnLevelAward(eax = int theGridY, ecx = int theGridX, Challenge* this)	eax, ecx, edx		部分特殊玩法的关卡过关时调用，清除全场僵尸并在 (theGridX, theGridY) 格子处掉落过关物品（钱袋或奖杯）。
424C90	Challenge::CheckForCompleteArtChallenge(int theGridY, int theGridX, Challenge* this)	eax, ecx, edx		限制种植类关卡检查是否完成种植任务，若完成则触发过关并在 (theGridX, theGridY) 格子处掉落过关奖品。
424DE0	Challenge::DrawArtChallenge(Graphics* g, Challenge* this)	eax, ecx, edx		绘制限制种植类关卡的种子限制地图。
424FB0	Challenge::DrawBeghouled(Graphics* g, Challenge* this)	eax, ecx, edx		绘制宝石迷阵相关关卡的弹坑和宝石迷阵转转看关卡的转向圆环贴图。
4251E0	Challenge::DrawSlotMachine(ecx = Graphics* g, edx = Challenge* this)	eax, ecx, edx		老虎机关卡，绘制老虎机拉杆的动画。
425300	Challenge::DrawBackdrop(edi = Graphics* g, eax = Challenge* this)	eax, ecx, edx		绘制部分特殊关卡的舞台背景。
425,460	Challenge::PlantAdded(edi = Plant* thePlant, ebx = Challenge* this)	eax, ecx, edx		限制种植类关卡种植植物后，检测相关限制地形以创建音效和特效，同时检验过关的条件是否达成。
425,550	Challenge::CanPlantAt(SeedType theSeedType, edi = int theGridY, ebx = int theGridX, ecx = Challenge* this)	eax = PlantingReason ; ecx, edx		在关卡特殊玩法的限制下，判断 theSeedType 植物（或僵尸）能否种植在指定位置，并返回不能种植的原因。
425,690	Challenge::InitZombieWavesSurvival(Challenge* this)	eax, ecx, edx		随机生成生存模式关卡的出怪类型数组。
425840	Challenge::InitZombieWaves(esi = Challenge* this)	eax, ecx, edx		生成非冒险模式的关卡的出怪类型数组。部分特殊的冒险模式关卡的出怪也在此进行设定。
425DA0	Challenge::WhackAZombiePlaceGraves(int theGraveCount, Challenge* this)	eax, ecx, edx		锤僵尸关卡，在第 3 列及更右侧的随机位置生成共 theGraveCount 个墓碑。优先选择没有植物的格子。
425FF0	Challenge::WhackAZombieSpawning(Challenge* this)	eax, ecx, edx		锤僵尸关卡进程的推进，包括波数和倒计时的更新及墓碑和僵尸的刷新等。
426580	Challenge::UpdateZombieSpawning(esi = Challenge* this)	al = bool isSpawningCompleted; ecx, edx		关卡特性相关刷怪的更新，返回是否完成刷新僵尸的更新。当返回“是”时，后续不再从战场右侧刷出僵尸。
426620	Challenge::GraveDangerSpawnGraveAt(edi = int theGridY, ebx = int theGridX, Challenge* this)	eax, ecx, edx		在 (theGridX, theGridY) 格子处出现墓碑，且墓碑会清除该格子内的所有植物。
4266C0	Challenge::GraveDangerSpawnRandomGrave(Challenge* this)	eax, ecx, edx		坟墓模式关卡，在第 4 列及更右侧的随机位置生成一个墓碑。优先选择没有植物的格子。
426850	Challenge::SpawnZombieWave(ecx = Challenge* this)	eax, ecx, edx		每波僵尸刷新时关卡特性相关事件的更新。此函数于“当前波数”的数值更新前调用。
426A20	Challenge::DrawStormFlash;(edi = int theMaxAmount, ebx = int theTime, esi = Graphics* g, eax = Challenge* this)	eax, ecx, edx		根据单次闪光的倒计时（theTime）和最大亮度（theMaxAmount），;分别计算合适的不透明度绘制暴风雨的黑暗效果和闪电的亮光效果。
426B20	Challenge::DrawWeather(edi = Graphics* g, esi = Challenge* this)	eax, ecx, edx		绘制关卡的特殊天气（下雨和暴风雨）。
426B90	Challenge::DrawRain(Graphics* g, Challenge* this)	eax, ecx, edx		绘制远景和近景的下雨效果。
426E90	Challenge::DrawStormNight(eax = Graphics* g, Challenge* this)	eax, ecx, edx		先绘制暴风雨夜的相关特效，然后重新绘制游戏内的底层和上层 UI。
426F60	Challenge::PlayBossEnter(eax = Challenge* this)	eax, ecx, edx		[Tag: 创建僵王博士,生成僵王博士]僵王博士相关关卡开始时调用，创建僵王博士出场。
426FC0	Challenge::PortalStart(edi = Challenge* this)	eax, ecx, edx		保护传送门关卡开始时调用，分别在 (0, 2)、(1, 9)、(3, 9)、(4, 2) 格子处开启共四个传送门。
4270A0	Challenge::UpdatePortal(GridItem* thePortal, Challenge* this)	eax, ecx, edx		传送门更新，依次判断场上所有僵尸、子弹和小推车是否进入传送门，并调整其穿过传送门后的坐标。
4273C0	Challenge::GetOtherPortal(edi = GridItem* thePortal, ebx = Challenge* this)	eax = GridItem*? aOtherPortal; ecx, edx		取得与给定传送门对应的另一传送门，即：取得一个与给定场地物品类型相同的场地物品。
427410	Challenge::GetPortalAt(edi = int theGridY, ebx = int theGridX, Challenge* this)	eax = GridItem*? aPortal; ecx, edx		取得位于指定行和列的传送门。
427470	Challenge::MoveAPortal(Challenge* this)	eax, ecx, edx		随机关闭场上的一个传送门，并在除本行和对应的另一传送门所在行以外的随机位置开启一个同种传送门。
4275E0	Challenge::UpdatePortalCombat(ecx = Challenge* this)	eax, ecx, edx		【关卡特性函数】保护传送门关卡的特性更新函数。
427800	Challenge::PortalCombatRowSpawnWeight(edi = int theGridY, ebx = Challenge* this)	st(0) = aWeight; eax, ecx, edx		保护传送门关卡中，在传送门的影响下，重新规划僵尸出现在第 theGridY 行的权重。有如下规则：;(1)若僵尸从本行最右侧开始，穿过若干传送门，仅需经过至多 4 列即可触碰小推车，则本行权重为 0.01;(2)在排除(1)的情况后，若本行存在传送门，则本行权重为 1 ，否则本行权重为 0.2。
427870	Challenge::GetPortalToLeft(int theGridY, ebx = int theGridX, Challenge* this)	eax = GridItem*? aPortal; ecx, edx		取得第 theGridY 行中列数小于第 theGridX 列的最右侧的传送门，;即从 (theGridX, theGridY) 格子向左的首个传送门。
4278E0	Challenge::GetPortalDistanceToMower(eax = int theGridY, Challenge* this)	eax = int aDistance; ecx, edx		计算受到传送门的影响下，从第 theGirdY 行最右侧开始至小推车所在位置，至少需要经过的列数量。
427970	Challenge::GetPortalToRight(int theGridY, ebx = int theGridX, Challenge* this)	eax = GridItem*? aPortal; ecx, edx		取得第 theGridY 行中列数大于第 theGridX 列的最左侧的传送门，;即从 (theGridX, theGridY) 格子向右的首个传送门。
4279E0	Challenge::CanTargetZombieWithPortals(Zombie* theZombie, eax = Plant* thePlant, Challenge* this)	al = 0(否) | 1(是); ecx, edx		判断受到传送门影响下，僵尸是否位于植物的攻击范围内。仅考虑植物向右发射子弹的情况。
427A60	Challenge::BeghouledPacketClicked(eax = SeedPacket* theSeedPacket, Challenge* this)	eax, ecx, edx		宝石迷阵关卡，鼠标点击卡牌，消耗阳光并生效相应的效果。
427C70	Challenge::BeghouledShuffle(edi = Challenge* this)	eax, ecx, edx		宝石迷阵关卡刷新，清除所有提示字幕和植物，并设定关卡状态以在下次更新时创建填补的植物掉落。
427D00	Challenge::BeghouledCanClearCrator(ecx = Challenge* this)	al = 0(否) | 1(是); ecx, edx		宝石迷阵关卡，判断当前是否可以填补弹坑，即：判断当前场上是否存在弹坑。
427D30	Challenge::ZombiquariumSpawnSnorkle(eax = Challenge* this)	eax = Zombie* aZombie; ecx, edx		僵尸水族馆关卡，在横坐标 50 至 650、纵坐标 100 至 400 范围内的随机位置出现一只潜水僵尸。
427DD0	Challenge::ZombiquariumPacketClicked(eax = SeedPacket* theSeedPacket, Challenge* this)	eax, ecx, edx		僵尸水族馆关卡，鼠标点击卡牌，消耗阳光并生效相应的效果。
427F60	Challenge::ZombiquariumDropBrain(int y, int x, edi = Challenge* this)	eax, ecx, edx		僵尸水族馆关卡，在 (x, y) 位置处投喂脑子，同时清除投食的提示字幕。
428010	Challenge::ZombiquariumMouseDown(int y, int x, Challenge* this)	eax, ecx, edx		僵尸水族馆关卡，鼠标以非右击的方式点击时，尝试投喂脑子。
4280A0	Challenge::ZombiquariumUpdate(Challenge* this)	eax, ecx, edx		【关卡特性函数】僵尸水族馆关卡的特性更新函数。
428510	Challenge::ShovelAddWallnuts(ebx = Challenge* this)	eax, ecx, edx		原用于你能把它挖出来吗关卡开始时在全屏种植坚果，现实际种植过程已内联至41F6E0的函数内。
428540	Challenge::ScaryPotterPlacePot;(ebx = int theGridArrayCount, TodWeightedGridArray* theGridArray, eax = theCount, ; SeedType theSeedType = -1, ZombieType theZombieType = -1, ScaryPotType theScaryPotType, Challenge* this)	eax, ecx, edx		分别从加权格子数组 theGridArray 中随机获取格子，创建共 theCount 个 theScaryPotType 类型的罐子。;若指定创建植物/僵尸罐子，则 theSeedType/theZombieType 指定罐子中的植物/僵尸类型，另一项需为 -1;若指定创建阳光罐子，则 theSeedType 和 theZombieType 均需为 -1。
428620	Challenge::ScaryPotterChangePotType(eax = theCount, Challenge* this)	eax, ecx, edx		将场地上随机共 theCount 个内容为植物的罐子的样式替换为绿色罐子（Leaf 样式）。
4286F0	Challenge::ScaryPotterPopulate(esi = Challenge* this)	eax, ecx, edx		生成破罐者关卡：根据当前关卡，随机生成相应的罐子地图。
429500	Challenge::ScaryPotterStart(ecx = Challenge* this)	eax, ecx, edx		冒险模式下砸罐子关卡开始时，创建“[ADVICE_USE_SHOVEL_ON_POTS]”的提示字幕。
4296A0	Challenge::ScaryPotterIsCompleted(edi = Challenge* this)	eax = bool isCompleted; ecx, edx		判断砸罐子关卡是否完成。完成的条件：场上不存在罐子，且不存在存活的未被魅惑的僵尸。
4296F0	Challenge::ScaryPotterUpdate(esi = Challenge* this)	eax, ecx, edx		【关卡特性函数】破罐者系列关卡的特性更新函数。
429760	Challenge::ScaryPotterMalletPot(eax = GridItem* theScaryPot, Challenge* this)	eax, ecx, edx		开始砸罐子，记录砸罐子的行和列，并创建锤子的动画和挥动锤子的音效。
4298E0	Challenge::ScaryPotterCountPots(ebx = Challenge* this)	eax = int aCount; ecx, edx		取得当前场上剩余的罐子数量。
429930	Challenge::PuzzleIsAwardStage(edx = Challenge* this)	al = 0(否) | 1(是); ecx, edx		根据当前关卡及轮数，判断解谜模式在完成此轮后是否应当掉落钱袋等额外奖励。其中：;我是僵尸无尽模式每 3 轮、破罐者无尽模式每 10 轮、其他非无尽的解谜关卡完成时，均会掉落钱袋奖品。
429980	Challenge::PuzzlePhaseComplete(int theGridY, eax = int theGridX, ecx = Challenge* this)	eax, ecx, edx		解谜模式关卡一轮完成，根据当前关卡及当前轮数决定掉落特殊奖品或直接退出关卡或进入下一轮。
429AC0	Challenge::ScaryPotterOpenPot(GridItem* theScaryPot, Challenge* this)	eax, ecx, edx		砸开罐子，释放罐子内容的植物、僵尸或阳光，创建砸罐的音效和特效，同时进行关卡过关条件的判断。
429DB0	Challenge::ScaryPotterJackExplode(eax = int thePosY, ecx = int thePosX, Challenge* this)	eax, ecx, edx		在 (thePosX, thePosY) 处创建爆炸。此爆炸仅对罐子有效且爆炸范围在函数内部已经固定。
429E50	Challenge::PuzzleNextStageClear(edi = Challenge* this)	eax, ecx, edx		解谜模式关卡开始进入下一轮，清除全场所有僵尸、植物、即用型卡牌、场地物品和字幕。
42A040	Challenge::SeedTypeToZombieType(eax = SeedType theSeedType)	eax = ZombieType aZombieType		根据卡牌类型 theSeedType 获取对应的僵尸类型 aZombieType。
42A0F0	Challenge::IZombiePlaceZombie;(eax = int theGridY, int theGridX, ZombieType theZombieType, ecx = Challenge* this)	eax, ecx, edx		[Tag:种植僵尸,生成僵尸,创建僵尸]我是僵尸模式中，在 (theGridX, theGridY) 格子处放置 theZombieType 僵尸。
42A210	Challenge::IZombieMouseDownWithZombie(int theClickCount, int theY, int theX, Challenge* this)	eax, ecx, edx		我是僵尸模式中，鼠标手持卡牌点击 (theX, theY) 位置处。
42A530	Challenge::IZombieSetupPlant(Plant* thePlant, eax = Challenge* this)	eax, ecx, edx		我是僵尸模式开始时，将植物身体的各部分动画速率重置为 0，并令土豆地雷进入准备就绪状态。
42A660	Challenge::IZombiePlacePlantInSquare;(ebx = int theGridY, int theGridX, SeedType theSeedType, edi = Challenge* this)	eax, ecx, edx		判断植物能否种植在指定格子内，若能则种植植物并对植物进行我是僵尸关卡的特殊调整。
42A6C0	Challenge::IZombiePlacePlants(eax = int theGridY, int theCount, SeedType theSeedType, Challenge* this)	eax, ecx, edx		在第 theGridY 行随机 theCount 个可种植的位置种植 theSeedType 植物并对其进行我是僵尸关卡的特殊调整。;当 theGridY 为 -1 时，不限制种植的行。函数内部会根据当前关卡自行获取可种植的最大列数范围。
42A890	Challenge::IZombieInitLevel(Challenge* this)	eax, ecx, edx		生成我是僵尸关卡：创建每行的脑子，并根据当前关卡随机生成相应的植物地图。
42B290	Challenge::IZombieStart(Challenge* this)	eax, ecx, edx		我是僵尸模式关卡开始时，创建过关需要吃掉所有脑子的提示字幕。
42B340	Challenge::IZombieUpdate(Challenge* this)	eax, ecx, edx		【关卡特性函数】我是僵尸系列关卡的特性更新函数。
42B530	Challenge::IsZombieSeedType(eax = SeedType theSeedType)	al = 0(否) | 1(是)		判断类型为 theSeedType 的卡牌是否为僵尸卡牌。
42B590	Challenge::IZombieSetPlantFilterEffect;(FilterEffect theFilterEffect, edi = Plant* thePlant, eax = Challenge* this)	eax, ecx, edx		我是僵尸模式中，统一设置植物身体的各部分动画的滤镜效果。
42B690	Challenge::IZombieDrawPlant(eax = Plant* thePlant, esi = Graphics* g, Challenge* this)	eax, ecx, edx		我是僵尸模式中，绘制纸板样式的植物。
42B810	Challenge::IZombieGetBrainTarget(eax = Zombie* theZombie, Challenge* this)	eax = GridItem*? aBrain; ecx, edx		我是僵尸模式中，寻找僵尸的目标脑子。
42B8B0	Challenge::IZombieScoreBrain(ebx = Griditem* theBrain, esi = Challenge* this)	eax, ecx, edx		我是僵尸模式中，获得一个脑子的分数，在脑子位置创建奖励掉落。同时，进行关卡过关条件的判断。
42B970	Challenge::IZombieEatBrain(edi = Zombie* theZombie, Challenge* this)	al = bool gotBrainTarget; ecx, edx		我是僵尸模式中，僵尸寻找目标脑子并啃食，若啃食完成则触发相应的事件。返回值表示是否存在目标脑子。
42B9D0	Challenge::IZombiePlantDropRemainingSun(esi = Plant* thePlant, Challenge* this)	eax, ecx, edx		我是僵尸模式中，当植物（向日葵）被压扁或被偷走时，一次性掉落所有剩余阳光。
42BA30	Challenge::IZombieSquishBrain(eax = Griditem* theBrain, Challenge* this)	eax, ecx, edx		我是僵尸模式中，压扁脑子。
42BAC0	Challenge::SquirrelCountUncaught(ebx = Challenge* this)	eax = int aCount; ecx, edx		松鼠关卡中，取得当前场上未被捕获且不藏有僵尸的松鼠数量。
42BB10	Challenge::SquirrelStart(Challenge* this)	eax, ecx, edx		松鼠关卡开始时，在随机格子创建共 7 只普通松鼠和 1 只藏有僵尸的松鼠。
42BCB0	Challenge::SquirrelChew(GridItem* theSquirrel, Challenge* this)	eax, ecx, edx		松鼠啃食，创建松鼠所在格子内的植物（坚果）的被啃食特效。
42BE10	Challenge::SquirrelFound(GridItem* theSquirrel, Challenge* this)	eax, ecx, edx		松鼠关卡中，当一只松鼠被发现时，根据松鼠本身状态和场地情况，决定松鼠的行为及关卡中触发的事件。
42C1B0	Challenge::SquirrelUpdateOne(eax = GridItem* theSquirrel, Challenge* this)	eax, ecx, edx		松鼠关卡中，一只松鼠自身的行为和状态的更新。
42C2C0	Challenge::SquirrelUpdate(eax = Challenge* this)	eax, ecx, edx		【关卡特性函数】松鼠关卡的特性更新函数。
42C340	Challenge::UpdateRain(edi = Challenge* this)	eax, ecx, edx		更新雨点特效的倒计时，并在适当的时机创建雨点落地的动画。
42C5C0	Challenge::LastStandUpdate(esi = Challenge* this)	eax, ecx, edx		【关卡特性函数】谁笑到最后关卡的特性更新函数。
42C6F0	Challenge::LastStandCompletedStage(Challenge* this)	eax, ecx, edx		谁笑到最后关卡完成一轮防御后，处理中场事件和进入下一轮的预备事件。;部分处于冷却或相当于冷却状态中的植物的状态倒计时会在此时被重置以加快其冷却。
42C9B0	Challenge::WhackAZombieUpdate(eax = Challenge* this)	eax, ecx, edx		【关卡特性函数】锤僵尸关卡的特性更新函数。
42CA30	Challenge::TreeOfWisdomDraw(Graphics* g, ecx = Challenge* this)	eax, ecx, edx		绘制智慧树场景的背景动画，调整智慧树动画的颜色并绘制智慧树的动画，同时绘制智慧树的话的文本。
42CEE0	Challenge::TreeOfWisdomInit(Challenge* this)	eax, ecx, edx		初始化智慧树关卡，创建智慧树和背景 6 片白云的动画。
42D1F0	Challenge::TreeOfWisdomGrow(edi = Challenge* this)	eax, ecx, edx		智慧树生长，更新存档中智慧树高度的记录值，播放智慧树相应高度时的成长动画。
42D360	Challenge::TreeOfWisdomFertilize(ebx = Challenge* this)	eax, ecx, edx		为智慧树施肥，创建肥料的场地物品及其动画，并减少存档中智慧树肥料的数量。
42D480	Challenge::TreeOfWisdomBabble(esi = Challenge* this)	eax, ecx, edx		智慧树进行随机的闲谈。根据智慧树的高度不同，可能触发的闲谈内容的范围亦会有所不同。
42D530	Challenge::TreeOfWisdomGiveWisdom(ecx = Challenge* this)	eax, ecx, edx		智慧树被施肥而生长后进行的谈话。当智慧树生长至部分特定高度时，会触发特殊的对话。
42D5C0	Challenge::TreeOfWisdomSayRepeat(edi = Challenge* this)	eax, ecx, edx		在“这些是久经考验的智慧……”的谈话结束后，智慧树进行随机的游戏技巧的谈话。;其中部分谈话需要智慧树达到一定高度后才可能触发。
42D680	Challenge::TreeOfWisdomUpdate(eax = Challenge* this)	eax, ecx, edx		【关卡特性函数】智慧树关卡的特性更新函数。
42D7E0	Challenge::TreeOfWisdomLeave(eax = Challenge* this)	eax, ecx, edx		离开智慧树关卡时，令所有的智慧树肥料立即生效。
42D830	Challenge::TreeOfWisdomNextGarden(ecx = Challenge* this)	eax, ecx, edx		从智慧树切换至禅境花园，令所有的智慧树肥料立即生效，并删除禅境花园的关卡存档。
42D8C0	Challenge::TreeOfWisdomOpenStore(Challenge* this)	eax, ecx, edx		从智慧树进入戴夫的商店，显示第 3 页的商店，并等待商店对话结束后重新播放禅境花园的背景音乐。
42D9A0	Challenge::TreeOfWisdomTool(ecx = int theMouseY, edx = int theMouseX, eax = Challenge* this)	eax, ecx, edx		鼠标手持智慧树肥料点击 (theMouseX, theMouseY) 位置处时，若点击位置位于智慧树上，则为智慧树施肥。
42D9E0	Challenge::TreeOfWisdomHitTest;(ebx = HitResult* theHitResult, int theX, edi = int theX, eax = Challenge* this)	al = bool isMouseOnTree; ecx, edx		智慧树的鼠标检测。若 (theX, theY) 位于智慧树上，则 theHitResult = { 0, #21 }，;否则 theHitResult = { 0, 0 }。
42DA90	Challenge::TreeOfWisdomCanFeed(edi = Challenge* this)	al = 0(不能) | 1(能); ecx, edx		判断当前能否使用智慧树肥料。当智慧树正在生长或场上已存在花园工具（智慧树肥料）时，返回“否”。
42DAE0	ChallengeScreen::ChallengeScreen(ChallengePage thePage, LawnApp* theApp, ChallengeScreen* this)	eax = *this; ecx, edx		初始化创建小游戏界面并加载相关资源。需要一个大小为 0x1E4 的内存区域用于构造 this。
42E280	ChallengeScreen::`scalar deleting destructor'(unsigned int flags, ecx = ChallengeScreen* this)	eax = *this; ecx, edx		删除 ChallengeScreen 小游戏界面，当 flags 的第 0 位置 1 时会额外释放小游戏界面本身占用的内存空间。		【虚函数】[[[(ChallengeScreen*)]+0]+0]
42E2A0	ChallengeScreen::~ChallengeScreen(ecx = ChallengeScreen* this)	eax, ecx, edx		销毁小游戏界面，删除界面中的各按钮及鼠标悬浮标签。
42E3C0	ChallengeScreen::SetUnlockChallengeIndex;(bool theIsIZombie, ebx = ChallengePage thePage, ChallengeScreen* this)	eax, ecx, edx		取得指定页下一个可解锁的小游戏并设置其解锁状态，theIsIZombie 用于在解谜页确定是否为解锁 IZ 小游戏。
42E440	ChallengeScreen::MoreTrophiesNeeded(eax = int theChallengeIndex, ecx = ChallengeScreen* this)	eax = int aTrophiesNeeded; ecx, edx		小游戏界面中，判断距离解锁 theChallengeIndex 小游戏还需要获得的奖杯数量。
42E6E0	ChallengeScreen::ShowPageButtons(eax = ChallengeScreen* this)	al = 0(否) | 1(是); ecx		判断小游戏界面是否显示翻页按钮。
42E710	ChallengeScreen::UpdateButtons(ChallengeScreen* this)	eax, ecx, edx		小游戏界面按下页码按钮时，根据翻页后的当前页码调整每个小游戏按钮的可见情况及每个页码按钮的状态。
42E8A0	ChallengeScreen::AccomplishmentsNeeded(esi = int theChallengeIndex, ChallengeScreen* this)	eax = int aAccomplishmentsNeeded; ecx, edx		小游戏界面中，判断距离解锁 theChallengeIndex 小游戏还需要完成的小游戏关卡数量。
42E920	ChallengeScreen::DrawButton(int theChallengeIndex, Graphics* g, ChallengeScreen* this)	eax, ecx, edx		小游戏界面绘制 theChallengeIndex 小游戏按钮，并在按钮上绘制小游戏的名称、锁定情况、最高纪录等。
42F160	ChallengeScreen::Draw(Graphics* g, ecx = ChallengeScreen* this)	eax, ecx, edx		绘制小游戏界面。		【虚函数】[[[(ChallengeScreen*)]+0]+68]
42F510	ChallengeScreen::Update(ecx = ChallengeScreen* this)	eax, ecx, edx		小游戏界面更新，包括鼠标悬浮标签及解锁中的小游戏的解锁过程等的更新。		【虚函数】[[[(ChallengeScreen*)]+0]+58]
42F640	ChallengeScreen::AddedToManager(WidgetManager* theWidgetManager, ecx = ChallengeScreen* this)	eax, ecx, edx		将小游戏界面加入控件管理器，并将其中的各个按钮加入其子控件链表中。		【虚函数】[[[(ChallengeScreen*)]+0]+50]
42F6B0	ChallengeScreen::RemovedFromManager(WidgetManager* theWidgetManager, ecx = ChallengeScreen* this)	eax, ecx, edx		将小游戏界面移出控件管理器，并将其中的各个按钮移出其子控件链表。		【虚函数】[[[(ChallengeScreen*)]+0]+54]
42F720	ChallengeScreen::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		小游戏界面按下按钮时，播放按钮点击的音效。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(ChallengeScreen*)]+88]+4]
42F740	ChallengeScreen::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		小游戏界面按下的按钮松开时，判断点击的按钮并依此执行相应的事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(ChallengeScreen*)]+88]+8]
42F7E0	ChallengeScreen::UpdateToolTip(ChallengeScreen* this)	eax, ecx, edx		小游戏界面更新鼠标悬浮标签。
42FB50	ChallengeScreen::KeyChar(char theChar, ecx = ChallengeScreen* this)	此函数不改变任何寄存器		【废弃函数】小游戏界面输入 theChar 字符。此函数现被广泛用于充当单参数的空白虚函数。		【虚函数】（原义）[[[(ChallengeScreen*)]+0]+BC]
42FB60	std::string::substr;(unsigned int _Count, ecx = unsigned int _Off, edx = std::string* this, esi = _Out_ std::string&& aSubStr)	eax = std::string&& aSubStr; ecx, edx		取得字符串一个从 _Off 开始 _Count 长度的子字符串，此函数在新建字符串后调用了403E20的函数。
42FB90	std::vector<Color>::operator[](edi = unsigned int _Pos, esi = std::vector<Color>* this)	eax = Color& aColor; ecx		取得颜色的向量容器中第 _Pos 项的颜色，返回该颜色的引用。当 _Pos 超出容器中当前颜色数量时，将抛出错误。
42FBC0	Sexy::EditListener::AllowKey(int theId, KeyCode theKey, ecx = EditListener* this);Sexy::EditListener::AllowChar(int theId, char theChar, ecx = EditListener* this);Sexy::EditListener::AllowText(int theId, const std::string& theText, ecx = EditListener* this)	al = 1		默认的输入框监听器判断输入框中是否允许输入按键/字符/文本。总是返回“是”。		【虚函数】[[[(EditListener*)]+0]+4] & [[[(EditListener*)]+0]+8] & [[[(EditListener*)]+0]+C]
42FBD0	CheatDialog::ApplyCheat(ecx = CheatDialog* this)	al = bool succeed; ecx, edx		应用作弊对话中的作弊内容，返回是否应用成功的逻辑值。
42FF60	Coin::CoinInitialize;(ecx = CoinMotion theCoinMotion, eax = CoinType theCoinType, int theY, int theX, Coin* this)	eax, ecx, edx		初始化物品信息和数据，若物品需要动画则创建物品的动画。
430970	Coin::IsMoney(eax = Coin* this)	al = 0(否) | 1(是)		判断物品是否为钱币（银币、金币或钻石）。
430990	Coin::IsSun(eax = Coin* this)	al = 0(否) | 1(是)		判断物品是否为阳光（普通阳光、小阳光或大阳光）。
4309B0	Coin::IsPresentWithAdvice(eax = Coin* this)	al = 0(否) | 1(是)		判断物品是否为特殊模式（小游戏、解谜模式、生存模式）的解锁礼盒。
4309D0	Coin::ScoreCoin(eax = Coin* this)	eax, ecx, edx		收取物品完成时，令物品消失。当物品为阳光（钱币）时，增加玩家阳光数（钱数和收取钱币计数）。
430AC0	Coin::UpdateFall(Coin* this)	eax, ecx, edx		物品被收集前的运动更新，包括下落中的坐标更新和落地后的消失判定等。
430E40	Coin::UpdateCollected(ecx = Coin* this)	eax, ecx, edx		物品被收集后的运动更新，包括运动中位置和大小的更新及收集完成时相关事件的触发。
431500	Coin::Update(eax = Coin* this)	eax, ecx, edx		物品的总更新函数。
4316F0	Coin::GetColor(esi = _Out_ Color&& aColor, ecx = Coin* this)	eax = Color&& aColor; ecx, edx		根据物品的类型和状态等，取得物品的颜色。
4317D0	Coin::GetFinalSeedPacketType(ecx = Coin* this)	eax = SeedType aFinalSeed; ecx, edx		获取当前关卡过关后掉落卡牌的植物类型。此函数仅在已掉落卡牌后用于获取卡牌上的植物类型。;若当前关卡过关后的掉落物不为植物卡牌，则返回 -1。
431810	Coin::Draw(Graphics* g, Coin* this)	eax, ecx, edx		绘制物品。
431F30	Coin::FanOutCoins(int theNumCoins, CoinType theCoinType, edi = Coin* this)	eax, ecx, edx		创建 theNumCoins 个 theCoinType 物品从原物品中飞出形成一个扇形区域（即打开钱袋时出现钱币的方式）。
432000	Coin::TryAutoCollectAfterLevelAward(esi = Coin* this)	eax, ecx, edx		关卡过关后，尝试将物品自动收集。
432060	Coin::Collect(ecx = Coin* this)	eax, ecx, edx		开始收集物品并处理物品开始被收集时触发的部分事件。
4329A0	Coin::GetSunValue(eax = Coin* this)	eax = int aValue; ecx		获取阳光的价值，对于非阳光物品，其价值为 0。
4329D0	Coin::GetCoinValue(eax = CoinType theCoinType)	eax = int aValue; ecx		获取 theCoinType 钱币的价值，对于非钱币物品，其价值为 0。
432A00	Coin::PlayLaunchSound(ecx = Coin* this)	eax, ecx, edx		播放物品掉落时的音效。仅钻石、巧克力、礼物盒等部分特殊物品存在掉落音效。
432A90	Coin::PlayGroundSound(eax = Coin* this)	eax, ecx, edx		播放物品落地时的音效。仅金币存在落地音效。
432B00	Coin::PlayCollectSound(edx = Coin* this)	eax, ecx, edx		播放物品收集时的音效。
432C00	Coin::MouseDown(int theClickCount, ecx = Coin* this)	eax, ecx, edx		鼠标点击物品，判断并执行收集物品及相关事件，同时设置一周目冒险模式 1-1 关卡的字幕提示。
432DD0	Coin::Die(esi = Coin* this)	eax, ecx, edx		销毁物品及其附件。
432E20	Coin::MouseHitTest(HitResult* theHitResult, int theY, int theX, edx = Coin* this)	al = bool isMouseOnCoin; ecx		物品的鼠标检测，若 (theX, theY) 位于物品上，则 theHitResult = { *this, 3 }，;否则 theHitResult = { 0, 0 }。
432F80	Coin::IsLevelAward(eax = Coin* this)	al = 0(否) | 1(是)		判断物品是否为过关奖品。
432FE0	Coin::GetsBouncyArrow(ecx = Coin* this)	al = 0(否) | 1(是); edx		判断物品是否需要提醒收集的指引箭头。
433050	Coin::GetDisappearTime(ecx = Coin* this)	eax = int aTime; ecx		取得物品从落地至消失的时间（即落地后的最大可存在时间）。
4330D0	ContinueDialog::ContinueDialog(LawnApp* this, ContinueDialog* this)	eax = *this; ecx, edx		初始化创建继续游戏对话。需要一个大小为 0x174 的内存区域用于构造 this。
4333D0	ContinueDialog::`scalar deleting destructor'(unsigned int flags, ecx = ContinueDialog* this)	eax = *this; ecx, edx		删除继续游戏对话，当 flags 的第 0 位置 1 时会额外释放对话本身占用的内存空间。		【虚函数】[[[(ContinueDialog*)]+0]+0]
4333F0	ContinueDialog::~ContinueDialog(ecx = ContinueDialog* this)	eax, ecx, edx		销毁继续游戏对话，删除继续按钮和重新开始按钮。
433470	ContinueDialog::GetPreferredHeight(width, ecx = ContinueDialog* this)	eax = int aHeight; ecx, edx		当指定继续游戏对话的宽度时，计算对话的首选高度值。		【虚函数】[[[(ContinueDialog*)]+0]+124]
433480	ContinueDialog::Resize(height, width, y, x, ecx = ContinueDialog* this)	eax, ecx, edx		设置继续游戏对话内部各控件及其本身的位置和大小。		【虚函数】[[[(ContinueDialog*)]+0]+A0]
433520	ContinueDialog::AddedToManager(WidgetManager* theWidgetManager, ecx = ContinueDialog* this)	eax, ecx, edx		将继续游戏对话加入控件管理器，并将其继续按钮和重新开始按钮加入其子控件链表中。		【虚函数】[[[(ContinueDialog*)]+0]+50]
433590	ContinueDialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = ContinueDialog* this)	eax, ecx, edx		将继续游戏对话移出控件管理器，并将其继续按钮和重新开始按钮移出其子控件链表。		【虚函数】[[[(ContinueDialog*)]+0]+54]
4335D0	ContinueDialog::RestartLoopingSounds(edi = ContinueDialog* this)	eax, ecx, edx		重新开始循环的音效，包括雨天关卡中的下雨音效和所有僵尸的自带音效。
4336C0	ContinueDialog::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		继续游戏对话中松开按下的按钮时，根据按下的按钮触发相应的事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(ContinueDialog*)]+88]+8]
433A70	CreditScreen::CreditScreen(ecx = LawnApp* theApp, CreditScreen* this)	eax = *this; ecx, edx		初始化创建 MV 界面。需要一个大小为 0xF8 的内存区域作为 credits。
433E20	CreditScreen::`scalar deleting destructor'(unsigned int flags, ecx = CreditScreen* this)	eax = *this; ecx, edx		删除 MV 界面，当 flags 的第 0 位置 1 时会额外释放对话本身占用的内存空间。		【虚函数】[[[(CreditScreen*)]+0]+0]
433E40	CreditScreen::~CreditScreen(ecx = CreditScreen* this)	eax, ecx, edx		销毁继续游戏对话，删除重播按钮、主菜单按钮和悬浮控件。
433EE0	CreditScreen::AddedToManager(WidgetManager* theWidgetManager, ecx = CreditScreen* this)	eax, ecx, edx		将 MV 界面加入控件管理器，并将其重播按钮、主菜单按钮和悬浮控件加入其子控件链表中。		【虚函数】[[[(CreditScreen*)]+0]+50]
433F30	CreditScreen::RemovedFromManager(WidgetManager* theWidgetManager, ecx = CreditScreen* this)	eax, ecx, edx		将 MV 界面移出控件管理器，并将其重播按钮、主菜单按钮和悬浮控件移出其子控件链表。		【虚函数】[[[(CreditScreen*)]+0]+54]
433F80	CreditScreen::PreLoadCredits(CreditScreen* this)	eax, ecx, edx		预加载 MV 中需要的音乐、贴图和动画，并设置部分动画定义文本轨道上各帧的字体。
434C70	CreditScreen::GetTiming(esi = float* theFraction, edi = CreditsTiming** theAfterTiming, ;                        ebx = CreditsTiming** theBeforeTiming, ecx = CreditScreen* this)	eax, ecx, edx		根据 gCreditsTiming 取得 MV 动画当前进度的前、后一个关键时刻及当前位于两个时刻之间的比例，;并将前、后时刻的指针及浮点型比例值分别写入[theBeforeTiming]、[theAfterTiming]和[theFraction]中。
434D60	CreditScreen::PlayReanim(eax = int aIndex, edi = CreditScreen* this)	eax = Reanimation* aReanim; ecx, edx		删除原有 MV 动画，播放 MV 第 aIndex 阶段（取值范围：{1, 2, 3}）的动画并设定各轨道的渲染分组。
434F20	DrawDisco(float theTime, float aCenterY, float aCenterX, edi = Graphics* g)	eax, ecx, edx	0xC	在指定中心位置绘制迪斯科灯光，其中 theTime 表示当前 MV 动画播放的浮点帧。
4351E0	CreditScreen::DrawFogEffect(float theTime, Graphics* g, CreditScreen* this)	eax, ecx, edx		绘制 MV 黑夜泳池场景中的浓雾效果，其中 theTime 表示当前浓雾的时间进度，其取值范围为 [0.0, 1.0]。
4354E0	CreditScreen::DrawOverlay(Graphics* g, ecx = CreditScreen* this)	eax, ecx, edx		MV 谢幕阶段，以一定的不透明度（从不透明逐渐变为全透明）填充一个全屏的黑色矩形作为淡入效果。		【虚函数】[[[(CreditScreen*)]+0]+B0]
435550	CreditScreen::DrawFinalCredits(esi = Graphics* g)	eax, ecx, edx		MV 谢幕阶段绘制制作人员名单。
435A90	DrawReanimToPreload(ecx = ReanimationType theReanimType, Graphics* g)	eax, ecx, edx	0x4	绘制预览用 theReanimType 类型的动画。
435B60	CreditScreen::Draw(Graphics* g, ecx = CreditScreen* this)	eax, ecx, edx		绘制 MV。		【虚函数】[[[(CreditScreen*)]+0]+68]
436940	CreditScreen::UpdateBlink(edi = CreditScreen* this)	eax, ecx, edx		更新 MV 中向日葵的眨眼。
436A30	CreditScreen::Update(ecx = CreditScreen* this)	eax, ecx, edx		更新 MV 界面及 MV，尽量同步 MV 时间与影片进度，并将界面标记为已变更。		【虚函数】[[[(CreditScreen*)]+0]+58]
436BE0	CreditScreen::UpdateMovie(CreditScreen* this)	eax, ecx, edx		更新 MV 影片（包括动画、特效、音效、脑子坐标和向日葵歌手的口型等），同时更新 MV 各阶段的进行。
437F20	CreditScreen::TurnOffTongues(int aParentTrack, Reanimation* theReanim, ecx = CreditScreen* this)	eax, ecx, edx		取消显示 theReanim 动画及 theReanim 下所有附属动画的部分轨道上的附件中僵尸动画的舌头，;其中 aParentTrack 为 theReanim 附属的轨道的序号，若 theReanim 不是附件动画则 aParentTrack 为 0。
437FC0	TodsHackyUnprotectedPerfTimer::SetStartTime;(int theTimeMillisecondsAgo, esi = TodsHackyUnprotectedPerfTimer* this)	eax, ecx, edx		将性能计时器的开始时间强制调整至当前时间的 theTimeMillisecondsAgo 毫秒之前。
438010	CreditScreen::JumpToFrame(float theFrame, ebx = CreditsPhase thePhase, eax = CreditScreen* this)	eax, ecx, edx		将 MV 动画跳转至 thePhase 阶段的 theFrame 浮点帧，并相应调整当前动画、音乐进度和 MV 计时器等。
438430	CreditScreen::PauseCredits(ebx = CreditScreen* this)	eax, ecx, edx		暂停 MV，创建继续或退出的选择弹窗，并等待若返回继续播放则修正 MV 计时器。
438530	CreditScreen::KeyDown(KeyCode theKey, ecx = CreditScreen* this)	eax, ecx, edx		MV 界面键盘按键按下，当按下空格、回车或退出键时，暂停 MV。		【虚函数】[[[(CreditScreen*)]+0]+C0]
438560	CreditScreen::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		MV 界面中按钮按下时，播放按下按钮的音效。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(CreditScreen*)]+88]+4]
4385A0	CreditScreen::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		MV 界面中松开按下的按钮时，根据按下的按钮触发相应的事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(CreditScreen*)]+88]+8]
438640	CursorObject::CursorObject(edi = CursorObject* this)	eax = *this; ecx, edx		初始化光标对象基础数据。创建光标对象时调用，初始化其坐标、指针和手持物相关数据等。;锤僵尸关卡中，额外创建锤子的动画。需要一个大小为 0x4C 的内存区域用于构造 this。
438780	CursorObject::Update(esi = CursorObject* this)	eax, ecx, edx		更新光标对象的坐标、动画及可见性。
438820	CursorObject::Draw(Graphics* g, CursorObject* this)	eax, ecx, edx		绘制鼠标上手持的物品。
438D50	CursorPreview::CursorPreview(eax = CursorPreview* this)	eax = *this; ecx, edx		初始化光标预览基础数据。需要一个大小为 0x2C 的内存区域用于构造 this。
438DA0	CursorPreview::Update(edi = CursorPreview* this)	eax, ecx, edx		更新光标预览的位置坐标及可见性。
438EB0	CursorPreview::Draw(Graphics* g, ebx = CursorPreview* this)	eax, ecx, edx		绘制种植预览。
4390E0	CutScene::CutScene(eax = Cutscene* this)	eax = *this; ecx, edx		初始化过场基础数据。需要一个大小为 0x4C 的内存区域用于构造 this。
439140	CutScene::PlaceAZombie(int theGridY, int theGridX, ZombieType theZombieType, Cutscene* this)	eax, ecx, edx		在过场中创建预览的僵尸。在植物僵尸 2 关卡中，创建鸭子救生圈僵尸会转化为创建豌豆射手僵尸。
4393D0	CutScene::CutSceneCanZombieGoInGridSpot(bool theZombieGrid[][5], ebx = int theGridY, esi = int theGridX, ;                                        edi = ZombieType theZombieType, ecx = Cutscene* this)	al = 0(不能) | 1(能); edx		判断在生成关卡僵尸预览时，类型为 theZombieType 的僵尸能否出现在 (theGridX, theGridY) 格子内。;其基本要求为：僵尸在图像上不可被覆盖，且只能位于可站立的地形处。部分僵尸存在额外的特殊要求。;参数中的 theZombieGrid 为 5×5 的布尔数组的指针，其 [i][j] 的值表示 i 列 j 行是否存在僵尸图像。
4394A0	CutScene::FindPlaceForStreetZombies;(int& thePosY, int& thePosX, bool theZombieGrid[][5], eax = ZombieType theZombieType, Cutscene* this)	eax, ecx, edx		生成关卡僵尸预览时，选取僵尸出现的格子并将格子的行、列分别赋值给 thePosY 和 thePosX。;对于蹦极僵尸，固定将 thePosX 和 thePosY 均赋值为 0。
439590	CutScene::FindAndPlaceZombie;(bool theZombieGrid[][5], esi = ZombieType theZombieType, ebx = Cutscene* this)	eax, ecx, edx		生成关卡僵尸预览时，选取位置并放置僵尸，同时将 theZombieGrid 中相应的格子标记为存在僵尸。
439640	CutScene::PreloadResources(CutScene* this)	eax, ecx, edx		预加载当前关卡可能用到的所有动画和贴图等资源，生成关卡的僵尸预览，并测算预加载消耗的时间。
43A140	CutScene::PlaceStreetZombies(CutScene* this)	eax, ecx, edx		生成关卡可能出现的僵尸的预览。会先统计每种类型的僵尸在关卡中出现的数量，统计时有以下规则：;(1)雪人僵尸仅在暴风雨夜、雪橇小队仅在雪橇区关卡被统计，蹦极僵尸和雪橇僵尸小队至多仅计入 1 只僵尸;(2)谁笑到最后关卡，除雪人僵尸外，所有允许出怪的僵尸类型至少计入 1 只僵尸;(3)泳池或浓雾场景的关卡，至少计入 1 只鸭子救生圈僵尸。;统计完成后对所有计数不为 0 的僵尸类型生成若干只（至少 1 只、至多不超过上述计数）预览僵尸，;且伽刚特尔、暴走伽刚特尔和雪橇车僵尸至多仅生成 1 只预览僵尸。
43A690	CutScene::PlaceLawnItems(esi = CutScene* this)	eax, ecx, edx		关卡开始时调用，初始化战场上的各种物品，包括：初始化小推车、放置花盆、放置钉耙。
43A710	CutScene::IsSurvivalRepick(edx = CutScene* this)	al = 0(否) | 1(是); ecx, edx		判断当前是否为生存模式的重新选卡阶段。该阶段返回主菜单时，将弹出确认离开游戏的弹窗。
43A740	CutScene::IsNonScrollingCutscene(eax = CutScene* this)	al = 0(否) | 1(是); ecx		判断当前关卡过场是否需要滚动屏幕画面。
43A7B0	CutScene::IsScrolledLeftAtStart(edx = CutScene* this)	al = 0(否) | 1(是); ecx, edx		判断当前关卡过场是否从画面最左侧开始滚动屏幕。其中，非首轮的生存模式的过场从屏幕中央开始滚动。
43A820	CutScene::CanGetPacketUpgrade(ecx = CutScene* this)	al = 0(否) | 1(是); ecx, edx		仅在冒险模式 2-3 至 3-4 的部分关卡调用，判断当前关卡开始时是否出现推荐购买卡槽第 7 格的戴夫。
43A890	CutScene::CanGetSecondPacketUpgrade(ecx = CutScene* this)	al = 0(否) | 1(是); ecx, edx		仅在冒险模式 2-6 至 3-4 的部分关卡调用，判断当前关卡开始时是否出现推荐购买卡槽第 8 格的戴夫。
43A900	CutScene::StartLevelIntro(CutScene* this)	eax, ecx, edx		开始关卡引入的过场，进行过场的场景布置，计算、规划并记录过场中各项事件的触发时间。;对于僵王博士、破罐者和保龄球相关关卡，在关卡引入时立即进行资源的预加载和战场物品的放置。;上述过程结束后，部分过场会额外创建房子名称的提示字幕并播放过场相应的背景音乐。
43B3A0	CutScene::IsBeforePreloading(eax = CutScene* this)	al = 0(否) | 1(是); ecx, edx		判断当前是否尚未完成关卡资源的预加载。
43B3C0	CutScene::CancelIntro(CutScene* this)	eax, ecx, edx		结束关卡引入的过场，预加载关卡资源并放置预览的僵尸，同时根据过场阶段对过场进行适当的调整：;若当前处于选卡前，则调整戴夫的相关状态否则，放置战场物品，并设置关卡的部分状态和音乐、音效等。
43B6A0	CutScene::AddGraveStoneParticles(ebx = CutScene* this)	eax, ecx, edx		依次创建场上所有墓碑升起时的土壤特效和音效。
43B6F0	CutScene::AddFlowerPots(CutScene* this)	eax, ecx, edx		关卡开始时的批量种植花盆。
43B7D0	CutScene::AnimateBoard(CutScene* this)	eax, ecx, edx		在过场进行的不同阶段，过场对相应阶段的关卡界面内应当触发的各项事件的动态行为的更新。包括：;开始戴夫对话、滚动画面、移动卡槽及选卡界面、放置战场物品、僵王博士登场、播放音乐、音效和特效等。
43C140	CutScene::ShowShovel(edx = CutScene* this)	eax, ecx, edx		判断关卡是否拥有铲子，若有则显示铲子。
43C1E0	CutScene::IsInShovelToturial(eax = CutScene* this)	al = 0(否) | 1(是); ecx		判断当前是否处于铲子使用的新手教程阶段。此函数实际用到 this 的只有 mBoard(+4) 的指针。
43C200	CutScene::Update(eax = CutScene* this)	eax, ecx, edx		关卡内的过场更新，包括开始游戏前的各种准备事件也在此函数内部执行。
43C3C0	CutScene::StartZombiesWon(ebx = CutScene* this)	eax, ecx, edx		开始僵尸进家的过场，隐藏主菜单按钮和铲子，停止所有音乐和僵尸自带音效，并播放游戏失败的上位音效。
43C410	CutScene::UpdateZombiesWon(CutScene* this)	eax, ecx, edx		僵尸进家的过场的更新，包括画面滚动、各时刻音效和特效的触发和过场结束时失败弹窗的创建等。
43C910	CutScene::ZombieWonClick(eax = CutScene* this)	eax, ecx, edx		若在僵尸进家的过场中按下鼠标且游戏允许使用作弊按键（内测版），则立即结束当前关卡并开始新游戏。
43C950	CutScene::AdvanceCrazyDaveDialog(bool theJustSkipping, CutScene* this)	eax, ecx, edx		过场推进戴夫对话进度，并触发部分特定语句时刻的特殊事件。
43CE00	CutScene::MouseDown(CutScene* this)	eax, ecx, edx		关卡引入阶段的过场中，当鼠标按下时，若戴夫存在，则推进戴夫的对话。;当允许使用作弊按键时，在推销关卡中将加速戴夫的推销对话，在不存在戴夫的关卡中将直接退出引入阶段。
43D280	CutScene::KeyDown(KeyCode theKey, CutScene* this)	eax, ecx, edx		过场中当按键按下时，根据按下的按键和当前情况触发相应的事件。
43D830	CutScene::ParseDelayTimeFromMessage(edi = CutScene* this)	eax = int aDelayTime; ecx, edx		推销关卡中，根据戴夫对话的字符串，取得其从当前对话结束至下一句对话开始的延时时间。;若戴夫的话中存在“{DELAY_”字符串，则取得、赋值并返回 mCrazyDaveCountDown，否则返回 100。
43D940	CutScene::ParseTalkTimeFromMessage(edi = CutScene* this)	eax = int aTalkTime; ecx, edx		推销关卡中，根据戴夫对话的字符串，取得其当前的一句对话的持续时间。;若戴夫的话中存在“{TIME_”字符串，则取得、赋值并返回 mCrazyDaveCountDown，否则返回 100。
43DA50	CutScene::ClearUpsellBoard(ebx = CutScene* this)	eax, ecx, edx		推销关卡中，清除当前的关卡和界面等数据，以准备进入下一个场景的演示关卡。包括：;清除每一行的冰道，释放所有游戏对象和动画、粒子系统，若存在演示用的小游戏界面则同时清除该界面。
43DBA0	CutScene::LoadIntroBoard(edi = CutScene* this)	eax, ecx, edx		清空当前演示关卡，加载演示引入关卡的布局，静默游戏音效，并对关卡进行 100 次预更新。
43E890	CutScene::LoadUpsellBoardPool(edi = CutScene* this)	eax, ecx, edx		清空当前演示关卡，加载泳池场景的演示关卡的布局，并在音效静默的状态下对关卡进行 100 次预更新。
43F310	CutScene::LoadUpsellBoardFog(edi = CutScene* this)	eax, ecx, edx		清空当前演示关卡，加载浓雾场景的演示关卡的布局，并在音效静默的状态下对关卡进行 100 次预更新。
43FD20	CutScene::LoadUpsellChallengeScreen(ecx = CutScene* this)	eax, ecx, edx		清空当前演示关卡，创建演示用的小游戏界面。
43FD90	CutScene::LoadUpsellBoardRoof(edi = CutScene* this)	eax, ecx, edx		清空当前演示关卡，加载屋顶场景的演示关卡的布局，并在音效静默的状态下对关卡进行 100 次预更新。
440D20	CutScene::UpdateUpsell(CutScene* this)	eax, ecx, edx		推销关卡戴夫对话进程的自动更新，并在部分特定语句的时刻触发相应的特殊事件。
441320	CutScene::DrawUpsell(Graphics* g, ebx = CutScene* this)	eax, ecx, edx		推销关卡中，绘制戴夫“TerraCotta”语句时的花盆动画和展示的小游戏界面。
441480	CutScene::UpdateIntro(eax = CutScene* this)	eax, ecx, edx		更新引入关卡及各个特定时刻触发的特殊效果。引入结束后，立即开启冒险模式的新游戏。
441590	CutScene::DrawIntro(Graphics* g, CutScene* this)	eax, ecx, edx		绘制引入关卡过场的场景图像，包括界面的黑色遮罩、宝开游戏出品的字样和植物大战僵尸的 Logo 等。
441970	std::string::find(unsigned int _Off, edx = const char* _Ptr, std::string* this)	eax = unsigned int _Pos; ecx, edx		在字符串中从 _Off 位置处开始寻找 _Ptr 子字符串，返回 _Ptr 首次出现的位置的索引，;未找到则返回无符号的 -1（即 4294967295）。此函数在计算得到 _Ptr 的长度后调用了 4419A0 的函数。
4419A0	std::string::find(unsigned int _Count, eax = unsigned int _Off, const char* _Ptr, std::string* this)	eax = unsigned int _Pos; ecx, edx		在字符串中从 _Off 位置处开始寻找以 _Ptr 的前 _Count 个字符开头的子字符串，;返回目标子字符串首次出现的位置的索引，未找到则返回无符号的 -1（即 4294967295）。
441A60	std::char_traits<char>::compare(unsigned int _Count, const char* _First2, const char* _First1)	eax = -1(<) | 0(=) | 1(>); ecx, edx	0xC	比较两个字符数组的前 _Count 个字符，当 _First1 大于/等于/小于 _First2 时，返回 1/0/-1。
441AF0	DataReaderException::`scalar deleting destructor'(unsigned int flags, ecx = DataReaderException* this)	eax = *this; ecx, edx		删除数据读取器异常，当 flags 的第 0 位置 1 时会额外释放异常本身占用的内存空间。		【虚函数】[[[(DataReaderException*)]+0]+0]
441B10	DataReaderException::~DataReaderException(ecx = DataReaderException* this)	eax, ecx, edx		销毁数据读取器异常。此函数内部直接跳转至61BFC0的函数。
441B20	DataReader::`scalar deleting destructor'(unsigned int flags, ecx = DataReader* this)	eax = *this; ecx, edx		删除 DataReader 数据读取器，当 flags 的第 0 位置 1 时会额外释放读取器本身占用的内存空间。		【虚函数】[[[(DataReader*)]+0]+0]
441B80	DataReader::~DataReader(ecx = DataReader* this)	eax, ecx, edx		销毁 DataReader 数据读取器，关闭文件流。
441BC0	DataReaderException::DataReaderException(const DataReaderException& __that, ecx = DataReaderException* this)	eax = *this; ecx, edx		复制 __that 的数据用于构造新数据读取器异常。需要一个大小为 0xC 的内存区域用于构造 this。
441BE0	DataReader::ReadBytes(edi = unsigned long theNumBytes, edx = void* theMem, eax = DataReader* this)	eax, ecx, edx		从数据读取器中读取 theNumBytes 个字节的数据并写入 theMem 指向的地址处，未能正常读取时则抛出异常。;当数据读取器存在数据区时，从数据区读取数据否则，当数据读取器存在文件流时，从文件流中读取数据。
441C90	DataReader::ReadString(std::string& theStr, DataReader* this)	eax, ecx, edx		从数据读取器中读取字符串并赋值给 theStr。其读取的过程为：;先读取 2 字节的短整数作为字符串的长度，然后读取相当于字符串长度个字节并写入字符串中。
441CF0	std::string::resize(char _Ch = 0, int _Newsize, ecx = std::string* this)	eax, ecx, edx		将字符串 *this 的长度重置为 _Newsize：若新长度小于原长度，则截取原字符串的前 _Newsize 个字符;若新长度大于原长度，则在原结尾位置之后填充若干个 _Ch 字符直到其长度等于 _Newsize。
441D20	std::string::append(char _Ch, unsigned int _Count, ecx = std::string* this)	eax = *this; ecx, edx		将 _Count 个 _Ch 字符连接在指定字符串后，返回连接后的原字符串。
441DD0	std::string::_Chassign(char _Ch, unsigned int _Count, unsigned int _Off, ecx = std::string* this)	eax, ecx, edx		将字符串中 _Off 位置开始的 _Count 个字符全部更改为 _Ch。
441E30	DataSync::`scalar deleting destructor'(unsigned int flags, ecx = DataSync* this)	eax = *this; ecx, edx		删除 DataSync 数据同步器，当 flags 的第 0 位置 1 时会额外释放同步器本身占用的内存空间。		【虚函数】[[[(DataSync*)]+0]+0]
441E50	std::map<void*, int>::~map<void*, int>(eax = std::map<void*, int>* this)	eax, ecx, edx		销毁并释放无类型指针向整数的映射容器。
441E60	std::map<int, void*>::~map<int, void*>(eax = std::map<int, void*>* this)	eax, ecx, edx		销毁并释放整数向无类型指针的映射容器。
441E70	DataSync::DataSync(DataReader& theReader, DataSync* this)	eax = *this; ecx, edx		由数据读取器创建数据同步器。需要一个大小为 0x38 的内存区域用于构造 this。;数据读取器的创建和 OpenMemory 等操作，可参考原版 4694DD 或 46AC6D 处的相关代码。
441F10	DataSync::DataSync(DataWriter& theWriter, DataSync* this)	eax = *this; ecx, edx		由数据写入器创建数据同步器。需要一个大小为 0x38 的内存区域用于构造 this。;数据写入器的创建和 OpenMemory 等操作，可参考原版 469618 或 46ADA1 处的相关代码。
441FB0	DataSync::~DataSync(ecx = DataSync* this)	eax = *this; ecx, edx		销毁 DataSync 数据同步器。
442020	DataSync::ResetPointerTable(DataSync* this)	eax, ecx, edx		清空数据同步器的整数向指针和指针向整数的映射容器及指针同步链表。
442110	std::map<void*, int>::operator[](ebx = void*& _KeyVal, eax = std::map<void*, int>* this)	eax = int& _Val; ecx, edx		在无类型指针向整数的映射容器中寻找 _KeyVal 指针对应的整数值，返回对该整数的引用。;若容器中原先不存在 _KeyVal 键，则向容器中新添加一个 (_KeyVal, 0) 对组。
442190	std::_Tree<std::_Tmap_traits<void*, int>>::insert;(const std::pair<void*, int>& _Val, _Out_ std::pair<std::_Tree<std::_Tmap_traits<void*, int>>::iterator, bool>&& _Ret, ; eax = std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax = &&_Ret; ecx, edx		向无类型指针向整数的映射红黑树中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在红黑树中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
442270	std::map<int, void*>::operator[](ebx = int& _KeyVal, eax = std::map<int, void*>* this)	eax = void*& _Val; ecx, edx		在整数向无类型指针的映射容器中寻找 _KeyVal 整数对应的指针值，返回对该指针的引用。;若容器中原先不存在 _KeyVal 键，则向容器中新添加一个 (_KeyVal, 0) 对组。
4422F0	std::_Tree<std::_Tmap_traits<void*, int>>::insert;(std::_Tree<std::_Tmap_traits<void*, int>>::iterator _Where, const std::pair<void*, int>& _Val, ; _Out_ std::_Tree<std::_Tmap_traits<void*, int>>::iterator&& _Ret, ; eax = std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax = &&_Ret; ecx, edx		向无类型指针向整数的映射红黑树中的指定位置添加一个对组 _Val，;返回表示插入的键值在红黑树中的位置的迭代器。
4424B0	std::_Tree<std::_Tmap_traits<void*, int>>::_Insert;(const std::pair<void*, int>& _Val, std::_Tree_nod<std::_Tmap_traits<void*, int>>::_Node* _Wherenode, bool _Addleft, ; _Out_ std::_Tree<std::_Tmap_traits<void*, int>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax = &&_Ret; ecx, edx		在无类型指针向整数的映射红黑树中的指定节点下添加一个新的节点，;返回表示插入的键值在红黑树中的位置的迭代器。
4426A0	std::_Tree<std::_Tmap_traits<void*, int>>::~_Tree<std::_Tmap_traits<void*, int>>;(eax = std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax, ecx, edx		销毁并释放无类型指针向整数的映射红黑树。
4426E0	std::_Tree<std::_Tmap_traits<int, void*>>::insert;(std::_Tree<std::_Tmap_traits<int, void*>>::iterator _Where, const std::pair<int, void*>& _Val, ; _Out_ std::_Tree<std::_Tmap_traits<int, void*>>::iterator&& _Ret, ; eax = std::_Tree<std::_Tmap_traits<int, void*>>* this)	eax = &&_Ret; ecx, edx		向整数向无类型指针的映射红黑树中的指定位置添加一个对组 _Val，;返回表示插入的键值在红黑树中的位置的迭代器。
4428A0	std::_Tree<std::_Tmap_traits<void*, int>>::_Erase(std::_Tree_nod<std::_Tmap_traits<void*, int>>::_Node* _Rootnode, ;                                             ecx = std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax, ecx, edx		移除并释放整数向整数的映射容器的红黑树的一个节点及该节点的所有右节点。
4428E0	std::_Tree<std::_Tmap_traits<int, void*>>::~_Tree<std::_Tmap_traits<int, void*>>;(eax = std::_Tree<std::_Tmap_traits<int, void*>>* this)	eax, ecx, edx		销毁并释放整数向无类型指针的映射红黑树。
442920	std::vector<void**>::erase(std::vector<void**>::iterator _Last, std::vector<void**>::iterator _First, ;                          _Out_ std::vector<void**>::iterator&& _Ret, ebx = std::vector<void**>* this)	eax = &&_Ret; ecx, edx		移除无类型指针的指针的向量容器从 _First 至 _Last 之间的所有项。
442980	std::length_error::length_error(const std::length_error& __that, ecx = std::length_error* this)	eax = *this; ecx, edx		复制 __that 的数据用于构造新长度错误。需要一个大小为 0x28 的内存区域用于构造 this。
4429A0	std::_Tree<std::_Tmap_traits<void*, int>>::erase;(std::_Tree<std::_Tmap_traits<void*, int>>::iterator _Last, std::_Tree<std::_Tmap_traits<void*, int>>::iterator _First, ; _Out_ std::_Tree<std::_Tmap_traits<void*, int>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax = &&_Ret; ecx, edx		移除无类型指针向整数的映射红黑树从 _First 至 _Last 之间的所有节点。
442A70	std::_Tree<std::_Tmap_traits<int, void*>>::insert;(const std::pair<int, void*>& _Val, _Out_ std::pair<std::_Tree<std::_Tmap_traits<int, void*>>::iterator, bool>&& _Ret, ; eax = std::_Tree<std::_Tmap_traits<int, void*>>* this)	eax = &&_Ret; ecx, edx		向整数向无类型指针的映射红黑树中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在红黑树中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
442B50	std::_Tree<std::_Tmap_traits<int, void*>>::erase;(std::_Tree<std::_Tmap_traits<int, void*>>::iterator _Last, std::_Tree<std::_Tmap_traits<int, void*>>::iterator _First, ; _Out_ std::_Tree<std::_Tmap_traits<int, void*>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<int, void*>>* this)	eax = &&_Ret; ecx, edx		移除整数向无类型指针的映射红黑树从 _First 至 _Last 之间的所有节点。
442C20	std::_Tree<std::_Tmap_traits<int, void*>>::_Insert;(const std::pair<int, void*>& _Val, std::_Tree_nod<std::_Tmap_traits<int, void*>>::_Node* _Wherenode, bool _Addleft, ; _Out_ std::_Tree<std::_Tmap_traits<int, void*>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<int, void*>>* this)	eax = &&_Ret; ecx, edx		在整数向无类型指针的映射红黑树中的指定节点下添加一个新的节点，;返回表示插入的键值在红黑树中的位置的迭代器。
442E10	std::_Tree<std::_Tmap_traits<void*, int>>::erase;(std::_Tree<std::_Tmap_traits<void*, int>>::iterator _Where, ; _Out_ std::_Tree<std::_Tmap_traits<void*, int>>::iterator&& _Ret, std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax = &&_Ret; ecx, edx		移除无类型指针向整数的映射红黑树的 _Where 处的节点。
4430D0	std::_Tree<std::_Tmap_traits<int, void*>>::erase;(std::_Tree<std::_Tmap_traits<int, void*>>::iterator _Where, ; _Out_ std::_Tree<std::_Tmap_traits<int, void*>>::iterator&& _Ret, std::_Tree<std::_Tmap_traits<int, void*>>* this)	eax = &&_Ret; ecx, edx		移除整数向无类型指针的映射红黑树的 _Where 处的节点。
443390	std::_Tree<std::_Tmap_traits<void*, int>>::_Lrotate(ecx = std::_Tree_nod<std::_Tmap_traits<void*, int>>* _Wherenode, ;                                              std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax, ecx, edx		对无类型指针向整数的映射红黑树的一个节点进行左旋转。
4433E0	std::_Tree<std::_Tmap_traits<void*, int>>::_Rrotate(ecx = std::_Tree_nod<std::_Tmap_traits<void*, int>>* _Wherenode, ;                                              std::_Tree<std::_Tmap_traits<void*, int>>* this)	eax, ecx, edx		对无类型指针向整数的映射红黑树的一个节点进行右旋转。
443430	std::_Tree<std::_Tmap_traits<int, int>>::_Buynode;(esi = const std::pair<int, int>& _Val, std::_Tree_nod<std::_Tmap_traits<int, int>>::_Node* _Larg, ; std::_Tree_nod<std::_Tmap_traits<int, int>>::_Node* _Parg, std::_Tree_nod<std::_Tmap_traits<int, int>>::_Node* _Rarg)	eax = std::_Tree_nod<int, int>::_Node* _Pnode; ;ecx, edx		创建一个整数向整数的映射容器的节点，令该节点的父节点指针指向 _Parg，;并令该节点的左、右子节点指针分别指向 _Larg 和 _Rarg，同时赋值该节点处的对组值为 _Val。
443470	std::_Tree<std::_Tmap_traits<int, int>>::const_iterator::_Dec;(esi = std::_Tree<std::_Tmap_traits<int, int>>::const_iterator* this)	eax, ecx, edx		整数向整数的映射容器的迭代器自减。
4434F0	std::_Tree<std::_Tmap_traits<void*, int>>::_Max(eax = std::_Tree_nod<std::_Tmap_traits<void*, int>>::_Node* _Pnode)	eax = _Node* _Maxnode; ecx, edx		取得无类型指针向整数的映射红黑树从 _Pnode 开始最右侧的一个节点。
443510	std::logic_error::~logic_error(ecx = std::logic_error* this)	eax, ecx, edx		销毁逻辑错误，释放错误字符串。
443550	std::logic_error::`scalar deleting destructor'(unsigned int flags, ecx = std::logic_error* this)	eax = *this; ecx, edx		删除逻辑错误，当 flags 的第 0 位置 1 时会额外释放逻辑错误本身占用的内存空间。		【虚函数】[[[(std::logic_error*)]+0]+0]
4435A0	std::logic_error::what(ecx = std::logic_error* this)	eax = const char* _what; ecx, edx		取得逻辑错误描述内容的 C 字符串。
4435B0	std::out_of_range::out_of_range(const std::out_of_range& __that, std::out_of_range* this)	eax = *this; ecx, edx		复制 __that 的数据用于构造新越界错误。需要一个大小为 0x28 的内存区域用于构造 this。
4435D0	std::logic_error::logic_error(const std::string& _Message, ecx = std::logic_error* this)	eax = *this; ecx, edx		由指定错误消息创建逻辑错误。需要一个大小为 0xC 的内存区域用于构造 this。
443630	std::logic_error::logic_error(const std::logic_error& __that, ecx = std::logic_error* this)	eax = *this; ecx, edx		复制 __that 的数据用于构造新逻辑错误。需要一个大小为 0x28 的内存区域用于构造 this。
4436A0	DataWriter::`scalar deleting destructor'(unsigned int flags, ecx = DataWriter* this)	eax = *this; ecx, edx		删除 DataWriter 数据写入器，当 flags 的第 0 位置 1 时会额外释放写入器本身占用的内存空间。		【虚函数】[[*dataWriter+0]+0]
4436F0	DataWriter::~DataWriter(ecx = DataWriter* this)	eax, ecx, edx		销毁 DataWriter 数据写入器，关闭文件流。
443730	DataWriter::EnsureCapacity(ecx = unsigned long theNumBytes, esi = DataWriter* this)	eax, ecx, edx		确保数据写入器至少拥有 theNumBytes 字节的容量，若当前容量不足则重复令容量翻倍直至满足需求。;当计算取得扩充后的容量后，会申请一片新的内存区域并将原有数据区内的所有数据迁移至新内存区域内。
443770	DataWriter::WriteLong(unsigned long theLong, eax = DataWriter* this)	eax, ecx, edx		当数据写入器存在数据区时，先检查数据区的容量，然后将无符号长整数 theLong 写入数据区;否则当数据写入器存在文件流时，将无符号长整数 theLong 写入文件流。
4437C0	DataWriter::WriteShort(unsigned short theShort, eax = DataWriter* this)	eax, ecx, edx		当数据写入器存在数据区时，先检查数据区的容量，然后将无符号短整数 theShort 写入数据区;否则当数据写入器存在文件流时，将无符号短整数 theShort 写入文件流。
443810	DataWriter::WriteString(eax = const std::string& theStr, ecx = DataWriter* this)	eax, ecx, edx		数据写入器依次写入字符串长度（短整数型）和字符串的文本内容。
4438C0	TodAllocator::Grow(esi = TodAllocator* this)	eax, ecx, edx		分配器额外申请 mGrowCount 项 Item 所需要的内存空间（共 (mGrowCount * mItemSize + 4) 字节）;在新内存空间的首个四字节中存入旧有 mBlockList 的值，并将新内存空间的指针赋值给 mBlockList;在每一项的内存区域的首个四字节中存入上一项的内存区域的首地址，并将末项的首地址赋值给 mFreeList。
443910	std::map<std::string, std::string>::~map<std::string, std::string>(eax = std::map<std::string, std::string>* this)	eax, ecx, edx		销毁并释放字符串向字符串的映射容器。
443920	GetPakPtr_Definition()	eax = PakInterfaceBase*? aPak; ecx, edx		从 Definition 的资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
443990	p_fopen_Definition(eax = const char* theFileName)	eax = PFILE*? pFile; ecx, edx		以二进制只读模式读取指定文件，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，失败则返回 0。;优先尝试通过资源包文件接口在 pak 资源包内读取文件，当无法获取接口时尝试直接读取文件。
4439F0	Sexy::XMLElement::XMLElement(XMLElement* this)	eax = *this; ecx, edx		初始化创建 XML 元素。需要一个大小为 0xA4 的内存区域用于构造 this。
443AE0	Sexy::XMLElement::~XMLElement(XMLElement* this)	eax, ecx, edx		销毁 XML 元素，释放其中的相关数据。
443BE0	DefinitionLoadImage(std::string theName, Image** theImage)	al = bool 是否成功; ecx, edx	0x20	根据定义加载贴图。参数的 theName 为贴图的标签（形如“IMAGE_XXX”），该字符串采用值传递。;先尝试借助资源管理器（根据 resources.xml）加载贴图，若失败则依次在可能的文件路径中手动加载贴图。
443F60	DefinitionLoadFont(std::string theName, edi = Font** theFont)	al = bool 是否成功; ecx, edx	0x1C	根据定义借助资源管理器加载字体。参数的 theName 为字体的标签，该字符串采用值传递。
444020	DefReadFromCacheArray(DefMap* theDefMap, ebx = DefinitionArrayDef* theArray, void*& theReadPtr)	al = bool 是否成功; ecx, edx	0x8	定义类型实例数组的指针的修复。用于描述此类型数据的结构字段的额外数据即指向该类型的 DefMap。;先从 theReadPtr 指向的地址读取整数型的、该类型实例占用的内存大小，并对照 theDefMap 进行检验，;然后根据实例的内存大小与 theArray 中已经正确读取的数组长度（实例数量）申请相应大小的内存区域，;仍然先粗略读取数组的全部数据至申请的内存区域内，然后再根据 theDefMap 依次修复每一项实例，;并将读取的数据作为 theArray 的数组数据（即：将申请的内存的指针赋值给 theArray->mArrayData）。
4440B0	DefReadFromCacheFloatTrack(FloatParameterTrack* theTrack, eax = void*& theReadPtr)	al = bool 是否成功; ecx, edx	0x4	浮点参数轨道的修复，先从 theReadPtr 指向的地址读取整数型的参数轨道节点数量，;然后申请相应数量的轨道节点的内存区域并一次性读取这些轨道节点的数据至申请的内存中。
444110	DefReadFromCacheString(_Out_ char** theString, void*& theReadPtr)	al = bool 是否成功; ecx, edx	0x8	字符数组指针的修复。先从 theReadPtr 指向的地址读取整数型的字符数组长度并申请相应大小的内存区域，;然后读取相应长度的字符数组并写入申请的内存中，并将申请的内存的地址（char*）写入 [theString] 中。
444180	DefReadFromCacheImage(_Out_ Image** theImage, eax = void*& theReadPtr)	al = bool 是否成功; ecx, edx	0x4	贴图指针的修复。先从 theReadPtr 指向的地址读取整数型的贴图标签字符串长度并依此读取贴图标签字符串，;然后根据该标签字符串尝试加载贴图并将贴图指针写入 [theImage] 中（加载失败则写入空指针）。
444220	DefReadFromCacheFont(Font** theFont, eax = void*& theReadPtr)	al = bool 是否成功; ecx, edx	0x4	字体指针的修复。先从 theReadPtr 指向的地址读取整数型的字体标签字符串长度并依此读取字体标签字符串，;然后根据该标签字符串尝试加载字体并将字体指针写入 [theFont] 中（加载失败则写入空指针）。
4442C0	DefMapReadFromCache(void* theDefinition, DefMap* theDefMap, void*& theReadPtr)	al = bool 是否成功; ecx, edx	0xC	在完成初次读取后，;根据 theDefMap 分别确认 theDefinition 的每一个成员变量并修复其中的指针和标志类型的数据。;从 theReadPtr 指向的地址读取数据的同时会相应移动 theReadPtr 指向的位置。修复的详情可参考相应的函数。
444380	DefinitionCalcHashSymbolMap(eax = DefSymbol* theSymbolMap, ecx = int aSchemaHash)	eax = unsigned int aCrcVal; ecx, edx		计算定义标志数组的循环冗余校验值，其中 aSchemaHash 为校验值的初始值。;函数将依次计算 theSymbolMap 数组中每一项定义标志的标志名称和标志数值的 crc32 值。
4443D0	DefinitionCalcHashDefMap(TodList<DefMap*>& theProgressMaps, DefMap* theDefMap, int aSchemaHash)	eax = unsigned int aCrcVal; ecx, edx	0xC	正式计算定义结构图 theDefMap 的循环冗余校验值，其中 aSchemaHash 为校验值的初始值。计算的原理为：;(1)先以 aSchemaHash 为初始值，计算定义类大小（theDefMap->mDefSize）的 crc32 值;(2)从(1)中的结果作为校验值初始值开始，依次计算每个定义结构字段的偏移量和数据类型的 crc32 值;(3)对于部分特殊类型的结构字段，该结构字段的计算需额外调用相应的函数计算其额外数据的 crc32 值;对于(3)中的情况，为处理递归调用，函数会将当前计算的 theDefMap 指针加入到 theProgressMaps 中。;开始(1)的计算之前，若检测到 theDefMap 指针已经位于 theProgressMaps 中，则会直接返回 aSchemaHash。
444490	DefinitionCalcHash(DefMap* theDefMap)	eax = unsigned int aCrcVal; ecx, edx	0x4	开始计算定义结构图 theDefMap 的循环冗余校验值，初始化定义结构图链表并调用正式计算的函数。
444500	DefinitionUncompressCompiledBuffer;(unsigned int& theUncompressedSize, unsigned int theCompressedBufferSize, esi = void* theCompressedBuffer)	eax = void* aUncompressedBuffer; ecx, edx	0x8	将从 .compiled 资源文件中读取的数据解压缩，并将解压后的数据长度写入 [&theUncompressedSize] 中。;其中，theCompressedBuffer 的前 2 个四字节将被视作一个压缩定义头，实际解压是从第 9 个字节开始的。
444560	DefinitionReadCompiledFile;(void* theDefinition, DefMap* theDefMap, eax = const std::string& theCompiledFilePath)	al = bool 是否成功; ecx, edx	0x8	根据定义结构图 theDefMap 从指定的 .compiled 文件中读取定义数据并写入 theDefinition 中。
444770	DefinitionGetCompiledFilePathFromXMLFilePath;(ebx = _Out_ std::string&& aCompiledFilePath, const std::string& theXMLFilePath)	eax = std::string&& aUncompressedBuffer; ;ecx, edx	0x4	根据给定的 XML 文件名 theXMLFilePath 获取该文件在 pak 中对应的 .compiled 文件的路径。;即：aCompiledFilePath = compiled\\ + theXMLFilePath + .compiled。
4447F0	DefinitionCompileAndLoad(void* theDefinition, DefMap* theDefMap, const std::string& theXMLFilePath)	al = bool 是否成功; ecx, edx	0xC	根据定义结构图 theDefMap 从 theXMLFilePath 相应的 .compiled 文件中读取定义数据并写入 theDefinition 中。当读取失败时，会弹出 missing resource %s 错误弹窗并退出程序（“%s” 为 .compiled 文件名）。
4448E0	FloatTrackEvaluate(float theInterp, float theTimeValue, eax = FloatParameterTrack& theTrack)	st(0) = aTrackVal; eax, ecx, edx	0x8	根据给定的时间和插值计算浮点参数轨道的当前值，其中 theTimeValue 和 theInterp 的取值范围均为 [0, 1]。;若给定时间值早于首个阶段或晚于最后一个阶段，则直接以插值计算首个或最后一个阶段的分布曲线上的值;否则，以插值分别计算当前及前一个阶段的分布曲线上的值，然后在缓动曲线上计算上述两个值之间的过渡。
4449F0	FloatTrackSetDefault(float theValue, esi = FloatParameterTrack& theTrack)	eax, ecx, edx	0x4	当浮点参数轨道 theTrack 不存在轨道节点且给定的 theValue 不为 0 时，将浮点参数轨道设为单节点的默认值：;申请 1 个节点的内存空间作为轨道的节点，并将节点的时间赋值为 0，最大、最小值均赋值为 theValue。
444A50	DefinitionFreeArrayField(ebx = DefMap* theDefMap, edi = DefinitionArrayDef* theArray)	eax, ecx, edx		根据定义结构图 theDefMap 依次释放定义数组中的每一项定义实例，然后释放数组数据本身占用的内存空间。
444A90	DefinitionFreeMap(void* theDefinition, DefMap* theDefMap)	eax, ecx, edx	0x8	根据定义结构图 theDefMap 依次释放定义实例 theDefinition 中所有指针型成员变量指向的内存空间，;同时清除指针的值（将指针赋值为空指针）。
444B00	std::list<std::map<std::string, std::string>::iterator>::_Tidy;(esi = std::list<std::map<std::string, std::string>::iterator>* this)	eax, ecx, edx		释放字符串向字符串的映射容器的迭代器的链表的每一个节点所占用的内存空间。
444B20	std::_Tree<std::_Tmap_traits<std::string, std::string>>::~_Tree<std::_Tmap_traits<std::string, std::string>>;(eax = std::_Tree<std::_Tmap_traits<std::string, std::string>>* this)	eax, ecx, edx		销毁并释放字符串向字符串的映射红黑树。
444B60	std::list<std::map<std::string, std::string>::iterator>::_Buynode()	eax = std::_List_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符串向字符串的映射容器的迭代器的链表容器的节点，并初始化该节点的前、后节点指针指向其自身。
444B80	std::_Tree<std::_Tmap_traits<std::string, std::string>>::erase;(std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator _Last, ; std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator _First, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, std::string>>* this)	eax = &&_Ret; ecx, edx		移除字符串向字符串的映射红黑树从 _First 至 _Last 之间的所有节点。
444C50	std::_Tree<std::_Tmap_traits<std::string, std::string>>::erase;(std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator _Where, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator&& _Ret, ; std::_Tree<std::_Tmap_traits<std::string, std::string>>* this)	eax = &&_Ret; ecx, edx		移除字符串向字符串的映射红黑树的 _Where 处的节点。
444F50	std::_Tree<std::_Tmap_traits<std::string, std::string>>::_Buynode()	eax = _Node* _Pnode; ecx, edx		创建一个字符串向字符串的映射红黑树的节点，令该节点的子节点和父节点指针为空指针，并初始化该节点的颜色。
444F90	std::_Tree<std::_Tmap_traits<std::string, std::string>>::_Erase;(std::_Tree_nod<std::_Tmap_traits<std::string, std::string>>::_Node* _Rootnode, ; ecx = std::_Tree<std::_Tmap_traits<std::string, std::string>>* this)	eax, ecx, edx		移除并释放字符串向字符串的映射容器的红黑树的一个节点及该节点的所有右节点。
445010	std::_Tree<std::_Tmap_traits<void*, int>>::_Lrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, std::string>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, std::string>>* this)	eax, ecx, edx		对字符串向字符串的映射红黑树的一个节点进行左旋转。
445060	std::_Tree<std::_Tmap_traits<std::string, std::string>>::_Max;(eax = std::_Tree_nod<std::_Tmap_traits<std::string, std::string>>::_Node* _Pnode)	eax = _Node* _Maxnode; ecx, edx		取得字符串向字符串的映射红黑树从 _Pnode 开始最右侧的一个节点。
445080	std::_Tree<std::_Tmap_traits<std::string, std::string>>::_Min;(eax = std::_Tree_nod<std::_Tmap_traits<std::string, std::string>>::_Node* _Pnode)	eax = _Node* _Minnode; ecx, edx		取得字符串向字符串的映射红黑树从 _Pnode 开始最左侧的一个节点。
4450A0	std::_Tree<std::_Tmap_traits<void*, int>>::_Rrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, std::string>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, std::string>>* this)	eax, ecx, edx		对字符串向字符串的映射红黑树的一个节点进行右旋转。
4450F0	std::_Tree<std::_Tmap_traits<std::string, std::string>>::const_iterator::_Inc;(esi = std::_Tree<std::_Tmap_traits<std::string, std::string>>::const_iterator* this)	eax, ecx, edx		字符串向字符串的映射红黑树的迭代器自增。
445160	std::operator+<char>(const std::string& _Right, edi = const char* _Left, esi = _Out_ std::string&& _Result)	eax = std::string&& _Result; ecx, edx		连接字符数组 _Left 与字符串 _Right，返回连接后的新字符串。
445200	TodList<DefMap*>::~TodList<DefMap*>(esi = TodList<DefMap*>* this)	eax, ecx, edx		销毁定义结构图链表。对所有四字节型数据的链表同样适用。
445210	TodList<DefMap*>::AddTail(DefMap*& theTail, ebx = TodList<DefMap*>* this)	eax, ecx, edx		向定义结构图链表的末尾添加一项 theTail。对所有四字节型数据的链表同样适用。
445290	std::_Allocate<Color>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个颜色所需要的内存空间，单个颜色占用的内存大小为 0x10。;当 _Count 个颜色的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
445290	std::_Allocate<std::_List_nod<std::map<std::string, std::string>::iterator>::_Node>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符串映射容器迭代器的链表容器的节点所需要的内存空间，单个节点占用的内存大小为 0x10。;当 _Count 个链表容器的节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
4452E0	std::pair<std::string, std::string>::~pair<std::string, std::string>(esi = std::pair<std::string, std::string>* this)	eax, ecx, edx		销毁两个字符串组成的对组。
4452E0	AttacherInfo::~AttacherInfo(esi = AttacherInfo* this)	eax, ecx, edx		销毁从属轨道信息，释放动画名和轨道名字符串。
445330	EffectSystem::EffectSystemInitialize(eax = EffectSystem* this)	eax, ecx, edx		初始化效果系统，创建并初始化粒子系统、轨迹、动画和附件的容器。
445490	EffectSystem::EffectSystemDispose(EffectSystem* this)	eax, ecx, edx		释放效果系统，释放并删除粒子系统、轨迹、动画和附件的容器。
4455A0	DataArray<Trail>::~DataArray<Trail>(esi = DataArray<Trail>* this)	eax = *this, ecx =  ? , edx =  ?		销毁轨迹数据数组，释放其中的所有轨迹，并释放轨迹区域占用的内存空间。
4455E0	EffectSystem::FreeAll(EffectSystem* this)	eax, ecx, edx		销毁并释放效果系统中的所有效果（粒子系统、粒子发射器、粒子、轨迹、动画、附件）。
445680	EffectSystem::ProcessDeleteQueue(EffectSystem* this)	eax, ecx, edx		处理被删除的效果对象，以默认析构函数销毁对象并在对应的数据数组中回收其占用的序列和编号。
445890	EffectSystem::Update(edi = EffectSystem* this)	eax, ecx, edx		效果系统更新，更新其中的所有效果。
4459B0	Tod_Tod_lClip | rClip;(const float edge, eax = const TriVertex& off, ecx = const TriVertex& on, edx = TriVertex& dst)	eax, ecx, edx	0x4	将超出左侧或右侧边界的三角顶点 off 参照边界内的三角顶点 on 进行裁剪，并将结果写入 dst 中。;其中，edge 为左侧或右侧边界的横坐标。裁剪的实质是以 on 为参考将 off 的横坐标缩放至边界上。
445B50	Tod_tClip | Tod_bClip;(const float edge, eax = const TriVertex& off, ecx = const TriVertex& on, edx = TriVertex& dst)	eax, ecx, edx	0x4	将超出顶部或底部边界的三角顶点 off 参照边界内的三角顶点 on 进行裁剪，并将结果写入 dst 中。;其中，edge 为顶部或底部边界的纵坐标。裁剪的实质是以 on 为参考将 off 的纵坐标缩放至边界上。
445D00	Tod_leClip(const float edge, eax = TriVertex** dst, TriVertex** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为左边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
445E00	Tod_reClip(const float edge, eax = TriVertex** dst, TriVertex** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为右边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
445F00	Tod_teClip(const float edge, eax = TriVertex** dst, TriVertex** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为上边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
446000	Tod_beClip(const float edge, eax = TriVertex** dst, TriVertex** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为下边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
446100	Tod_clipShape(const float bottom, const float top, const float right, const float left, ;              eax = TriVertex* src, esi = TriVertex** dst)	eax = unsigned int vCount; ecx, edx	0x10	将 src 中的 3 个三角顶点组成的三角形依次分别以指定的左、右、上、下边界进行裁剪，;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。;当任意一次裁剪后得到的三角顶点数量小于 2 个（无法组成图形）时，将立即终止裁剪过程并返回 0。
4461B0	TodTriangleGroup::TodTriangleGroup(eax = TodTriangleGroup* this)	eax = *this; ecx, edx		初始化三角组。需要一个大小为 0x3C0C 的内存区域用于构造 this。
4461F0	TodTriangleGroup::DrawGroup(Graphics* g, esi = TodTriangleGroup* this)	eax, ecx, edx		绘制三角组。绘制完成后会将当前记录的三角形个数清零（但不会清除贴图指针）。
446300	TodTriangleGroup::AddTriangle;(const Rect& theSrcRect, int theDrawMode, const Color& theColor, const Rect& theClipRect, ; const SexyMatrix3& theMatrix, eax = Image* theImage, Graphics* g, edi = TodTriangleGroup* this)	eax, ecx, edx		将 theImage 的 theSrcRect 区域经过 theMatrix 变换及 theClipRect 裁剪后的图形及图像添加入三角组中。;当指定的纹理贴图或绘制模式与当前值不同时，或三角组中的三角形数量已满时，会先绘制已有的三角形。
4468D0	DataArray<TodParticleSystem>::DataArrayFreeAll(edi = DataArray<TodParticleSystem>* this)	eax, ecx, edx		以析构函数销毁并释放粒子系统数据数组中的所有粒子系统。
446960	DataArray<TodParticleEmitter>::DataArrayFreeAll(edi = DataArray<TodParticleEmitter>* this)	eax, ecx, edx		以析构函数销毁并释放粒子发射器数据数组中的所有粒子发射器。
446A10	DataArray<TodParticle>::DataArrayFreeAll(eax = DataArray<TodParticle>* this)	eax, ecx, edx		以析构函数销毁并释放粒子数据数组中的所有粒子。
446A80	DataArray<Reanimation>::DataArrayFreeAll(ebx = DataArray<Reanimation>* thsi)	eax, ecx, edx		以析构函数销毁并释放动画数据数组中的所有动画。
446B30	DataArray<Reanimation>::DataArrayFree(esi = Reanimation* theItem, ebx = DataArray<Reanimation>* this)	eax, ecx, edx		销毁并从动画数据数组中移除动画，同时从全局内存分配器中回收动画轨道占用的内存空间。
446B80	RGB_to_HSL(float& l, edx = float& s, ecx = float& h, float b, float g, float r)	eax	0x10	将标准化的 RGB 颜色转化为标准化的 HSL 颜色，其中 r,g,b 及取得的 h,s,l 的取值范围均为 [0, 1]。;当给定的 rgb 颜色属于灰色（即 r、g、b 色值相同）时，取得的 h 值为未定义。
446D80	HSL_to_RGB(esi = float& b, edi = float& g, ebx = float& r, float l, float s, float h)	eax	0xC	将标准化的 HSL 颜色转化为标准化的 RGB 颜色，其中 h,s,l 及取得的 r,g,b 的取值范围均为 [0, 1]。;当给定的 HSL 颜色属于灰色（即 s 值为 0）时，参数的 h 值无实用，取得的 r、g、b 色值均等于 l。
446EC0	std::map<Image*, Image*>::~map<Image*, Image*>(ecx = std::map<Image*, Image*>* this)	eax, ecx, edx		销毁并释放贴图指针向贴图指针的映射容器。
446F00	FilterEffectDisposeForApp()	eax, ecx, edx		删除并释放每种滤镜效果作用下的、原贴图向滤镜贴图的映射容器，以及容器中的滤镜贴图。
446FD0	FilterEffectDoLumSat(float theSat, float theLum, MemoryImage* theImage)	eax, ecx, edx	0xC	将贴图中所有像素的亮度和饱和度分别乘以 theLum 和 theSat（不改变色相）。
447190	FilterEffectDoWhite(esi = MemoryImage* theImage)	eax, ecx, edx		将贴图中的所有像素的颜色转化为白色（不改变不透明度）。
4471D0	FilterEffectCreateImage(FilterEffect theFilterEffect, Image* theImage)	eax = Image* aNewImage; ecx, edx	0x8	创建贴图在指定滤镜效果作用下得到的新贴图。
447340	FilterEffectGetImage(eax = FilterEffect theFilterEffect, Image* theImage)	eax = Image* aNewImage; ecx, edx	0x4	从滤镜相应的映射容器中取得贴图在指定滤镜效果作用下得到的新贴图，若不存在则创建并加入容器中。
4473E0	std::map<Image*, Image*>::map<Image*, Image*>(ecx = std::map<Image*, Image*>* this)	eax = *this, ecx =  ? , edx =  ?		初始化创建贴图指针向贴图指针的映射容器。需要一个大小为 0xC 的内存区域用于构造 this。
447410	std::_Tree<std::_Tmap_traits<<Image*, Image*>>::insert;(const std::pair<Image*, Image*>& _Val, ; _Out_ std::pair<std::_Tree<std::_Tmap_traits<<Image*, Image*>>::iterator, bool>&& _Ret, ; ebx = std::_Tree<std::_Tmap_traits<<Image*, Image*>>* this)	eax = &&_Ret; ecx, edx		向贴图指针向贴图指针的映射容器中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
4474F0	std::_Tree<std::_Tmap_traits<<Image*, Image*>>::find;(ebx = Image*& _Keyval, eax = _Out_ std::_Tree<std::_Tmap_traits<Image*, Image*>>::iterator&& _Ret, ; esi = std::_Tree<std::_Tmap_traits<Image*, Image*>>* this)	eax = &&_Ret; ecx, edx		在贴图指针向贴图指针的映射容器中寻找 _Keyval 原贴图指针对应的目标贴图指针。;若找到，则返回指示该对组所在位置处的迭代器否则，返回相当于 map.end() 的迭代器。
447560	std::_Tree<std::_Tmap_traits<Image*, Image*>>::_Insert;(const std::pair<Image*, Image*>& _Val, std::_Tree_nod<std::_Tmap_traits<Image*, Image*>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<Image*, Image*>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<Image*, Image*>>* this)	eax = &&_Ret; ecx, edx		在贴图指针向贴图指针的映射红黑树中的指定节点下添加一个新的节点，;返回表示插入的键值在红黑树中的位置的迭代器。
447750	std::_Tree<std::_Tmap_traits<<Image*, Image*>>::erase;(std::_Tree<std::_Tmap_traits<<Image*, Image*>>::iterator _Last, ; std::_Tree<std::_Tmap_traits<<Image*, Image*>>::iterator _First, ; edi = std::_Tree<std::_Tmap_traits<<Image*, Image*>>* this, ; _Out_ std::_Tree<std::_Tmap_traits<<Image*, Image*>>::iterator&& _Ret)	eax = &&_Ret; ecx, edx		删除贴图指针向贴图指针的映射容器中 [_First, _Last) 之间的所有元素，并取得删除后的新的迭代器。;其中，参数 _First 和 _Last 采用值传递，出参 _Ret 采用引用传递。
447820	std::_Tree<std::_Tmap_traits<Image*, Image*>>::erase;(std::_Tree<std::_Tmap_traits<Image*, Image*>>::iterator _Where, ; _Out_ std::_Tree<std::_Tmap_traits<Image*, Image*>>::iterator&& _Ret, ; std::_Tree<std::_Tmap_traits<Image*, Image*>>* this)	eax = &&_Ret; ecx, edx		移除字符串向字符串的映射红黑树的 _Where 处的节点。
447AE0	Sexy::ButtonWidget::MouseUp(int theClickCount, int theY, int theX, ecx = ButtonWidget* this);Sexy::EditWidget::MouseUp(int theClickCount, int theY, int theX, ecx = EditWidget* this);Sexy::Dialog::MouseUp(int theClickCount, int theY, int theX, ecx = Dialog* this)	eax, ecx, edx		按钮/输入框/对话中鼠标松开。此函数直接跳转至Sexy::Widget::MouseUp。		【虚函数】[[[(ButtonWidget*)]+0]+E0] & [[[(EditWidget*)]+0]+E0] & [[[(Dialog*)]+0]+E0]
447AF0	Sexy::DailogButton::~DialogButton(ecx = DialogButton* this)	eax, ecx, edx		销毁对话按钮。此函数直接跳转至53F340的函数。
447B00	DrawStoneButton(const std::string& theLabel, bool isHighLighted, bool isDown, ;                int theHeight, int theWidth, int y, eax = int x, Graphics* g)	eax, ecx, edx	0x1C	在 (x, y) 位置处绘制一个宽度为 theWidth、高度为 theHeight 的石制按钮的贴图，;并以 FONT_DWARVENTODCRAFT18GREENINSET 字体在按钮上绘制 theLabel 文本。
447C60	GameButton::GameButton(int theId, esi = GameButton* this)	eax = *this; ecx, edx		初始化游戏按钮基础数据，并设定其颜色数组。需要一个大小为 0x130 的内存区域用于构造 this。
447DE0	GameButton::~GameButton(GameButton* this)	eax, ecx, edx		销毁游戏按钮，释放其字体和文本字符串占用的内存空间。
447E60	GameButton::DrawButtonImage(int theY, edi = int theX, eax = const Rect& theRect, ;                            Image* theImage, ecx = Graphics* g, edx = GameButton* this)	eax, ecx, edx		若给定的 theRect 矩形的宽度不为零，则绘制游戏按钮贴图的 theRect 区域，否则绘制 theImage 贴图。;实际绘制的位置的横（纵）坐标为给定的横（纵）纵坐标加上游戏按钮自身的横（纵）向偏移距离。
447EC0	GameButton::Draw(Graphics* g, esi = GameButton* this)	eax, ecx, edx		绘制游戏按钮。
448310	GameButton::IsMouseOver(eax = GameButton* this)	al = 0(否) | 1(是)		判断游戏按钮是否得到鼠标悬浮。
448330	GameButton::Update(esi = GameButton* this)	eax, ecx, edx		游戏按钮更新，包括鼠标按下与悬浮与否的状态的更新和依此进行的悬浮不透明度相关的更新。
448470	GameButton::SetLabel(edx = const string& theLabel, GameButton* this)	eax, ecx, edx		设置游戏按钮的文本内容。对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。
4484E0	NewLawnButton::SetLabel(edx = const string& theLabel, NewLawnButton* this)	eax, ecx, edx		设置贴图按钮的文本内容，对其父类的按钮（按钮控件、对话按钮等）同样适用。;对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。
448550	LawnStoneButton::SetLabel(edx = const string& theLabel, LawnStoneButton* this)	eax, ecx, edx		设置草坪石制按钮的文本内容。对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。
4485C0	LawnStoneButton::Draw(Graphics* g, LawnStoneButton* this)	eax, ecx, edx		绘制草坪石制按钮。		【虚函数】[[[(LawnStoneButton*)]+0]+68]
448620	MakeButton(const string& theText, ButtonListener* theListener, int theId)	eax = LawnStoneButton* aButton; ecx, edx	0xC	创建草坪石制按钮。
4486C0	NewLawnButton::NewLawnButton(ButtonListener* theListener, ecx = int theId, NewLawnButton* this)	eax = *this; ecx, edx		初始化创建贴图按钮。需要一个大小为 0x170 的内存区域用于构造 this。
448770	NewLawnButton::`scalar deleting destructor'(unsigned int flags, ecx = NewLawnButton* this)	eax = *this; ecx, edx		删除贴图按钮，当 flags 的第 0 位置 1 时会额外释放贴图按钮本身占用的内存空间。		【虚函数】[[[(NewLawnButton*)]+0]+0]
448790	NewLawnButton::Draw(Graphics* g, NewLawnButton* this)	eax, ecx, edx		绘制贴图按钮。		【虚函数】[[[(NewLawnButton*)]+0]+68]
448B70	NewLawnButton::IsPointVisible(int y, int x, ecx = NewLawnButton* this)	al = 0(否) | 1(是); ecx, edx		判断贴图按钮内 (x, y) 位置处的一点是否属于按钮的判定范围内。		【虚函数】[[[(NewLawnButton*)]+0]+F0]
448BC0	MakeNewButton(Image* theImageDown, ebx = Image* theImageOver, edi = Image* theImageNormal, ;              Font* theFont, const std::string& theText, ButtonListener* theListener, int theId)	eax = NewLawnButton* aButton; ecx, edx	0x14	创建贴图按钮。当 theText 文本字数为 0 时，字体指针可以为空指针（文本字符串不能解引用空指针）。
448C80	GameSelectorOverlay::Draw(Graphics* g, ecx = GameSelectorOverlay* this);StoreScreenOverlay::Draw(Graphics* g, ecx = StoreScreenOverlay* this)	eax, ecx, edx		商店、主菜单等场景的悬浮控件的公用绘制函数，内部直接跳转至父控件的 DrawOverlay() 函数。		【虚函数】[[[(GameSelectorOverlay*)]+0]+68] & [[[(StoreScreenOverlay*)]+0]+68]
448C90	GameSelectorOverlay::`scalar deleting destructor'(unsigned int flags, ecx = GameSelectorOverlay* this)	eax = *this; ecx, edx		悬浮控件的公用 delete 操作，当 flags 的第 0 位置 1 时会额外释放控件本身占用的内存空间。		【虚函数】[[[(GameSelectorOverlay*)]+0]+0]
448C90	StoreScreenOverlay::`scalar deleting destructor'(unsigned int flags, ecx = StoreScreenOverlay* this)	eax = *this; ecx, edx		悬浮控件的公用 delete 操作，当 flags 的第 0 位置 1 时会额外释放控件本身占用的内存空间。		【虚函数】[[[(StoreScreenOverlay*)]+0]+0]
448CB0	GameSelector::GameSelector(LawnApp* theApp, GameSelector* this)	eax = *this; ecx, edx		初始化创建主菜单界面，并进行存档的同步。需要一个大小为 0x130 的内存区域用于构造 this。
449D00	GameSelector::DeleteGameSelector(unsigned int flags, ecx = GameSelector* this)	eax = *this; ecx, edx		删除 GameSelector 主菜单界面，当 flags 的第 0 位置 1 时会额外释放界面本身占用的内存空间。		【虚函数】[[[(GameSelector*)]+0]+0]
449D20	GameSelector::~GameSelector(ecx = GameSelector* this)	eax, ecx, edx		销毁主菜单界面，删除其中的所有按钮及鼠标悬浮标签。
449E60	GameSelector::SyncButtons(esi = GameSelector* this)	eax, ecx, edx		根据存档同步主菜单界面内图鉴、商店、禅境花园按钮的可见和可用与否及三种额外模式按钮的颜色和贴图。
44A2E0	GameSelector::AddTrophySparkle(edi = GameSelector* this)	eax, ecx, edx		主菜单界面创建向日葵奖杯的闪亮特效。
44A320	GameSelector::SyncProfile(bool theShowLoading, ecx = GameSelector* this)	eax, ecx, edx		更换当前存档时，用于同步存档配置相关。当 theShowLoading 为 1 时，会创建 “Loading...” 对话。
44A650	GameSelector::Draw(Graphics* g, ecx = GameSelector* this)	eax, ecx, edx		绘制主菜单界面的场景。		【虚函数】[[[(GameSelector*)]+0]+68]
44AB50	GameSelector::DrawOverlay(Graphics* g, ecx = GameSelector* this)	eax, ecx, edx		绘制主菜单界面悬浮及前景，包括：关卡数字、浇水提示气泡、叶子和花、内测文本和鼠标悬浮标签。		【虚函数】[[[(GameSelector*)]+0]+B0]
44B0D0	GameSelector::UpdateTooltip(GameSelector* this)	eax, ecx, edx		主菜单界面更新鼠标悬浮标签，鼠标位于向日葵奖杯上时显示相应的标签。
44B2A0	GameSelector::Update(ecx = GameSelector* this)	eax, ecx, edx		主菜单界面更新，将自身标记为已变更，更新开始游戏的进程及主菜单内的各动画和按钮的状态和位置等。		【虚函数】[[[(GameSelector*)]+0]+58]
44BB20	GameSelector::TrackButton(float theOffsetY, float theOffsetX, const char* theTrackName, ;                          edi = DialogButton* theButton, eax = GameSelector* this)	eax, ecx, edx		将 theButton 按钮的坐标移动至主菜单自身动画的 theTrackName 轨道的 (当前位置 + 偏移位置) 处。
44BBC0	GameSelector::AddedToManager(WidgetManager* theWidgetManager, ecx = GameSelector* this)	eax, ecx, edx		将主菜单界面加入控件管理器，并将其中的所有按钮及悬浮控件加入控件管理器。		【虚函数】[[[(GameSelector*)]+0]+50]
44BCA0	GameSelector::RemovedFromManager(WidgetManager* theWidgetManager, ecx = GameSelector* this)	eax, ecx, edx		将主菜单界面移出控件管理器，并将其中的所有按钮及悬浮控件移出控件管理器。		【虚函数】[[[(GameSelector*)]+0]+54]
44BD80	GameSelector::OrderInManagerChanged(ecx = GameSelector* this)	eax, ecx, edx		当主菜单界面在控件管理器中所处的图层发生变化时，重新将其中的所有按钮及悬浮控件置于自身上层。		【虚函数】[[[(GameSelector*)]+0]+78]
44BE60	GameSelector::KeyDown(KeyCode theKey, ecx = GameSelector* this)	eax, ecx, edx		主菜单界面键盘按键按下，进行游戏指令的按键检测。		【虚函数】[[[(GameSelector*)]+0]+C0]
44C200	GameSelector::KeyChar(char theChar, ecx = GameSelector* this)	eax, ecx, edx		主菜单界面输入 theChar 字符，判断并处理内测模式下的全模式暂时解锁（c）和完美存档（u）功能。		【虚函数】[[[(GameSelector*)]+0]+BC]
44C360	GameSelector::MouseDown(int theClickCount, int y, int x, ecx = GameSelector* this)	eax, ecx, edx		主菜单界面鼠标按下，令点击的花瓣开始脱落。若允许作弊按键且正在进行开始动画，则立即跳过动画。		【虚函数】[[[(GameSelector*)]+0]+D8]
44C4C0	GameSelector::ButtonMouseEnter(int theId, ecx = ButtonListener* this)	eax, ecx, edx		主菜单界面鼠标进入按钮时，若该按钮可用，则播放按钮轻触的音效。		【虚函数】[[[(ButtonListener*)]+0]+10]/[[[(GameSelector*)]+88]+10]
44C540	GameSelector::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		主菜单界面中按钮按下时，播放按下按钮的音效。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(GameSelector*)]+88]+4]
44C590	GameSelector::ClickedAdventure(eax = GameSelector* this)	eax, ecx, edx		主菜单界面中点击冒险模式按钮时触发，禁用主菜单内所有按钮并布置游戏开始动画。;试玩模式下，若当前不低于 3-5 关卡，则先弹出重玩确认的弹窗。
44C890	GameSelector::ShouldDoZenTuturialBeforeAdventure(eax = GameSelector* this)	al = 0(否) | 1(是); ecx		判断当前是否需要进行禅境花园教程。当且仅当当前为一周目 4-5 关卡且花园内无盆栽时，返回“是”。
44C8C0	GameSelector::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		主菜单界面中松开按下的按钮时，根据按下的按钮触发相应的事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(GameSelector*)]+88]+8]
44CB00	GameSelector::AddPreviewProfiles(ecx = GameSelector* this)	eax, ecx, edx		分别创建 4 个冒险模式进度为 2 至 5 大关的存档、以及 1 个完成冒险模式和 1 个全模式解锁的存档。
44CFA0	GridItem::GridItem(eax = Griditem* this)	eax = *this; ecx, edx		初始化场地物品基础数据。需要一个大小为 0xE8 的内存区域用于构造 this。
44D000	GridItem::GridItemDie(esi = Griditem* this)	eax, ecx, edx		令场地物品消失，同时销毁场地物品的相关动画和粒子系统。
44D070	GridItem::DrawGridItemOverlay(Graphics* g, esi = Griditem* this)	eax, edx		当蜗牛需求巧克力且玩家手持巧克力时，绘制蜗牛需求的气泡。
44D140	GridItem::DrawGridItem(ecx = Graphics* g, edx = Griditem* this)	eax, ecx, edx		绘制场地物品。
44D250	GridItem::DrawIZombieBrain(ebx = Graphics* g, Griditem* this)	eax, ecx, edx		绘制我是僵尸模式的脑子。
44D3A0	GridItem::DrawGraveStone(Graphics* g, Griditem* this)	eax, ecx, edx		绘制墓碑及其下方的泥土，会访问到 Board 的墓碑形状和坐标偏移。
44D690	GridItem::DrawStinky(esi = Graphics* g, Griditem* this)	eax, ecx, edx		绘制蜗牛，对于吃下巧克力的蜗牛会额外绘制其运动轨迹的残影。
44D860	GridItem::DrawCrater(Graphics* g, Griditem* this)	eax, ecx, edx		绘制弹坑。
44DB00	GridItem::DrawScaryPot(Graphics* g, Griditem* this)	eax, ecx, edx		绘制罐子及其阴影，透视状态下额外绘制其内容物。
44DFD0	GridItem::DrawLadder(Graphics* g, Griditem* this)	eax, ecx, edx		绘制梯子。
44E090	GridItem::AddGraveStoneParticles(Griditem* this)	eax, ecx, edx		创建墓碑升起时的土壤特效和音效。创建特效时会访问到 Board 的墓碑坐标偏移。
44E1B0	GridItem::OpenPortal(eax = Griditem* this)	eax, ecx, edx		开启传送门，若传送门动画不存在则创建。
44E360	GridItem::ClosePortal(esi = Griditem* this)	eax, ecx, edx		关闭传送门。
44E400	GridItem::UpdatePortal(edi = Griditem* this)	eax, ecx, edx		传送门开启和关闭完成时的更新。
44E520	GridItem::UpdateScaryPot(edi = Griditem* this)	eax, ecx, edx		更新罐子的透视状态。
44E5E0	GridItem::Update(eax = Griditem* this)	eax, ecx, edx		更新场地物品的动画、粒子系统、状态和特性等。
44E6A0	GridItem::RakeFindZombie(Griditem* this)	eax = Zombie*? aTargetZombie; ecx, edx		寻找钉耙攻击范围内的目标僵尸，若范围内不存在目标僵尸则返回 0。
44E780	GridItem::UpdateRake(eax = Griditem* this)	eax, ecx, edx		更新钉耙的触发和攻击。
44E8A0	LawnGetCloseRequest()	al = 0(否) | 1(是)		判断是否有关闭程序的请求。【函数指针】[69E6A0]（gAppCloseRequest）
44E8C0	LawnHasUsedCheatKeys()	al = 0(否) | 1(是); ecx		判断玩家是否使用过作弊按键。【函数指针】[69E6A4]（gAppHasUsedCheatKeys）
44E8F0	WinMain(int nCmdShow, LPSTR lpCmdLine, HINSTANCE hPrevInstance, HINSTANCE hInstance)	eax = int 进程结果; ecx, edx		程序执行的入口函数。初始化程序基础设定，创建游戏程序并开始执行，程序关闭后删除游戏程序并退出。
44EAA0	LawnApp::LawnApp(LawnApp* this)	eax = *this; ecx, edx		初始化创建游戏程序。需要一个大小为 0x8C8 的内存区域用于构造 this。
44EDD0	LawnApp::`scalar deleting destructor'(unsigned int flags, ecx = LawnApp* this)	eax = *this; ecx, edx		删除游戏程序，当 flags 的第 0 位置 1 时会额外释放游戏程序本身占用的内存空间。		【虚函数】[[[(LawnApp*)]+0]+0]
44EDF0	LawnApp::~LawnApp(ecx = LawnApp* this)	eax, ecx, edx		销毁游戏程序，若处于关卡内则尝试保存用户存档和关卡存档。删除程序内各个系统和对象。
44F1B0	TypingCheck::`scalar deleting destructor'(esi = TypingCheck* this)	eax = *this; ecx, edx		销毁指令，同时释放内容字符串、记录字符串及指令本身占用的内存空间。
44F200	LawnApp::Shutdown(ecx = LawnApp* this)	eax, ecx, edx		关闭游戏程序，若处于关卡内则尝试保存用户存档和关卡存档。删除程序内各个系统和对象。		【虚函数】[[[(LawnApp*)]+0]+A8]
44F380	LawnApp::KillBoard(edi = LawnApp* this)	eax, ecx, edx		删除游戏关卡，包括清空关卡界面和清除选卡场景。
44F400	LawnApp::CheckForUpdates()	此函数不改变任何寄存器		【废弃函数】此函数现被广泛用于充当无参数或由调用者清栈的空白函数。
44F410	LawnApp::CanPauseNow(ecx = LawnApp* this)	al = 0(不能) | 1(能); ecx, edx		判断游戏当前能否暂停。
44F460	LawnApp::LostFocus(ecx = LawnApp* this)	eax, ecx, edx		程序窗口失去焦点时，若禁用作弊按键且可以暂停，则创建暂停对话以暂停游戏。		【虚函数】[[[(LawnApp*)]+0]+14C]
44F480	LawnApp::WriteToRegistry(ecx = LawnApp* this)	eax, ecx, edx		若当前用户存档存在，则将当前用户的用户名写入注册表“CurUser”项并保存一次用户存档。		【虚函数】[[[(LawnApp*)]+0]+5C]
44F530	LawnApp::ReadFromRegistry(ecx = LawnApp* this)	eax, ecx, edx		函数直接跳转至 [5D1D90]SexyApp::ReadFromRegistry()。		【虚函数】[[[(LawnApp*)]+0]+60]
44F540	LawnApp::WriteCurrentUserConfig(eax = LawnApp* this)	al = 1; ecx, edx		若当前玩家存档可用，则立即保存一次存档。
44F560	LawnApp::PreNewGame(bool theLookForSavedGame, GameMode theGameMode, esi = LawnApp* this)	eax, ecx, edx		进入关卡的预备阶段，处理游戏的开始阶段和旧有游戏进度的读取相关。;若 theLookForSavedGame = 1 则尝试读档，读档失败或其值为 0 时会删除此关卡旧有存档并开始新游戏。
44F5F0	LawnApp::MakeNewBoard(ecx = LawnApp* this)	eax, ecx, edx		初始化创建新关卡界面。
44F6B0	LawnApp::StartPlaying(esi = LawnApp* this)	eax, ecx, edx		移除选卡界面并开始关卡。
44F700	LawnApp::SaveFileExists(esi = LawnApp* this)	al = 0(不存在) | 1(存在); ecx, edx		判断当前用户存档是否存在冒险模式关卡的存档文件。
44F7A0	LawnApp::TryLoadGame(LawnApp* this)	al = bool 是否成功; ecx, edx		停止所有音乐，尝试读取当前关卡的存档，若读取成功则在关卡界面内显示继续游戏的对话。
44F890	LawnApp::NewGame(eax = LawnApp* this)	eax, ecx, edx		进入新关卡，创建关卡界面并初始化关卡，显示选卡界面，开始关卡引入的过场。
44F8E0	LawnApp::ShowGameSelector(ecx = LawnApp* this)	eax, ecx, edx		移除关卡界面及原有主菜单界面（若有），然后创建并显示主菜单界面。
44F9E0	LawnApp::KillGameSelector(esi = LawnApp* this)	eax, ecx, edx		移除主菜单界面。
44FA20	LawnApp::ShowAwardScreen(AwardType theAwardType, esi = LawnApp* this)	eax, ecx, edx		创建并显示奖励·便签界面。
44FAF0	LawnApp::KillAwardScreen(esi = LawnApp* this)	eax, ecx, edx		移除奖励·便签界面。
44FB30	LawnApp::ShowCreditScreen(esi = LawnApp* this)	eax, ecx, edx		创建并显示 MV 界面。
44FBF0	LawnApp::KillCreditScreen(esi = LawnApp* this)	eax, ecx, edx		移除 MV 界面。
44FC30	LawnApp::ShowChallengeScreen(ChallengePage thePage, esi = LawnApp* this)	eax, ecx, edx		创建小游戏界面，并将页码调整至第 thePage 页。页码大于 3 的页为空白页。
44FD00	LawnApp::KillChallengeScreen(esi = LawnApp* this)	eax, ecx, edx		删除小游戏界面。
44FD40	LawnApp::ShowStoreScreen(edi = LawnApp* this)	eax = StoreScreen* aStore; ecx, edx		创建并显示戴夫的商店界面。
44FDC0	LawnApp::ShowSeedChooserScreen(esi = LawnApp* this)	eax, ecx, edx		创建并显示选卡界面。
44FE70	LawnApp::KillSeedChooserScreen(esi = LawnApp* this)	eax, ecx, edx		移除选卡界面。
44FEB0	LawnApp::DoBackToMain(eax = LawnApp* this)	eax, edx		从游戏关卡内返回主菜单，处理退出关卡时的音乐、存档等事件，并显示主菜单。
44FF00	LawnApp::DoConfirmBackToMain(ecx = LawnApp* this)	eax, ecx, edx		弹出是否确认返回主菜单的对话。
4500D0	LawnApp::DoNewOptions(bool theFromGameSelector, edi = LawnApp* this)	eax, ecx, edx		创建选项菜单对话。关卡内的菜单上显示“主菜单”等 3 个按钮，主界面的菜单上显示“制作者名单”按钮。
450180	LawnApp::DoAlmanacDialog(ebx = ZombieType theZombieType = -1, edi = LawnApp* this)	eax = AlmanacDialog* aAlmanac; ecx, edx		创建图鉴对话。若 theZombieType 不为 -1，则令图鉴显示 theZombieType 僵尸的一页。
450220	LawnApp::DoContinueDialog(ebx = LawnApp* this)	eax, ecx, edx		创建读档后的继续游戏的对话。
4502C0	LawnApp::DoPauseDialog(ecx = LawnApp* this)	eax, ecx, edx		游戏暂停（包括暂停游戏和显示暂停界面）。
4504B0	LawnApp::LawnMessageBox(int theButtonMode, const char* theButton2Name, const char* theButton1Name, ;                                                        const char* theLinesName, const char* theHeaderName, int theDialogId, LawnApp* this)	eax = int aDepressedButtonId; ecx, edx		创建游戏内部弹窗。对于“[X]”格式的字符数组，会自动在 LawnStrings 中获取相应文本。;此函数内部会调用 Dialog::WaitForResult 临时执行更新程序，直到按钮被按下才返回相应的返回值。;返回值表示被按下的按钮的编号，默认情况下，“是”按钮的编号为 0x3E8，“否”按钮的编号为 0x3E9。
450770	LawnApp::DoDialog(int theButtonMode, const std::string& theDialogFooter, const std::string& theDialogLines, ;                  const std::string& theDialogHeader, bool isModal, int theDialogId, ecx = LawnApp* this)	eax = LawnDialog* aDialog; ecx, edx		创建 LawnDialog 对话，其中 theButtonMode = 0(NONE) | 1(YES_NO) | 2(OK_CANCEL) | 3(FOOTER)。;对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。		【虚函数】[[[(LawnApp*)]+0]+120]
450880	LawnApp::DoUserDialog(edi = LawnApp* this)	eax, ecx, edx		创建用户对话。
450930	LawnApp::FinishUserDialog(bool isYes, LawnApp* this)	eax, ecx, edx		结束用户对话时，若选择为“是”（即 isYes 为 1），则切换当前用户存档。
450A10	LawnApp::DoCreateUserDialog(edi = LawnApp* this)	eax, ecx, edx		进行“创建新用户”对话。
450AC0	LawnApp::FinishCreateUserDialog(bool isYes, ecx = LawnApp* this)	eax, ecx, edx		结束“创建新用户”对话，进行存档相关的操作和处理。isYes 表示结束对话时按下的是否为“好”按钮。
450E20	LawnApp::DoConfirmDeleteUserDialog(ecx = const std::string& theName, edi = LawnApp* this)	eax, ecx, edx		进行确认删除用户对话，其中 name 为即将被删除的用户的用户名。
450F40	LawnApp::FinishConfirmDeleteUserDialog(bool isYes, ecx = LawnApp* this)	eax, ecx, edx		结束确认删除用户对话，若选择为“是”（即 isYes 为 1），则删除用户对话中选择的用户存档。
451180	LawnApp::DoRenameUserDialog(string& name, edi = LawnApp* this)	eax, ecx, edx		进行重命名用户对话。
451260	LawnApp::FinishRenameUserDialog(bool isYes, ecx = LawnApp* this)	eax, ecx, edx		结束重命名用户对话，若选择为“是”（即 isYes 为 1），则尝试重命名用户对话中选择的用户存档。
451490	LawnApp::FinishNameError(edi = int theId, esi = LawnApp* this)	eax, ecx, edx		结束 dialogID 编号的用户名错误对话。
4514D0	LawnApp::FinishRestartConfirmDialog(ecx = LawnApp* this)	eax, ecx, edx		结束确认重新开始关卡对话。
451580	LawnApp::NewDialog(int theButtonMode, const std::string& theDialogFooter, const std::string& theDialogLines, ;                   const std::string& theDialogHeader, bool isModal, int theDialogId, ecx = LawnApp* this)	eax = LawnDialog* aDialog; ecx, edx		创建 LawnDialog 对话，并将对话的位置设置在屏幕正中间。		【虚函数】[[[(LawnApp*)]+0]+64]
451630	LawnApp::KillNewOptionsDialog(eax = LawnApp* this)	al = bool found; ecx, edx		删除选项对话，返回表示是否找到并成功删除编号为 2 的对话（即选项对话）的逻辑值。
4516C0	LawnApp::KillAlmanacDialog(eax = LawnApp* this)	al = bool found; ecx, edx		删除图鉴对话，返回表示是否找到并成功删除编号为 3 的对话（即图鉴对话）的逻辑值。
4516F0	LawnApp::NeedPauseGame(esi = LawnApp* this)	al = 0(否) | 1(是); ecx, edx		判断当前是否需要暂停。当当前不存在对话，或仅存在 1 个选卡警告或购买卡槽或模仿者对话，;或当前位于禅境花园或智慧树时，返回“否”。否则，返回“是”。
451780	LawnApp::ModalOpen(ecx = LawnApp* this)	eax, ecx, edx		当开始一个模态对话时，如果当前位于关卡内且需要暂停，则暂停游戏。		【虚函数】[[[(LawnApp*)]+0]+140]
451800	LawnApp::KillDialog(int theDialogId, ecx = LawnApp* this)	al = bool found; ecx, edx		删除 dialogID 的对话及其窗口，同时根据当前各游戏场景界面的存在情况令相应窗口获得焦点。;返回表示是否找到并成功删除编号为 theDialogId 的对话的逻辑值。		【虚函数】[[[(LawnApp*)]+0]+134]
451870	LawnApp::ShowResourceError(bool doExit, ecx = LawnApp* this)	eax, ecx, edx		函数直接跳转至 [5527B0]SexyAppBase::ShowResourceError()。		【虚函数】[[[(LawnApp*)]+0]+1AC]
451880	LawnApp::Init(ecx = LawnApp* this)	eax, ecx, edx		游戏初始化，包括读取设定数据及存档、加载资源、创建标题界面及初始化游戏内的各个系统等。		【虚函数】[[[(LawnApp*)]+0]+C4]
4522A0	LawnApp::ChangeDirHook(const char* theIntendedPath, ecx = LawnApp* this)	al = 0		即将改变工作目录时的 hook，返回值表示是否确认执行改变工作目录。函数直接返回“否”。		【虚函数】[[[(LawnApp*)]+0]+D0]
4522B0	LawnApp::Start(ecx = LawnApp* this)	eax, ecx, edx		若资源加载失败，则退出，否则开始游戏进程。		【虚函数】[[[(LawnApp*)]+0]+C0]
4522C0	LawnApp::DebugKeyDown(int theKey, ecx = LawnApp* this)	al = bool 是否为有效的调试按键; ecx, edx		游戏程序中按下调试按键。		【虚函数】[[[(LawnApp*)]+0]+154]
4522E0	LawnApp::HandleCmdLineParam;(const std::string& theParamValue, const std::string& theParamName, ecx = LawnApp* this)	eax, ecx, edx		处理一个命令行指令。内测版中判断 “-tod” 指令以开启作弊按键。		【虚函数】[[[(LawnApp*)]+0]+B4]
452310	LawnApp::UpdatePlayerProfileForFinishingLevel(eax = LawnApp* this)	al = bool 是否为首通当前关卡且有解锁新关卡; ;ecx, edx		当关卡完成后，更新存档中的关卡完成及解锁等相关数据，并立即保存一次存档。
4524F0	LawnApp::CheckForGameEnd(eax = LawnApp* this)	eax, ecx, edx		检测关卡结束并进行关卡结束后的相关处理。
452650	LawnApp::UpdateFrames(ecx = LawnApp* this)	eax, ecx, edx		游戏程序对游戏内容进行一轮的更新，会根据快速模式和慢速模式的开启与否决定一轮的更新次数。		【虚函数】[[[(LawnApp*)]+0]+20]
452740	LawnApp::LoadGroup(int theGroupAveMsToLoad, const char* theGroupName, ecx = LawnApp* this)	eax, ecx, edx		加载一组资源并更新加载线程任务量。其中 theGroupAveMsToLoad 表示该组资源的平均任务量。
4528E0	LawnApp::LoadingThreadProc(ecx = LawnApp* this)	eax, ecx, edx		游戏资源加载线程的主处理函数。加载游戏需要的资源（贴图、字体等）和定义数据（粒子系统定义等）。
452C60	LawnApp::FastLoad(GameMode theGameMode, eax = LawnApp* this)	eax, ecx, edx		若未退出程序，则立即移除标题界面并开始 theGameMode 关卡的新游戏。
452CB0	LawnApp::LoadingCompleted(ecx = LawnApp* this)	eax, ecx, edx		加载完成时，移除标题界面，删除标题界面图片并显示主菜单。
452D80	LawnApp::URLOpenFailed(const std::string& theURL, ecx = LawnApp* this)	eax, ecx, edx		打开 theURL 网页失败，将 theURL 网址拷贝至剪贴板，并弹出失败弹窗。		【虚函数】[[[(LawnApp*)]+0]+8C]
452EE0	LawnApp::URLOpenSucceeded(const std::string& theURL, ecx = LawnApp* this)	eax, ecx, edx		打开 theURL 网页成功，删除正在打开浏览器的弹窗。		【虚函数】[[[(LawnApp*)]+0]+90]
452F00	LawnApp::OpenURL(bool shutdownOnOpen, const std::string& theURL, ecx = LawnApp* this)	al = bool 是否成功打开指定网页; ecx, edx		弹出正在打开浏览器的弹窗，并尝试在浏览器中打开 theURL 网页。		【虚函数】[[[(LawnApp*)]+0]+94]
453040	LawnApp::ConfirmQuit(ecx = LawnApp* this)	eax, ecx, edx		弹出是否确认退出游戏的弹窗。
4531D0	LawnApp::PreDisplayHook(ecx = LawnApp* this)	eax, ecx, edx		程序初始化结束、切换全屏模式并显示窗口之前的钩子。函数直接跳转至 [5D4FD0]SexyApp::PreDisplayHook()。		【虚函数】[[[(LawnApp*)]+0]+68]
4531E0	LawnApp::ButtonDepress(int theId, ecx = LawnApp* this)	eax, ecx, edx		游戏中按下编号为 theId 的按钮。记 N = theId Mod 10000，则若：;(1)N < 2000 或 N ≥ 4000：直接返回;(2)2000 ≤ N < 3000：完成或销毁 N - 2000 编号的对话，对于部分对话，执行其“是”选项的事件;(3)3000 ≤ N < 4000：完成或销毁 N - 3000 编号的对话，对于部分对话，执行其“否”选项的事件。
453630	LawnApp::PlayFoley(esi = FoleyType theFoleyType, eax = LawnApp* this)	eax, ecx, edx		判断当前是否需要为特殊过场静默音效，若不静默则调用515240的函数播放 theFoleyType 音效。
453650	LawnApp::PlayFoleyPitch(float thePitch, eax = FoleyType theFoleyType, ecx = LawnApp* this)	eax, ecx, edx		判断当前是否需要为特殊过场静默音效，若不静默则调用515020的函数以指定音高播放 theFoleyType 音效。
453670	LawnApp::GetStageString(eax = _Out_ std::string&& aStageStr, ecx = int theLevel)	eax = std::string&& aStageStr; ecx, edx		取得冒险模式第 theLevel 关的关卡序列字符串（“%d-%d”格式的字符串）。
4536D0	LawnApp::IsSurvivalMode(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为生存模式关卡。
4536F0	LawnApp::IsPuzzleMode(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为解谜模式关卡。
453710	LawnApp::IsChallengeMode(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为小游戏模式关卡。
453740	LawnApp::IsContinousChallenge(ecx = LawnApp* this)	al = 0(否) | 1(是); ecx, edx		判断关卡是否为无尽波数的关卡（包括需要达到特定条件才能过关的关卡以及僵王博士关卡）。
4537B0	LawnApp::IsSquirrelLevel(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为松鼠关卡。
4537D0	LawnApp::IsIZombieLevel(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为 IZombie（我是僵尸） 系列关卡。
453820	LawnApp::IsShovelLevel(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为“你能把它挖出来吗”关卡。
453840	LawnApp::IsWallnutBowlingLevel(ecx = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为坚果保龄球相关关卡（冒险模式 1-5 关卡及两个坚果保龄球小游戏）。
453870	LawnApp::IsSlotMachineLevel(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为老虎机关卡。
453890	LawnApp::IsWhackAZombieLevel(ecx = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为锤僵尸相关关卡（冒险模式 2-5 关卡及小游戏锤僵尸）。
4538C0	LawnApp::IsLittleTroubleLevel(ecx = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为小僵尸关卡（冒险模式 3-5 关卡及小游戏小僵尸大麻烦）。
4538F0	LawnApp::IsVaseBreakerLevel(ecx = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为破罐者系列关卡。
453920	LawnApp::IsStormyNightLevel(ecx = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为暴风雨相关关卡（冒险模式 4-10 关卡及小游戏黑暗的暴风雨夜）。
453950	LawnApp::IsBungeeBlitzLevel(ecx = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为蹦极闪电战相关关卡（冒险模式 5-5 关卡及小游戏蹦极闪电战）。
453980	LawnApp::IsMiniBossLevel(ecx = LawnApp* this)	al = 0(否) | 1(是); edx		判断当前关卡是否为冒险模式 1-10 或 2-10 或 3-10 关卡。
4539D0	LawnApp::IsZombossLevel(ecx = LawnApp* this)	al = 0(否) | 1(是)		判断当前关卡是否为僵王博士相关关卡（冒险模式 5-10 关卡及小游戏僵王博士的复仇）。
453A00	LawnApp::IsChallengeWithoutSeedBank(ecx = LawnApp* this)	al = 0(否) | 1(是); ecx, edx		判断当前关卡是否在开始时无卡槽。
453A50	LawnApp::UpdateApp(ecx = LawnApp* this)	al = bool updated; ecx, edx		游戏程序的更新。若检测到关闭游戏的请求，则关闭游戏，否则进行程序的更新。		【虚函数】[[[(LawnApp*)]+0]+180]
453A70	LawnApp::CloseRequestAsync(ecx = LawnApp* this)	eax, ecx, edx		游戏关闭请求异步时，清除延期消息，获得关闭请求。		【虚函数】[[[(LawnApp*)]+0]+15C]
453A90	LawnApp::GetAwardSeedForLevel(eax = int theLevel)	eax = SeedType anAwardSeed; ecx, edx		获取冒险模式 theLevel 关卡过关的奖励植物类型。
453AC0	LawnApp::GetSeedsAvailabe(eax = LawnApp* this)	eax = int aSeedsNum; ecx		根据玩家当前存档的冒险模式关卡进度，取得当前已解锁的植物类型数量。
453B20	LawnApp::HasSeedType(ebx = SeedType theSeedType, edi = LawnApp* this)	al = bool hasSeedType; ecx, edx		判断玩家是否已获得 theSeedType 植物。
453C30	LawnApp::AddReanimation;(ebx = ReanimationType theReanimationType, int theRenderOrder, float theY, float theX, eax = LawnApp* this)	eax = Reanimation* aReanim; ecx, edx		在 theRenderOrder 图层的 (theX, theY) 处创建 theReanimationType 动画。
453C80	LawnApp::AddTodParticle;(eax = ParticleEffect theEffect, ecx = int theRenderOrder, float theY, float theX, edx = LawnApp* this)	eax = TodParticleSystem* aParticle; ;ecx, edx		在 theRenderOrder 图层的 (theX, theY) 处创建 theEffect 粒子系统。;此函数内部获取了 mEffectSystem->mParticleHolder，函数的实质即为518A70的函数。
453CB0	LawnApp::ReanimationTryToGet(ecx = ReanimationID theReanimationID, eax = LawnApp* this)	eax = Reanimation*? aReanim; edx		根据动画编号 theReanimationID 取得对应的动画对象指针。
453CF0	LawnApp::RemoveReanimation(edx = ReanimationID theReanimationID, eax = LawnApp* this)	eax, ecx, edx		移除动画。此函数内部根据 theReanimationID 获取动画并确保动画存在后跳转至4733F0的函数。
453D20	LawnApp::AdvanceCrazyDaveText(ebx = LawnApp* this)	al = bool 是否存在下一句话; ecx, edx		尝试开始戴夫的下一句话，若存在下一句话则设置戴夫的话文本。
453DC0	LawnApp::GetCrazyDaveText(int theMessageIndex, _Out_ std::string&& aMessage, ecx = LawnApp* this)	eax = std::string&& aMessage; ecx, edx		根据指定的编号，在 LawnStrings 中获取相应的戴夫的话，并替换其中的“{PLAYER_NAME}”等变量。
454070	LawnApp::CanShowAlmanac(eax = LawnApp* this)	al = 0(否) | 1(是)		判断玩家是否已获得图鉴，即：判断是否到达或通过冒险模式 2-5 关卡。
454090	LawnApp::CanShowStore(eax = LawnApp* this)	al = 0(否) | 1(是)		判断玩家是否已解锁戴夫的商店。
4540C0	LawnApp::CanShowZenGarden(eax = LawnApp* this)	al = 0(否) | 1(是); ecx, edx		判断玩家是否已解锁禅境花园模式。
454120	LawnApp::HasBeatenChallenge(eax = GameMode theGameMode, ecx = LawnApp* this)	al = 0(否) | 1(是); ecx, edx		判断玩家是否已完成过 theGameMode 的小游戏关卡。
454170	LawnApp::HasFinishedAdventure(eax = LawnApp* this)	al = 0(否) | 1(是)		判断玩家是否已完成至少一个周目的冒险模式。
454190	LawnApp::IsFirstTimeAdventureMode(eax = LawnApp* this)	al = 0(否) | 1(是)		判断当前是否为一周目的冒险模式关卡。
4541B0	LawnApp::CrazyDaveEnter(ebx = LawnApp* this)	eax, ecx, edx		创建戴夫出场。注意：并非任何关卡任何时间创建的戴夫都能正常更新，详细可参考455040的函数。
4542F0	LawnApp::CrazyDaveDie(edi = LawnApp* this)	eax, ecx, edx		戴夫离场，移除戴夫的动画、字符串和音效。
454350	LawnApp::CrazyDaveLeave(edi = LawnApp* this)	eax, ecx, edx		令戴夫开始离场。
454430	LawnApp::CrazyDaveTalkIndex(int theMessageIndex, esi = LawnApp* this)	eax, ecx, edx		令戴夫进行 theMessageIndex 编号的对话。
4544A0	LawnApp::CrazyDaveDoneHanding(ecx = LawnApp* this)	eax, ecx, edx		戴夫结束手持动作，删除手持轨道上的附件。
454520	LawnApp::CrazyDaveStopSound(esi = LawnApp* this)	eax, ecx, edx		移除所有戴夫说话的相关音效。
454570	LawnApp::CrazyDaveTalkMessage(const std::string& theMessage, LawnApp* this)	eax, ecx, edx		播放戴夫说话动作，设置戴夫的话的内容。
454ED0	LawnApp::CrazyDaveStopTalking(LawnApp* this)	eax, ecx, edx		戴夫停止说话，清除其手持的附件，恢复戴夫动画动作，并停止戴夫对话的音效。
455040	LawnApp::UpdateCrazyDave(eax = LawnApp* this)	eax, edx		仅在部分特定情况下调用，用于更新戴夫。对于游戏开始时出现的戴夫的更新，可参考CutScene::Update();对于关卡内出现的戴夫，可参考Board::Update()对于其他情况的戴夫，可参考相应的Update函数。
4552F0	LawnApp::DrawCrazyDave(Graphics* g, ecx = LawnApp* this)	eax, ecx, edx		绘制戴夫。
455670	LawnApp::GetNumPreloadingTasks(eax = LawnApp* this)	eax = int aNumTasks; ecx, edx		取得需要预加载的植物和僵尸的资源的总任务量。
455720	LawnApp::PreloadForUser(eax = LawnApp* this)	eax, ecx, edx		加载当前存档的用户已拥有的植物植物、已遇到过的僵尸和可能用到的 UI 等的动画资源。
455930	LawnApp::EnforceCursor(ecx = LawnApp* this)	eax, ecx, edx		根据当前光标样式的值，加载相应的光标资源并强制修改光标的形状。		【虚函数】[[[(LawnApp*)]+0]+30]
455AA0	LawnApp::Pluralize;(ecx = const char* thePlural, edi = const char* theSingular, int theCount, _Out_ std::string&& aStr)	eax = std::string&& aStr; ecx, edx		将文本字符串中的首个 {COUNT} 子字符串以 theCount 转化的字符串替换，返回替换后的新字符串。;当 theCount 为 1 时，文本使用单数形式的 theSingular 字符串，否则使用复数形式的 thePlural 字符串。
455BA0	LawnApp::GetNumTrophies(ChallengePage thePage, ebx = LawnApp* this)	eax = int aNumTrophies; ecx, edx		获取在第 thePage 页的小游戏中已赢得的奖杯数量。
455C20	LawnApp::TrophiesNeedForGoldSunflower(eax = LawnApp* this)	eax = int aNumNeed; ecx, edx		取得当前距离获得金向日葵奖杯还需要获得的奖杯数量，即：48 - 当前在三种模式中已获得的奖杯数之和。
455C50	LawnApp::EarnedGoldTrophy(eax = LawnApp* this)	al = bool earned; ecx, edx		判断玩家当前是否已获得金向日葵奖杯。
455C90	LawnApp::IsTrialStageLocked(edi = LawnApp* this)	al = 0(否) | 1(是)		判断游戏当前是否为试玩版或试玩调试的关卡锁定模式。
455CC0	LawnApp::InitHook(ecx = LawnApp* this)	eax, ecx, edx		创建版权系统并获取当前游戏的试玩模式。		【虚函数】[[[(LawnApp*)]+0]+4C]
455E10	LawnApp::GetMoneyString(ecx = _Out_ std::string&& aMoneyStr, eax = int theAmount)	eax = std::string&& aMoneyStr; ecx, edx		将金钱数量 theAmount 转化为金钱栏显示格式的字符串（包含“$”符号，每 3 位数字以“,”分隔）。
455EE0	LawnGetCurrentLevelName(_Out_ std::string&& aLevelName)	eax = std::string&& aLevelName; ecx, edx	0x4	取得当前游戏关卡、场景或阶段的名称。
456060	LawnApp::CanDoPinataMode(eax = LawnApp* this)	al = 0(不能) | 1(能)		判断玩家能否开启 [PINATA] 模式。该模式仅在智慧树高度达到 1000 英尺后解锁。
456080	LawnApp::CanDoDanceMode(eax = LawnApp* this)	al = 0(不能) | 1(能)		判断玩家能否开启 [DANCE] 模式。该模式仅在智慧树高度达到 500 英尺后解锁。
4560A0	LawnApp::CanDoDaisyMode(eax = LawnApp* this)	al = 0(不能) | 1(能)		判断玩家能否开启 [DAISIES] 模式。该模式仅在智慧树高度达到 100 英尺后解锁。
4560C0	LawnApp::PlaySample(int theSoundNum, ecx = LawnApp* this)	eax, ecx, edx		判断当前是否需要为特殊过场静默音效，若不静默则自动跳转至 554C20 播放 theSoundNum 上位音效。		【虚函数】[[[(LawnApp*)]+0]+D8]
4560E0	LawnApp::SwitchScreenMode(bool force, bool is3d, bool wantWindowed, ecx = LawnApp* this)	eax, ecx, edx		切换当前游戏的窗口化和 3D 加速与否。若存在选项对话，则同步调整对话中全屏勾选框的勾选与否。		【虚函数】[[[(LawnApp*)]+0]+110]
456130	std::string::clear(esi = std::string* this)	eax, ecx, edx		将字符串变为空字符串。并不会完全清空字符串的内容，仅将其首个字符置为 '\0'。
4561A0	std::list<std::string>::push_back(eax = const std::string& _Val, ebx = std::list<std::string>* this)	eax, edx		在字符串的链表容器的尾部添加一个字符串元素。
4561D0	std::string::erase(std::string::const_iterator _Last, std::string::const_iterator _First, ;                   _Out_ std::string::iterator&& _Ret, eax = std::string* this)	eax = &&_Ret; ecx, edx		清除字符串从 _First 至 _Last 之间的所有字符，并返回表示清除后下一个字符所在位置的迭代器。
456280	std::list<ButtonWidget*>::_Buynode()	eax = std::_List_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个按钮控件指针的链表容器的节点，并初始化该节点的前、后节点指针指向其自身。
4562A0	std::list<Image*>::clear(esi = std::list<Image*>* this)	eax, ecx, edx		清除贴图指针链表中的所有节点并释放这些节点占用的内存空间。
4562E0	std::list<std::string>::_Buynode;(const std::string& _Val, std::_List_nod<std::string>::_Node* _Prev, std::_List_nod<std::string>::_Node* _Next)	eax = std::_List_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符串的链表容器的节点，并令该节点的前、后节点指针分别指向 _Prev 和 _Next，;同时赋值该节点处的字符串值为 _Val。当创建失败时，释放申请的节点并抛出错误。
456370	std::list<std::string>::_Incsize(ecx = std::list<std::string>* this)	eax, ecx, edx		字符串的链表容器增加 1 个节点后，检查链表长度是否超出上限，若超出则抛出错误，否则将链表大小记录值加 1。
456400	std::operator==<char>(esi = const char* _Right, ecx = const std::string& _Left)	al = bool _Equal; ecx, edx		比较两个字符串 _Left 和 _Right 是否相等。
456430	std::_Allocate<std::_List_nod<ButtonWidget*>::_Node>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个按钮控件指针的链表容器的节点所需要的内存空间，单个节点占用的内存大小为 0xC。;当 _Count 个节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
456480	std::_Construct<std::string>(const std::string& _Val, ecx = std::string* _Ptr)	eax, ecx, edx	0x4	在 _Ptr 指向的地址构造一个值为 _Val 的字符串。
4564E0	std::_Allocate<std::_List_nod<std::string>::_Node>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符串的链表容器的节点所需要的内存空间，单个节点占用的内存大小为 0x24。;当 _Count 个链表容器的节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
456530	TodList<ReanimCacheImageVariation>::RemoveAll(esi = TodList<ReanimCacheImageVariation>* this)	eax, ecx, edx		依次移除动画缓存贴图样式链表的每一节点并由 mpAllocator 回收该节点占用的内存区域。
4565A0	std::string::compare;(unsigned int _Count, const char* _Ptr, unsigned int _N0, unsigned int _Off, ecx = std::string* this)	eax = -1(<) | 0(=) | 1(>); ecx, edx		将字符串从 _Off 开始 _N0 长度的部分、与字符数组的前 _Count 部分进行比较。;实际参与比较部分的长度为 _Count、_N0 和 *this 截取部分有效长度三者的最小值。
456610	std::_String_const_iterator<char>::_String_const_iterator<char>;(const std::_Container_base* _Pstring, const char* _Ptr, ecx = std::_String_const_iterator<char>* this)	eax = *this; ecx, edx		初始化创建字符串的常量迭代器。其中 _Ptr 指向字符串内的字符，表示该迭代器指示的位置。;需要一个大小为 0x8 的内存区域用于构造 this。
456670	std::string::begin(_Out_ std::string::iterator&& _It, ecx = std::string* this)	eax = &&_It; ecx, edx		取得表示字符串起始位置的迭代器。
4566B0	std::string::end(_Out_ std::string::iterator&& _It, ecx = std::string* this)	eax = &&_It; ecx, edx		取得表示字符串终止位置的迭代器。
4566E0	Sexy::EditWidget::MouseDown(int theClickCount, int y, int x, ecx = EditWidget* this)	eax, ecx, edx		输入框中鼠标按下。此函数直接跳转至 Sexy::Widget::MouseDown。		【虚函数】[[[(EditWidget*)]+0]+D8]
4566F0	Sexy::EditListener::EditWidgetText(const std::string& theString, int theId, ecx = EditListener* this)	此函数不改变任何寄存器		默认的输入框监听器监听到输入框中输入了字符串。此函数现被广泛用于充当双参数的空白虚函数。		【虚函数】[[[(EdieListener*)]+0]+0]
456700	LawnEditWidget::`scalar deleting destructor'(unsigned int flags, ecx = LawnEditWidget* this)	eax = *this; ecx, edx		删除 LawnEditWidget 输入框，当 flags 的第 0 位置 1 时会额外释放输入框本身占用的内存空间。		【虚函数】[[[(LawnEditWidget*)]+0]+0]
456720	LawnEditWidget::KeyDown(KeyCode theKey, ecx = LawnEditWidget* this)	eax, ecx, edx		输入框中键盘按下，当按下 Esc 键时额外触发其所处对话的键盘按下事件（一般是结束对话）。		【虚函数】[[[(LawnEditWidget*)]+0]+C0]
456760	LawnEditWidget::KeyChar(char theChar, ecx = LawnEditWidget* this)	eax, ecx, edx		输入框中输入 theChar 字符，若需要自动首字母大写且输入的是字母，则将其改为大写并取消自动首字母大写。		【虚函数】[[[(LawnEditWidget*)]+0]+BC]
4567B0	CreateEditWidget(Dialog* theDialog, EditListener* theListener)	eax = LawnEditWidget* aEdit; ecx, edx	0x8	在指定的对话中创建 LawnEditWidget 输入框（输入框的编号默认为 0）。
456860	MakeNewCheckbox(bool theDefault, CheckboxListener* theListener, int theId)	eax = Checkbox* aCheckbox; ecx, edx	0xC	创建 Checkbox 勾选框控件。其中 theDefault = 0(默认不勾选) | 1(默认勾选)。
4568D0	GetSavedGameName(ecx = int theProfileId, GameMode theGameMode, _Out_ std::string&& aFileName)	eax = std::string&& aFileName; ecx, edx	0x8	获取 theProfileId 编号用户存档 theGameMode 关卡存档的文件名字符串。文件名可用于调用存、读档等函数。
456980	GetCurrentDaysSince2000()	eax = int aDays; ecx, edx		根据本地时间计算当前日期距离 2000 年 1 月 1 日的天数。
456A00	Sexy::Rect::Intersection(eax = _Out_ Rect&& aRect, ecx = const Rect& theTRect, edi = Rect* this)	eax = Rect&& aRect; ecx, edx		取得由两个矩形重叠部分构成的新的矩形。若给出的两个矩形无重叠，则返回矩形 (0, 0, 0, 0)。
456A80	LawnDialog::LawnDialog(int theButtonMode, const std::string& theDialogFooter, ;                       const std::string& theDialogLines, ecx = const std::string& theDialogHeader, ;                       bool isModal, int theId, LawnApp* theApp, LawnDialog* this)	eax = *this; ecx, edx		初始化创建 LawnDialog 对话及窗口。需要一个大小为 0x16C 的内存区域用于构造 this。;会根据 theButtonMode 在对话窗口下方创建 0～2 个按钮，存储在 [*this+160] 和 [*this+164] 中。;theId 表示对话的编号即类型，其取值范围为 [0, 1000)，且 0 至 50 编号的对话原版均已用作特殊用途。
456E80	LawnDialog::`scalar deleting destructor'(unsigned int flags, ecx = LawnDialog* this)	eax = *this; ecx, edx		删除 LawnDialog 对话，当 flags 的第 0 位置 1 时会额外释放对话本身占用的内存空间。		【虚函数】[[[(LawnDialog*)]+0]+0]
456EA0	LawnDialog::~LawnDialog(ecx = LawnDialog* this)	eax, ecx, edx		销毁 LawnDialog 对话，删除 ReanimationWidget 及“是”和“否”按钮。
456F30	LawnDialog::CalcSize(int theExtraY, int theExtraX, esi = LawnDialog* this)	eax, ecx, edx		给定对话框的额外宽度和额外高度，计算满足条件的宽度和高度的最小值，并以此重设对话框的大小。;宽高的最小值要求：至少能容纳所有文本、控件和对话框的贴图，超出部分向上取至中部贴图尺寸的整数倍。
457160	LawnDialog::AddedToManager(WidgetManager* theWidgetManager, ecx = LawnDialog* this)	eax, ecx, edx		将 LawnDialog 对话加入控件管理器，并将其动画控件及“是”“否”按钮（若有）加入其子控件链表中。		【虚函数】[[[(LawnDialog*)]+0]+50]
4571B0	LawnDialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = LawnDialog* this)	eax, ecx, edx		将 LawnDialog 对话移出控件管理器，并将其动画控件及“是”“否”按钮（若有）移出其子控件链表。;同时销毁并从效果系统的动画数据数组中移除 LawnDialog 的动画控件中的动画。		【虚函数】[[[(LawnDialog*)]+0]+54]
457230	LawnDialog::SetButtonDelay(int theDelay, ecx = LawnDialog* this)	eax, ecx, edx		设置 LawnDialog 内的按钮延时时长，并将“是”“否”按钮（若有）设为禁用。		【虚函数】[[[(LawnDialog*)]+0]+130]
457280	LawnDialog::Update(ecx = LawnDialog* this)	eax, ecx, edx		LawnDialog 对话更新，将自身标记为已变更，若按钮延时为 0 则将“是”“否”按钮（若有）设为可用。		【虚函数】[[[(LawnDialog*)]+0]+58]
4572E0	LawnDialog::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		LawnDialog 中按钮按下时，播放按下按钮的音效。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(LawnDialog*)]+88]+4]
457300	LawnDialog::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		LawnDialog 中松开按下的按钮时，判断按钮延迟并依此决定是否执行按钮被点击的相关判断。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(LawnDialog*)]+88]+8]
457320	LawnDialog::CheckboxChecked(bool theChecked, int theId, ecx = LawnDialog* this)	eax, ecx, edx		LawnDialog 中勾选框被勾选时，播放勾选的音效。		【虚函数】[[[(LawnDialog*)]+0]+134]
457340	LawnDialog::KeyDown(KeyCode theKey, ecx = LawnDialog* this)	eax, ecx, edx		LawnDialog 中键盘按下，暂停界面下执行关卡内的按键检测，除图鉴外的对话中根据按键点击相应的按钮。		【虚函数】[[[(LawnDialog*)]+0]+C0]
4573D0	LawnDialog::Resize(int theHeight, int theWidth, int theY, int theX, ecx = LawnDialog* this)	eax, ecx, edx		设置 LawnDialog 内部各控件及其本身的位置和大小。		【虚函数】[[[(LawnDialog*)]+0]+A0]
4575A0	LawnDialog::Draw(Graphics* g, ecx = LawnDialog* this)	eax, ecx, edx		绘制 LawnDialog 的背景及标题和正文的文本。如果规定了 mDrawStandardBack 为 false 则不绘制。		【虚函数】[[[(LawnDialog*)]+0]+68]
4579A0	ReanimationWidget::ReanimationWidget(esi = ReanimationWidget* this)	eax = *this; edx		初始化创建动画控件。需要一个大小为 0x9C 的内存区域用于构造 this。
4579F0	ReanimationWidget::`scalar deleting destructor'(unsigned int flags, ecx = ReanimationWidget* this)	eax = *this; ecx, edx		删除动画控件，当 flags 的第 0 位置 1 时会额外释放动画控件本身占用的内存空间。		【虚函数】[[[(ReanimationWidget*)]+0]+0]
457A10	ReanimationWidget::~ReanimationWidget(ReanimationWidget* this)	eax, ecx, edx		销毁动画控件，同时销毁并从效果系统的动画数据数组中移除其动画。
457A80	ReanimationWidget::AddReanimation(float x, float y, ReanimationWidget* this)	eax, ecx, edx		在动画控件中的指定位置添加读报僵尸的动画并播放闲置动作（若存在），同时相应地调整控件自身的坐标。
457B80	ReanimationWidget::Draw(Graphics* g, ecx = ReanimationWidget* this)	eax, ecx, edx		若动画控件中存在动画，则绘制该动画。		【虚函数】[[[(ReanimationWidget*)]+0]+68]
457BA0	ReanimationWidget::Update(ecx = ReanimationWidget* this)	eax, ecx, edx		若动画控件中存在动画，则更新该动画，并将控件自身标记为已变更。		【虚函数】[[[(ReanimationWidget*)]+0]+58]
457BC0	GameOverDialog::GameOverDialog;(bool theShowChallengeName, const std::string& theMessage, GameOverDialog* this)	eax = *this; ecx, edx		初始化创建游戏结束对话。其中 theShowChallengeName 指定是否需要在对话标题中显示当前关卡名。;需要一个大小为 0x170 的内存区域用于构造 this。
457E50	GameOverDialog::ButtonDepress(int theId, ecx = GameOverDialog* this)	eax, ecx, edx		游戏结束对话中松开按下的按钮时，判断按下的按钮并执行重新开始或返回主菜单。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(GameOverDialog*)]+88]+8]
457F20	GameOverDialog::AddedToManager(WidgetManager* theWidgetManager, ecx = GameOverDialog* this)	eax, ecx, edx		将游戏结束对话加入控件管理器，并将其主菜单按钮加入其子控件链表中。		【虚函数】[[[(GameOverDialog*)]+0]+50]
457F80	GameOverDialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = GameOverDialog* this)	eax, ecx, edx		将游戏结束对话移出控件管理器，并将其主菜单按钮移出其子控件链表。		【虚函数】[[[(GameOverDialog*)]+0]+54]
457FB0	GameOverDialog::MouseDrag(int y, int x, ecx = GameOverDialog* this)	eax, ecx, edx		游戏结束对话中当鼠标拖动至 (x, y) 位置处时，重置主菜单按钮的位置以保证其在屏幕上的绝对坐标不变。		【虚函数】[[[(GameOverDialog*)]+0]+E8]
458000	LawnMower::LawnMowerInitialize(eax = int theRow, LawnMower* this)	eax, ecx, edx		初始化小推车。后续需要自行设定小推车的坐标。
4581E0	LawnMower::UpdatePool(edi = LawnMower* this)	eax, ecx, edx		对于运动中的水路小推车，判断其出入水的条件并依此更新其高度偏移和运动状态等。
458540	LawnMower::MowZombie(Zombie* theZombie, eax = LawnMower* this)	eax, ecx, edx		小推车碾压僵尸。
4586E0	LawnMower::Update(LawnMower* this)	eax, ecx, edx		小推车的更新函数，更新小推车的索敌、运动和消失等事件，并更新小推车的动画。
458A80	LawnMower::Draw(ecx = Graphics* g, edx = LawnMower* this)	eax, ecx, edx		绘制小推车和其影子。
458D10	LawnMower::Die(eax = LawnMower* this)	eax, ecx, edx		销毁小推车，销毁小推车的动画。当存在剩余额外小推车时，在本行创建一个新的小推车。
458DA0	LawnMower::StartMower(esi = LawnMower* this)	eax, ecx, edx		启动小推车。
458EB0	LawnMower::SquishMower(ecx = LawnMower* this)	eax, ecx, edx		压扁小推车。
458F60	LawnMower::EnableSuperMower(eax = LawnMower* this)	eax, ecx, edx		输入 TRICKEDOUT 指令时，播放小推车装饰后的动画。
458FC0	MessageWidget::ClearReanim(edi = MessageWidget* this)	eax, ecx, edx		清除提示字幕的所有文字的动画。
459010	MessageWidget::SetLabel;(ecx = MessageStyle theMessageStyle, edx = const std::string& theNewLabel, esi = MessageWidget* this)	eax, ecx, edx		设置提示字幕和字幕的持续时间。对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。
4591E0	MessageWidget::LayoutReanimText(MessageWidget* this)	eax, ecx, edx		对于有文字动画的字幕，分别在合适的位置创建每一个字符的入场动画。用于创建红字字幕的动画。;由于红字在动画层面是作为一个整体显示的，故红字字幕的文本长度（即动画数量）固定为 1。
4594B0	MessageWidget::Update(ecx = MessageWidget* this)	eax, ecx, edx		更新字幕的剩余时间和下一轮的切换，同时遍历每个文字的动画（若有）以设置其动画速率并更新其动画。
459710	MessageWidget::DrawReanimatedText;(float thePosY, const Color& theColor, Font* theFont, Graphics* g, MessageWidget* this)	eax, ecx, edx		对于有文字动画的字幕，遍历字幕的每个文字，分别以其动画变换创建矩阵，并绘制在矩阵作用下的文本。
459990	MessageWidget::GetFont(eax = MessageWidget* this)	eax = Font* aFont; ecx		取得字幕样式对应的字体。
4599E0	MessageWidget::Draw(Graphics* g, MessageWidget* this)	eax, ecx, edx		计算合适的位置并以相应的字体绘制字幕的底框矩形、文字描边和文本内容等。
45A090	std::string::basic_string(unsigned int _Count, const char* _Ptr, ecx = std::string* this)	eax = *this; ecx, edx		以字符数组的前 _Count 个字符构造字符串对象。需要一个大小为 0x1C 的内存区域用于构造 this。
45A0C0	GetPakPtr_Music()	eax = PakInterfaceBase*? aPak; ecx, edx		从 Music 的资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
45A130	p_fopen_Music(eax = const char* theFileName)	eax = PFILE*? pFile; ecx, edx		以二进制只读模式读取指定文件，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，失败则返回 0。;优先尝试通过资源包文件接口在 pak 资源包内读取文件，当无法获取接口时尝试直接读取文件。
45A190	p_fclose_Music(esi = PFILE* theFile)	eax = 0(成功) | -1(失败); ecx, edx		尝试通过资源包文件接口关闭文件，当无法获取接口时直接关闭文件流。同时释放 pFile 占用的内存空间。
45A1D0	p_fseek_Music(esi = int theOrigin, edi = PFILE* theFile)	eax = 0(成功) | 非零(失败); ecx, edx		设置资源包数据文件当前读取指针指向的位置。其中 theOrigin 的取值可参考 61D72B 的函数的说明。;优先尝试通过资源包文件接口操作读取指针，当无法获取接口时尝试直接操作文件流的读取指针。
45A200	p_ftell_Music(esi = PFILE* theFile)	eax = int aOffset; ecx, edx		取得资源包数据文件当前读取指针指向的位置距离文件头的偏移量。;优先尝试通过资源包文件接口获取偏移量，当无法获取接口时尝试直接在文件流中获取偏移量。
45A230	p_fread_Music(esi = PFILE* theFile, edi = int theCount, ebx = void* thePtr)	eax = int 实际完整读取的项数; ecx, edx		读取资源包数据文件中 theCount 字节的数据并解密，然后将解密后的数据写入 thePtr 指向的地址;优先尝试通过资源包文件接口读取数据，当无法获取接口时尝试直接从文件流中读取数据。
45A260	Music::Music(eax = Music* this)	eax = *this; ecx, edx		初始化创建音乐系统。需要一个大小为 0x4C 的内存区域用于构造 this。
45A2C0	Music::TodLoadMusic(const std::string& theFileName, MusicFile theMusicFile, Music* this)	al = bool 是否成功; ecx, edx		读取 theFileName 音频文件作为编号为 theMusicFile 的音乐序列。
45A6C0	Music::SetupMusicFileForTune(eax = MusicTune theMusicTune, ecx = MusicFile theMusicFile)	eax, ecx, edx		根据 theMusicTune 音乐在 theMusicFile 文件中的起始和终止位置调整音乐每条轨道的音量属性（静音与否）。
45A8A0	Music::MusicTitleScreenInit(ecx = Music* this)	eax, ecx, edx		加载主音乐（mainmusic.mo3）并确保播放标题界面的背景音乐。
45A980	Music::MusicInit(ecx = Music* this)	eax, ecx, edx		加载主音乐（mainmusic.mo3）及主音乐的踩镲音乐（mainmusic_hihats.mo3）。
45AAC0	Music::MusicCreditScreenInit(edi = Music* this)	eax, ecx, edx		若 MV 音乐尚未加载，则加载 MV 音乐（ZombiesOnYourLawn.ogg）。
45ABB0	Music::StopAllMusic(esi = Music* this)	eax, ecx, edx		停止当前所有背景音乐。
45AC20	Music::GetBassMusicHandle(eax = MusicFile theMusicFile, ecx = Music* this)	eax = HMUSIC aHMusic(存在) | 0(不存在); ;ecx, edx		从音乐接口的音乐数据容器中寻找编号为 theMusicFile 的音乐文件的信息并返回其音乐句柄（若存在）。
45AC70	Music::PlayFromOffset(double theVolume, int theOffset, MusicFile theMusicFile, Music* this)	eax, ecx, edx		从编号为 theMusicFile 的音乐序列中的 theOffset 位置开始，循环播放该位置所在的循环段内的背景音乐;当指定编号的音乐存在音乐流且为 MV 音乐时，改为不循环播放。参数 theVolume 取值范围为 [0, 1]。
45ADB0	Music::PlayMusic(eax = int theDrumsOffset = -1, edx = int theOffset = -1, ;                 ecx = MusicTune theMusicTune, esi = Music* this)	eax, ecx, edx		从指定位置开始播放 theMusicTune 背景音乐，;当 theOffset 为 -1 时，从 theMusicTune 音乐起始位置开始播放。
45B1B0	Music::MusicResyncChannel;(MusicFile theMusicFileToSync, ecx = MusicFile theMusicFileToMatch, eax = Music* this)	eax, ecx, edx		适当加快或减慢 theMusicFileToSync 音乐的播放速率以使其尽量匹配 theMusicFileToMatch 音乐的播放进度。
45B240	Music::StartBurst(eax = Music* this)	此函数不改变任何寄存器		以 400cs 淡入背景音乐的短纯音阶段。
45B260	Music::UpdateMusicBurst(esi = Music* this)	eax, ecx, edx		关卡内更新背景音乐的主音乐、短纯音、踩擦音和鼓点效果的状态变化过程及音量的调整等。
45B670	Music::MusicUpdate(eax = Music* this)	eax, ecx, edx		背景音乐系统的总更新，包括音乐过渡的更新、关卡内特殊音乐效果的更新及音乐之间的同步等。
45B750	Music::MakeSureMusicIsPlaying(edi = MusicTune theMusicTune, eax = Music* this)	eax, ecx, edx		判断当前正在播放的背景音乐是否为 theMusicTune，若不是则停止当前所有背景音乐并播放指定的背景音乐。
45B770	Music::StartGameMusic(eax = Music* this)	eax, ecx, edx		根据当前关卡，播放相应的背景音乐。
45B930	Music::GameMusicPause(bool thePause, edi = Music* this)	eax, ecx, edx		设置游戏音乐的暂停与否。暂停时，记录音乐当前播放的进度取消暂停时，从记录的位置开始继续播放。
45BAA0	std::_Tree<std::_Tmap_traits<<int, BassMusicInfo>>::insert;(const std::pair<int, BassMusicInfo>& _Val, ; _Out_ std::pair<std::_Tree<std::_Tmap_traits<<int, BassMusicInfo>>::iterator, bool>&& _Ret, ; ebx = std::_Tree<std::_Tmap_traits<<int, BassMusicInfo>>* this)	eax = &&_Ret; ecx, edx		向音乐文件编号向音乐信息的映射容器中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
45BB80	std::_Tree<std::_Tmap_traits<<int, BassMusicInfo>>::find;(ebx = int& _Keyval, eax = _Out_ std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::iterator&& _Ret, ; esi = std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>* this)	eax = &&_Ret; ecx, edx		在音乐文件编号向音乐信息的映射容器中寻找 _Keyval 编号的音乐文件对应的音乐信息。;若找到，则返回指示该对组所在位置处的迭代器否则，返回相当于 map.end() 的迭代器。
45BBF0	std::string::rfind(const char* _Ptr, edi = std::string* this)	eax = int aIndex(找到) | -1(未找到); ;ecx, edx		查找 _Ptr 指向的单个字符在字符串中最后一次出现的位置，未找到则返回 -1。
45BC90	std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::_Insert;(const std::pair<int, BassMusicInfo>& _Val, ; ecx = std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>* this)	eax = &&_Ret; ecx, edx		在字符串向存档的映射红黑树中的指定节点下添加一个新的节点，返回表示插入的键值在红黑树中的位置的迭代器。
45BE70	std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::_Lrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>* this)	eax, ecx, edx		对音乐文件编号向音乐信息的映射红黑树的一个节点进行左旋转。
45BEC0	std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::_Rrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>* this)	eax, ecx, edx		对音乐文件编号向音乐信息的映射红黑树的一个节点进行右旋转。
45BF10	std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::_Buynode;(const std::pair<int, BassMusicInfo>& _Val, std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>::_Node* _Larg, ; std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>::_Node* _Parg, ; std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>::_Node* _Rarg)	eax = std::_Tree_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个音乐文件编号向音乐信息的映射容器的节点，令该节点的父节点指针指向 _Parg，;并令该节点的左、右子节点指针分别指向 _Larg 和 _Rarg，同时赋值该节点处的对组值为 _Val。
45BF50	std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::const_iterator::_Dec;(esi = std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::const_iterator* this)	eax, ecx, edx		音乐文件编号向音乐信息的映射容器的迭代器自减。
45BFD0	std::_Tree<std::_Tmap_traits<int, BassMusicInfo>>::_Max;(eax = std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>::_Node* _Pnode)	eax = _Node* _Maxnode; ecx, edx		取得音乐文件编号向音乐信息的映射红黑树从 _Pnode 开始最右侧的一个节点。
45BFF0	std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int, BassMusicInfo>>::_Node>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个音乐文件编号向音乐信息的映射容器的节点所需要的内存空间，单个节点占用的内存大小为 0x48。;当 _Count 个链表容器的节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
45C050	NewOptionsDialog::NewOptionsDialog(bool theFromGameSelector, LawnApp* theApp, NewOptionsDialog* this)	eax = *this; ecx, edx		初始化创建选项对话，需要一个大小为 0x180 的内存区域用于构造 this。
45C760	NewOptionsDialog::`scalar deleting destructor'(unsigned int flags, ecx = NewOptionsDialog* this)	eax = *this; ecx, edx		删除选项对话，当 flags 的第 0 位置 1 时会额外释放对话本身占用的内存空间。		【虚函数】[[[(NewOptionsDialog*)]+0]+0]
45C780	NewOptionsDialog::~NewOptionsDialog(ecx = NewOptionsDialog* this)	eax, ecx, edx		销毁选项对话，删除其中的所有按钮、勾选框和滑动条。
45C880	NewOptionsDialog::GetPreferredHeight(int theWidth, ecx = NewOptionsDialog* this)	eax = int aHeight; ecx, edx		当指定选项对话的宽度时，计算对话的首选高度值。		【虚函数】[[[(NewOptionsDialog*)]+0]+124]
45C890	NewOptionsDialog::AddedToManager(WidgetManager* theWidgetManager, ecx = NewOptionsDialog* this)	eax, ecx, edx		将选项对话加入控件管理器，并将其中的所有按钮、勾选框和滑动条加入其子控件链表中。		【虚函数】[[[(NewOptionsDialog*)]+0]+50]
45C930	NewOptionsDialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = NewOptionsDialog* this)	eax, ecx, edx		将选项对话移出控件管理器，并将其中的所有按钮、勾选框和滑动条移出其子控件链表。		【虚函数】[[[(NewOptionsDialog*)]+0]+54]
45C9D0	NewOptionsDialog::Resize(int theHeight, int theWidth, int theY, int theX, ecx = NewOptionsDialog* this)	eax, ecx, edx		设置选项对话内部各控件及其本身的位置和大小。		【虚函数】[[[(NewOptionsDialog*)]+0]+A0]
45CB50	NewOptionsDialog::Draw(Graphics* g, ecx = NewOptionsDialog* this)	eax, ecx, edx		绘制选项对话的背景及标题和各个选项的文本。		【虚函数】[[[(NewOptionsDialog*)]+0]+68]
45CF50	NewOptionsDialog::SliderVal(double theVal, int id, ecx = SliderListener* this)	eax, ecx, edx		选项对话中滑块条滑动时，根据 id 相应调整游戏音乐或音效的音量。		【虚函数】[[[(SliderListener*)]+0]+0]/[[[(NewOptionsDialog*)]+150]+0]
45CFF0	NewOptionsDialog::CheckboxChecked(bool checked, int theId, ecx = CheckboxListener* this)	eax, ecx, edx		选项对话中勾选框被点击时，判断对应选项能否被设置，若不能则弹出提示弹窗。		【虚函数】[[[(CheckboxListener*)]+0]+0]/[[[(NewOptionsDialog*)]+154]+0]
45D290	NewOptionsDialog::KeyDown(KeyCode theKey, ecx = NewOptionsDialog* this)	eax, ecx, edx		选项对话中键盘按键按下，若在关卡内则进行游戏关卡内的按键检测。;当按下空格或回车键时，视为按下了“是”按钮当按下返回键时，视为按下了“否”按钮。		【虚函数】[[[(NewOptionsDialog*)]+0]+C0]
45D2F0	NewOptionsDialog::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		选项对话中按钮按下时，播放按下按钮的音效。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(NewOptionsDialog*)]+88]+4]
45D310	NewOptionsDialog::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		选项对话中松开按下的按钮时，根据按下的按钮触发相应的事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(NewOptionsDialog*)]+88]+8]
45D610	NewUserDialog::NewUserDialog(bool isRename, LawnApp* theApp, NewUserDialog* this)	eax = *this; ecx, edx		初始化创建新用户对话，需要一个大小为 0x178 的内存区域用于构造 this。
45D7E0	NewUserDialog::`scalar deleting destructor'(unsigned int flags, ecx = NewUserDialog* this)	eax = *this; ecx, edx		删除新用户对话，当 flags 的第 0 位置 1 时会额外释放对话本身占用的内存空间。		【虚函数】[[[(NewUserDialog*)]+0]+0]
45D800	NewUserDialog::~NewUserDialog(ecx = NewUserDialog* this)	eax, ecx, edx		销毁新用户对话，删除其中的用户名输入框。
45D870	NewUserDialog::AddedToManager(WidgetManager* theWidgetManager, ecx = NewUserDialog* this)	eax, ecx, edx		将新用户对话加入控件管理器，并将其用户名输入框加入其子控件链表中。		【虚函数】[[[(NewUserDialog*)]+0]+50]
45D8E0	NewUserDialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = NewUserDialog* this)	eax, ecx, edx		将新用户对话移出控件管理器，并将其用户名输入框移出其子控件链表。		【虚函数】[[[(NewUserDialog*)]+0]+54]
45D910	NewUserDialog::Resize(int theHeight, int theWidth, int theY, int theX, ecx = NewUserDialog* this)	eax, ecx, edx		设置新用户对话内用户名输入框及其本身的位置和大小。		【虚函数】[[[(NewUserDialog*)]+0]+A0]
45D970	NewUserDialog::Draw(Graphics* g, ecx = NewUserDialog* this)	eax, ecx, edx		绘制新用户对话及其用户名输入框。		【虚函数】[[[(NewUserDialog*)]+0]+68]
45D9D0	NewUserDialog::EditWidgetText(const std::string& theString, int theId, ecx = EditListener* this)	eax, ecx, edx		用户名输入框中输入字符串，视为在游戏中按下了 theId + 2000 编号的按钮。		【虚函数】[[[(NewUserDialog*)]+16C]+0]/[[[(EditListener*)]+0]+0]
45D9F0	NewUserDialog::AllowChar(char theChar, int theId, ecx = EditListener* this)	al = 0(不允许) | 1(允许); ecx, edx		判断 theChar 字符是否为用户名输入框中允许的字符。当且仅当字符为字母、数字或空格时返回允许。		【虚函数】[[[(NewUserDialog*)]+16C]+8]/[[[(EditListener*)]+0]+8]
45DA20	NewUserDialog::GetName(_Out_ std::string&& aNameString, NewUserDialog* this)	eax = std::string&& aNameString; ecx, edx		取得“创建新用户”对话中玩家输入的新用户名。
45DB30	std::string::operator[](unsigned int _Off, ecx = std::string* this)	eax = char& _Ch		获取字符串中第 _Off 个字符，返回对该字符的引用。
45DB60	Plant::PlantInitialize;(SeedType theImitaterType, SeedType theSeedType, eax = int theGridY, ecx = int theGridX, Plant* this)	eax, ecx, edx		初始化植物信息和数据。其中，theGirdX 和 theGridY 指定植物所在的列数和行数，;theSeedType 指定植物的类型。当植物为模仿者时，theImitaterType 指定其模仿的植物类型。
45E7C0	Plant::CalcRenderOrder(esi = Plant* this)	eax = int aRenderOrder; ecx, edx		计算植物当前应当位于的图层。
45E860	Plant::SetSleeping(bool theIsAsleep, eax = Plant* this)	eax, ecx, edx		设置植物的睡眠与否，同时据此设置植物的相关动画。
45EB10	Plant::GetDamageRangeFlags(PlantWeapon thePlantWeapon, eax = Plant* this)	eax = int aDamageRangeFlags		取得植物攻击的能力范围。此处，有意义的 thePlantWeapon = 0(一般) | 1(仙人掌发射地面子弹)。
45EBD0	Plant::IsOnHighGround(ecx = Plant* this)	al = 0(否) | 1(是); ecx, edx		判断植物是否位于高地。
45EC00	Plant::SpikeRockTakeDamage(esi = Plant* this)	eax, ecx, edx		地刺王受到碾压型伤害时，减少血量并根据减少后的当前血量更新各个尖刺的显示情况及其自身的消失与否。
45ED00	Plant::DoRowAreaDamage(unsigned int theDamageFlags, Plant* this)	eax, ecx, edx		范围伤害类植物（喷射类、地刺类等）实际攻击僵尸的函数，内部含有不同植物的伤害及特效。;对于喷射类植物，此函数调用来自466E00函数的内部。
45EEA0	Plant::AddAttachedParticle;(ParticleEffect theEffect, int theRenderPosition, int thePosY, int thePosX, edi = Plant* this)	eax = TodParticleSystem* aParticle; ;ecx, edx		销毁植物原有的附属粒子特效，然后在 (thePosX, thePosY) 位置创建 theEffect 粒子特效并绑定至植物。
45EF10	Plant::FindTargetAndFire(PlantWeapon thePlantWeapon, int theRow, eax = Plant* this)	al = bool 是否索敌成功; ecx, edx		一般攻击型植物的索敌与攻击准备函数，若成功索敌则植物会开始攻击动画并进入攻击预备状态。;此处，有意义的 thePlantWeapon = 0(一般) | 1(仙人掌发射地面子弹、裂荚射手攻击后方)。
45F2A0	Plant::LaunchThreepeater(edi = Plant* this)	eax, ecx, edx		三线射手的索敌与攻击准备函数，若成功索敌则植物会开始攻击动画并进入攻击预备状态。
45F470	Plant::FindStarFruitTarget(Plant* this)	al = bool 是否索敌成功; ecx, edx		杨桃的索敌函数。
45F6E0	Plant::LaunchStarFruit(esi = Plant* this)	eax, ecx, edx		杨桃的攻击准备函数。尝试索敌，若成功索敌则植物会开始攻击动画并进入攻击预备状态。
45F720	Plant::StarFruitFire(esi = Plant* this)	eax, ecx, edx		杨桃攻击，分别向五个方向发射星星子弹。
45F8A0	Plant::UpdateShooter(eax = Plant* this)	eax, ecx, edx		所有攻击型植物的攻击判定的总更新，包括攻击倒计时的更新和索敌的判断。
45F980	Plant::MakeSun(eax = Plant* this)	al = 0(否) | 1(是)		判断植物是否为可以生产阳光的植物（向日葵、双子向日葵、阳光菇）。
45F9A0	Plant::UpdateProductionPlant(edi = Plant* this)	eax, ecx, edx		所有生产型植物的生产相关的总更新，包括生产倒计时的更新和物品的生产。
45FB70	Plant::UpdateSunShroom(eax = Plant* this)	eax, ecx, edx		【植物特性函数】阳光菇的特性更新函数。
45FC70	Plant::UpdateGraveBuster(Plant* this)	eax, ecx, edx		【植物特性函数】墓碑吞噬者的特性更新函数。
45FD90	Plant::PlayBodyReanim(float theAnimRate, ecx = int theBlendTime, ReanimLoopType theLoopType, ;                      const char* theTrackName, eax = Plant* this)	eax, ecx, edx		自动获取植物动画对象序列并以 theAnimRate 的速率有补间地播放 theTrackName 轨道上的动画，;其中 theBlendTime 指定补间动画的时长（帧数）。此函数内部获取植物动画后采用了与473BF0相似的过程。
45FE20	Plant::UpdatePotato(eax = Plant* this)	eax, ecx, edx		【植物特性函数】土豆地雷的特性更新函数。
460060	Plant::UpdateTanglekelp(Plant* this)	eax, ecx, edx		【植物特性函数】缠绕海草的特性更新函数。
460320	Plant::SpikeweedAttack(esi = Plant* this)	eax, ecx, edx		地刺和地刺王开始攻击，播放攻击动画和音效。
460370	Plant::UpdateSpikeweed(eax = Plant* this)	eax, ecx, edx		【植物特性函数】地刺和地刺王的特性更新函数。
460420	Plant::UpdateScaredyShroom(Plant* this)	eax, ecx, edx		【植物特性函数】胆小菇的特性更新函数。
460610	Plant::UpdateTorchwood(Plant* this)	eax, ecx, edx		【植物特性函数】火炬树桩的特性更新函数。
4606F0	Plant::DoSquashDamage(Plant* this)	eax, ecx, edx		植物对其攻击范围内的所有其可攻击的僵尸造成一次 1800 点伤害。
4607E0	Plant::FindSquashTarget(Plant* this)	eax = Zombie*? aTargetZombie; ecx, edx		窝瓜的索敌函数。
4609D0	Plant::UpdateSquash(Plant* this)	eax, ecx, edx		【植物特性函数】窝瓜的特性更新函数。
460DD0	Plant::UpdateDoomShroom(eax = Plant* this)	eax, ecx, edx		【植物特性函数】毁灭菇的特性更新函数。
460F00	Plant::UpdateBlover(edi = Plant* this)	eax, ecx, edx		【植物特性函数】三叶草的特性更新函数。
460F60	Plant::UpdateCoffeeBean(ecx = Plant* this)	eax, ecx, edx		【植物特性函数】咖啡豆的特性更新函数。
460FA0	Plant::UpdateUmbrella(eax = Plant* this)	eax, ecx, edx		【植物特性函数】叶子保护伞的特性更新函数。
461020	Plant::UpdateCobCannon(eax = Plant* this)	eax, ecx, edx		【植物特性函数】玉米加农炮的特性更新函数。
4611F0	Plant::UpdateCactus(eax = Plant* this)	eax, ecx, edx		【植物特性函数】仙人掌的特性更新函数。
461320	Plant::UpdateChomper(eax = Plant* this)	eax, ecx, edx		【植物特性函数】大嘴花的特性更新函数。
4615D0	Plant::GetFreeMagnetItem(edx = Plant* this)	eax = MagnetItem*? aMagnetItem; ecx		寻找吸金磁吸收物品数组中的首个空闲物品位置并返回其指针，若不存在空闲位置则返回 0。;对于非吸金磁的植物，返回首个吸收物品指针。
461610	Plant::MagnetShroomAttactItem(ebx = Zombie* theZombie, Plant* this)	eax, ecx, edx		磁力菇从僵尸身上吸收铁制品，赋值吸收的物品的相关数据并处理僵尸失去该物品的相关事件。
461CD0	Plant::DrawMagnetItemsOnTop(ebx = Plant* this)	al = 0(否) | 1(是); ecx, edx		判断磁力菇或吸金磁是否正在吸引物品中。对于磁力菇，要求其吸收的物品与其自身的距离不小于 20。;吸引过程中，被吸引的物体将被绘制在其他游戏物体的较上层否则，物体与植物本身同时绘制。
461D90	Plant::UpdateMagnetShroom(Plant* this)	eax, ecx, edx		【植物特性函数】磁力菇的特性更新函数。
462390	Plant::FindGoldMagnetTarget(edi = Plant* this)	eax = Coin*? aCoin; ecx, edx		获取场上距离植物最近的一个钱币类物品作为吸金磁的目标物品，若场上不存在该类物品则返回 0。
4624B0	Plant::GoldMagnetFindTargets(eax = Plant* this)	eax, ecx, edx		吸金磁寻找并吸引目标物品。
4625D0	Plant::IsAGoldMagnetAboutToSuck(edi = Plant* this)	al = 0(存在) | 1(不存在); edx		判断场上是否存在正处于吸引前摇中的吸金磁。用于确保场上只能同时存在 1 株正在吸引中的吸金磁。
462680	Plant::UpdateGoldMagnetShroom(eax = Plant* this)	eax, ecx, edx		【植物特性函数】吸金磁的特性更新函数。
4629F0	Plant::RemoveEffects(esi = Plant* this)	eax, ecx, edx		植物消失时调用，移除植物的所有动画和粒子系统。
462B80	Plant::Squish(Plant* this)	eax, ecx, edx		压扁植物，处理植物被压扁时的相关事件。
462CE0	Plant::UpdateBowling(edi = Plant* this)	eax, ecx, edx		【植物特性函数】坚果保龄球（坚果、爆炸坚果、巨大坚果）的特性更新函数。
463150	Plant::UpdateAbilities(eax = Plant* this)	eax, ecx, edx		关卡内各植物特性的总更新，对植物调用其特性更新函数，同时更新植物能力相关的各项倒计时及相应事件。
463420	Plant::IsPartOfUpgradableTo(eax = SeedType theUpgradedType, esi = Plant* this)	al = 0(否) | 1(是); ecx, edx		判断植物是否为升级至 theUpgradedType 所需的植物（或之一）。
463470	Plant::IsUpgradableTo(SeedType theUpgradedType, ecx = Plant* this)	al = 0(否) | 1(是); ecx, edx		判断植物当前是否可以（作为主植物）升级至 theUpgradedType 植物。
4635C0	Plant::UpdateReanimColor(Plant* this)	eax, ecx, edx		更新植物动画的颜色。
4638F0	Plant::IsInPlay(eax = Plant* this)	al = 0(否) | 1(是)		判断植物是否为战斗关卡（除禅境花园、智慧树以外的关卡）内的植物。
463920	Plant::UpdateReanim(ebx = Plant* this)	eax, ecx, edx		植物本体动画更新函数，更新植物动画的各项信息数据。
463E40	Plant::Update(eax = Plant* this)	eax, ecx, edx		植物的总更新函数。
463EF0	Plant::NotOnGround(eax = Plant* this)	al = 0(在地面) | 1(不在地面); ecx		判断植物是否位于地面上。可用于判断格子能否种植、植物是否会受到攻击等。
463F30	Plant::AttachBlinkAnim(edi = Reanimation* theReanimBody, eax = Plant* this)	eax = Reanimation* aBlinkReanim; ecx, edx		创建并绑定植物的眨眼动画。参数的植物本体动画用于判断轨道情况和设定眨眼动画的部分基础数据。
464230	Plant::DoBlink(eax = Plant* this)	eax, ecx, edx		植物眨眼，创建并绑定眨眼动画。
464390	Plant::EndBlink(esi = Plant* this)	eax, ecx, edx		植物结束眨眼，删除眨眼动画。
464410	Plant::UpdateBlink(eax = Plant* this)	eax, ecx, edx		植物眨眼的更新函数，包括植物开始眨眼和结束眨眼的判定和执行。
464480	Plant::AnimateNuts(edi = Plant* this)	eax, ecx, edx		坚果类植物（坚果、高坚果）的动态函数，根据植物当前血量更新其形态相应的覆写贴图。
464680	Plant::AnimateGarlic(eax = Plant* this)	eax, ecx, edx		大蒜的动态函数，根据植物当前血量更新其形态相应的覆写贴图。
464760	Plant::AnimatePumpkin(eax = Plant* this)	eax, ecx, edx		南瓜头的动态函数，根据植物当前血量更新其形态相应的覆写贴图。
464820	Plant::UpdateShooting(eax = Plant* this)	eax, ecx, edx		射手类植物子弹发射的更新和处理函数。大喷菇和忧郁菇的攻击也在此函数中进行更新。;此函数区别于 UpdateShooter 等函数，在植物攻击被触发后，更新处理伤害的实际产生或子弹的实际发射。
464DB0	Plant::Animate(eax = Plant* this)	eax, ecx, edx		植物动态的更新函数，包括植物动态相关倒计时的更新、贴图效果的更新和眨眼的更新等各类动态的处理。
464EF0	PlantFlowerPotHeightOffset(float theFlowerPotScale, eax = SeedType theSeedType)	st(0) = aHeightOffset; ecx	0x4	根据植物类型及花盆的大小，取得种植在花盆上的植物的纵向偏移高度。
465040	PlantDrawHeightOffset(int theRow = -1, int theCol = -1, esi = SeedType theSeedType, ;                      eax = Plant* thePlant = 0, edi = Board* theBoard = 0)	st(0) = aHeightOffset; eax, ecx, edx	0x8	根据植物类型及 (theCol, theRow) 格子内的情况等，计算植物位置的纵向偏移高度。;当不在关卡内时，theBoard 指针可以为 0当不涉及具体的植物实例时，thePlant 指针可以为 0;当不特定具体某一行/某一列时， theRow/theCol 可以为 -1。
465380	Plant::GetPeaHeadOffset(int& theOffsetY, int& theOffsetX, eax = Plant* this)	eax, ecx, edx		取得豌豆家族植物子弹发射位置的横、纵向偏移分别存储在 [&theOffsetX] 和 [&theOffsetY] 地址处。
465460	Plant::DrawMagnetItems(Graphics* g, ebx = Plant* this)	eax, ecx, edx		绘制磁力菇和吸金磁所有吸引的物品。
465680	Plant::DrawShadow(float theOffsetY, float theOffsetX, Graphics* g, eax = Plant* this)	eax, ecx, edx		绘制植物影子。
465A90	Plant::Draw(Graphics* g, Plant* this)	eax, ecx, edx		绘制植物，包括植物动画、贴图、影子等的绘制和冷却中的磁力菇的吸引物品的绘制。
4660B0	Plant::DrawSeedType(float thePosY, float thePosX, DrawVariation theDrawVariation, ;                    ecx = SeedType theImitaterType, edx = SeedType theSeedType, Graphics* g)	eax, ecx, edx	0x10	在 (thePosX, thePosY) 位置处绘制 theSeedType(theImitaterType) 植物。;此函数对僵尸卡牌的 theSeedType 同样适用。
466390	Plant::MouseDown(int y, int x, esi = Plant* this)	eax, ecx, edx		鼠标点击植物。对于装填完成的玉米加农炮，重置鼠标相关并记录点炮数据对于其他植物，不作任何处理。
466420	Plant::IceZombies(edi = Plant* this)	eax, ecx, edx		冻结战场，包括冻结全场僵尸、冻结水面和天空、清除僵王博士的火球。
4664B0	Plant::BurnRow(int theRow, edi = Plant* this)	eax, ecx, edx		植物在其攻击能力范围内尝试将第 theRow 行的僵尸化为灰烬，同时销毁该行的梯子和冰球。
4665B0	Plant::BlowAwayFliers(Plant* this)	eax, ecx, edx		吹飞所有僵尸方的飞行单位（气球僵尸），同时吹散浓雾。
466650	Plant::KillAllPlantsNearDoom(edi = Plant* this)	eax, ecx, edx		清空与植物（毁灭菇）在同一格内的所有植物。
4666A0	Plant::DoSpecial(Plant* this)	eax, ecx, edx		部分特殊型植物（尤一次性植物）的生效函数。
466B80	Plant::ImitaterMorph(esi = Plant* this)	eax, ecx, edx		模仿者变身生效函数，种植其模仿的类型的植物，并设置该植物各个动画的滤镜。
466CA0	Plant::UpdateImitater(edi = Plant* this)	eax, ecx, edx		【植物特性函数】模仿者的特性更新函数。
466D50	Plant::CobCannonFire(int theTargetY, int theTargetX, eax = Plant* this)	eax, ecx, edx		玉米加农炮锁定目标位置，播放发射动画，记录目标位置坐标，并进入发射预备状态。
466E00	Plant::Fire(PlantWeapon thePlantWeapon, int theRow, Zombie* theTargetZombie = 0, Plant* this)	eax, ecx, edx		发射类（射手类、投手类、喷射类）植物的攻击函数。其中：;thePlantWeapon = 0(一般) | 1(仙人掌发射地面子弹、玉米投手投掷黄油、裂荚射手攻击后方);目标僵尸仅用于确定投手类植物的抛物线，为 0 时子弹会投掷至场地边缘。
4675C0	Plant::FindTargetZombie(ecx = PlantWeapon thePlantWeapon, int theRow, Plant* this)	eax = Zombie*? aTargetZombie; ecx, edx		植物索敌函数，若范围内有敌方僵尸则返回该僵尸的指针，否则返回 0。;thePlantWeapon = 0(一般) | 1(仙人掌发射地面子弹、玉米投手投掷黄油、裂荚射手攻击后方)。
4678B0	Plant::DistanceToClosestZombie(Plant* this)	eax = int aDistance; ecx, edx		取得本行内距离植物最近的一只僵尸到植物的距离。会忽略所有不在植物攻击能力范围内的僵尸。
4679B0	Plant::Die(Plant* this)	eax, ecx, edx		令植物消失，同时处理植物消失相关事件。
467B00	Plant::GetCost(edx = SeedType theImitaterType, eax = SeedType theSeedType)	eax = int aCost; ecx, edx		取得植物种植时需要花费的阳光数量。我是僵尸模式下的僵尸卡牌价格也在此函数中获取。
467C00	Plant::GetNameString(SeedType theImitaterType, SeedType theSeedType, _Out_ std::string&& aNameString)	eax = std::string&& aNameString; ecx, edx	0xC	取得植物名称的字符串。
467DB0	Plant::GetToolTip(SeedType theSeedType, ecx = _Out_ std::string&& aToolTipString)	eax = std::string&& aToolTipString; ;ecx, edx	0x4	取得植物提示文本的字符串。
467E30	Plant::GetRefreshTime(edx = SeedType theImitaterType, ecx = SeedType theSeedType)	eax = int aRefreshTime; ecx		从植物信息数组中取得对应植物的冷却时间。当卡牌为僵尸卡时，返回冷却时间为 0。
467E60	Plant::IsNocturnal(eax = SeedType theSeedType)	al = 0(否) | 1(是)		判断植物是否为夜行性（蘑菇家族）的植物。
467EA0	Plant::IsAquatic(eax = SeedType theSeedType)	al = 0(否) | 1(是)		根据给定的植物类型 theSeedType，判断植物是否为水生植物。
467EC0	Plant::IsUpgrade(eax = SeedType theSeedType)	al = 0(否) | 1(是)		根据给定的植物类型 theSeedType，判断植物是否为紫卡植物。
467EF0	Plant::GetPlantRect(eax = _Out_ Rect&& aInjuryRect, ecx = Plant* this)	eax = Rect&& aInjuryRect; ecx, edx		取得植物受伤判定范围的矩形。
467F90	Plant::GetPlantAttackRect;(PlantWeapon thePlantWeapon, eax = _Out_ Rect&& aAttackRect, ecx = Plant* this)	eax = Rect&& aAttackRect; ecx, edx		取得植物可以攻击（或作用）到的范围的矩形。其中，thePlantWeapon = 0(一般) | 1(裂荚射手攻击后方) 。
4681E0	Plant::PreloadPlantResources(esi = SeedType theSeedType)	eax, ecx, edx		预加载 theSeedType 植物相关的所有动画的定义数据。每次进入关卡时会对所有已拥有的植物调用此预加载。
468280	Plant::PlayIdleAnim(float theRate, edi = Plant* this)	eax, ecx, edx		以 theRate 速率播放植物闲置动画，IZ 模式中固定将动画速率设为 0。
4682E0	Sexy::SexyVector2::Magnitude(eax = SexyVector2* this)	st(0) = aMag; eax, ecx, edx		计算平面向量的大小（模）。
468310	PlayerInfo::SyncSummary(DataSync& theSync, eax = PlayerInfo* this)	eax, ecx, edx		同步存档基础数据，包括用户名字符串、用户序列号和用户编号的数据。
468390	PlayerInfo::SyncDetails(DataSync& theSync, PlayerInfo* this)	eax, ecx, edx		同步存档文件细节数据，包括除用户名字符串、更换用户次数和用户序号以外的所有 PlayerInfo 数据。;当数据同步器存在读取器时，将清空当前用户数据，然后从读取器的数据区读取并赋值用户数据;否则，保存当前用户数据到写入器的数据区，保存时会根据数据量自动调整其数据区的内存容量大小。
469400	PlayerInfo::LoadDetails(PlayerInfo* this)	eax, ecx, edx		从 userdata/user%d.dat 存档文件读取用户数据。
4695F0	PlayerInfo::SaveDetails(PlayerInfo* this)	eax, ecx, edx		保存用户数据到 userdata/user%d.dat 存档文件。
469810	PlayerInfo::DeleteUserFiles(PlayerInfo* this)	eax, ecx, edx		删除指定用户的用户数据的存档文件及该用户各个关卡的存档文件。
469940	PlayerInfo::Reset(esi = PlayerInfo* this)	eax, ecx, edx		创建新存档时调用，初始化除用户名外的所有数据。需要一个大小为 0x4818 的内存区域用于存储 *this 的数据。
469A00	PottedPlant::InitializePottedPlant(SeedType theSeedType = -1, esi = PottedPlant* this)	eax, ecx, edx		初始化盆栽植物信息和数据，并随机决定盆栽植物的朝向和需要浇水的次数。
469A60	PoolEffect::PoolEffectInitialize(esi = PoolEffect* this)	eax, ecx, edx		初始化水面效果，生成原始的焦散图像并拷贝焦散灰度图像的不透明度通道。
469BC0	PoolEffect::BilinearLookupFixedPoint(edx = unsigned int v, eax = unsigned int u, PoolEffect* this)	eax = unsigned char alpha; ecx, edx		根据当前横向和纵向的时刻，从焦散灰度图像中双线性混合地计算焦散图像当前的不透明度值。;其中，u 和 v 为以无符号整数形式表示的定点数，其高 16 位为整数部分，低 16 位为小数部分。
469CA0	PoolEffect::UpdateWaterEffect(eax = PoolEffect* this)	eax, ecx, edx		更新焦散图像各像素的不透明度值。
469DE0	PoolEffect::Draw(bool theIsNight, Graphics* g, PoolEffect* this)	eax, ecx, edx		绘制水面波纹特效。其中 theIsNight 指定绘制的是否为夜晚的水面效果。
46A6B0	floorf(float _X)	st(0) = _Val; eax, edx	0x4	将给定的浮点数向下取整。
46A6E0	ProfileMgr::ProfileMgr(ProfileMgr* this)	eax = *this; ecx, edx		初始化创建存档管理器并清空存档信息的映射容器。需要一个大小为 0x18 的内存区域用于构造 this。
46A780	ProfileMgr::`scalar deleting destructor'(unsigned int flags, ecx = ProfileMgr* this)	eax = *this; ecx, edx		删除存档管理器，当 flags 的第 0 位置 1 时会额外释放存档管理器对话本身占用的内存空间。		【虚函数】[[[(ProfileMgr*)]+0]+0]
46A7B0	std::map<std::string, PlayerInfo, Sexy::StringLessNoCase>::~map<std::string, PlayerInfo, Sexy::StringLessNoCase>;(eax = std::map<std::string, PlayerInfo, Sexy::StringLessNoCase>* this)	eax, ecx, edx		销毁存档管理器的存档信息的映射容器。此函数内部直接跳转至46C290的函数。
46A7C0	ProfileMgr::GetAnyProfile(esi = ProfileMgr* this)	eax = PlayerInfo*? aPlayerInfo; ecx, edx		当存档管理器中存储有存档信息时，取首个节点的存档、加载该存档的数据并返回该存档否则，返回 0。
46A7F0	ProfileMgr::Clear(edi = ProfileMgr* this)	eax, ecx, edx		重置存档管理器，清空存档管理器的存档信息的映射容器，同时重置下一个存档的编号和顺序。
46A830	ProfileMgr::SyncState(DataSync& theSync, ProfileMgr* this)	eax, ecx, edx		当待同步的存档的版本与当前游戏存档版本相同时，利用数据同步器同步所有存档的基础数据。
46AA30	PlayerInfo::operator=(eax = const PlayerInfo& __that, ebx = PlayerInfo* this)	eax = PlayerInfo& this; ecx, edx		存档的赋值运算符，以存档 __that 的数据赋值存档 this。
46ABC0	ProfileMgr::Load(ProfileMgr* this)	eax, ecx, edx		尝试读取游戏文件夹下“userdata/users.dat”中的存档配置数据，若发生异常则转为重置存档管理器。
46AD80	ProfileMgr::Save(eax = ProfileMgr* this)	eax, ecx, edx		将当前存档配置相关的数据写入游戏文件夹下的“userdata/users.dat”文件中。
46AF70	ProfileMgr::DeleteProfile(ecx = const std::string& theName, eax = ProfileMgr* this)	al = bool 是否找到并成功删除指定存档; ;ecx, edx		删除存档管理器中用户名为 theName 的存档。
46AFF0	ProfileMgr::RenameProfile;(const std::string& theNewName, ecx = const std::string& theOldName, edx = ProfileMgr* this)	al = bool 是否找到并成功重命名指定存档; ;ecx, edx		将名为 theOldName 的用户的用户名更改为 theNewName。
46B170	std::pair<std::string, PlayerInfo>::~pair<std::string, PlayerInfo>(esi = std::pair<std::string, PlayerInfo>* this)	eax, ecx, edx		销毁字符串和存档的对组，销毁字符串和存档。
46B1C0	ProfileMgr::DeleteOldestProfile(eax = ProfileMgr* this)	eax, ecx, edx		删除按使用时间排序下当前最久未使用的存档。
46B290	ProfileMgr::GetProfile(ecx = const std::string& theName, edi = ProfileMgr* this)	eax = PlayerInfo*? aProfile; ecx, edx		寻找名为 theName 的用户，若成功找到该用户则立即读取其存档并视为使用该存档，未找到则返回 0。
46B310	ProfileMgr::AddProfile(const std::string& theName, edi = ProfileMgr* this)	eax = PlayerInfo*? aProfile; ecx, edx		创建名为 theName 的新用户存档。若需要创建的存档的用户名与已有存档重复，则无法成功完成创建。;成功创建后，若当前存档数量超过 200 个，则依次删除最久未使用的存档直至存档数量不超过 200 个。
46B4D0	std::map<std::string, PlayerInfo, Sexy::StringLessNoCase>::operator[];(const std::string& _Keyval, std::map<std::string, PlayerInfo, Sexy::StringLessNoCase>* this)	eax = PlayerInfo& _Val; ecx, edx		在字符串向存档的映射容器中寻找 _Keyval 字符串对应的存档值，返回对该存档的引用。;若容器中原先不存在 _Keyval 键，则向容器中新添加一个 (_Keyval, _P) 对组，其中 _P 为默认构造的存档。
46B640	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::insert;(const std::pair<std::string, PlayerInfo>& _Val, ; _Out_ std::pair<std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator, bool>&& _Ret, ; ebx = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		向字符串向存档的映射容器中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
46B740	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::erase;(std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator _Where, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator&& _Ret, ; std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		删除字符串向存档的映射容器中 _Where 指示的位置处的元素，并取得删除后的新的迭代器。;其中，参数 _Where 采用值传递（一种传参方式是依次令 [&_Where+4] 和 [&_Where+0] 入栈）。
46BAD0	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::find;(ebx = const std::string& _Keyval, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator&& _Ret, ; esi = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		在字符串向存档的映射容器中寻找 _Keyval 字符串对应的存档值。;若找到，则返回指示该对组所在位置处的迭代器否则，返回相当于 map.end() 的迭代器。
46BB40	std::_Tree<std::_Tmap_traits<...>>::const_iterator::operator==;(esi = const std::_Tree<std::_Tmap_traits<...>>::const_iterator& _Right, ; edi = std::_Tree<std::_Tmap_traits<...>>::const_iterator* this)	al = bool _Equal; ecx, edx		判断两个迭代器是否相等，即判断两个迭代器指向的地址是否相同。不同容器的迭代器比较时会发生错误。;此函数适用于所有类型的映射容器的迭代器。
46BB60	std::pair<std::string, PlayerInfo>::pair<std::string, PlayerInfo>;(const PlayerInfo& _Val2, const std::string& _Val1, std::pair<std::string, PlayerInfo>* this)	eax = *this; ecx, edx		从给定的字符串和存档创建一个对组。需要一个大小为 0x4834 的内存区域用于构造 this。
46BBC0	PlayerInfo::PlayerInfo(const PlayerInfo& __that, ebx = PlayerInfo* this)	eax = *this; ecx, edx		复制存档 __that 的数据以构造新存档 this。需要一个大小为 0x4818 的内存区域用于构造 this。
46BD40	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::insert;(std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator _Where, ; const std::pair<std::string, PlayerInfo>& _Val, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator&& _Ret, ; eax = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		向字符串向存档的映射红黑树中的指定位置添加一个对组 _Val，返回表示插入的键值在红黑树中的位置的迭代器。
46BF60	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Erase;(std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Rootnode, ; ecx = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		移除并释放字符串向存档的映射容器的红黑树的一个节点及该节点的所有右节点。
46BFE0	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Insert;(const std::pair<std::string, PlayerInfo>& _Val, ; ecx = std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		在字符串向存档的映射红黑树中的指定节点下添加一个新的节点，返回表示插入的键值在红黑树中的位置的迭代器。
46C1A0	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Lrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		对字符串向存档的映射红黑树的一个节点进行左旋转。
46C1F0	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Max;(eax = std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Pnode)	eax = _Node* _Maxnode; ecx, edx		取得字符串向存档的映射红黑树从 _Pnode 开始最右侧的一个节点。
46C210	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Min;(eax = std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Pnode)	eax = _Node* _Minnode; ecx, edx		取得字符串向存档的映射红黑树从 _Pnode 开始最左侧的一个节点。
46C230	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Rrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		对字符串向存档的映射红黑树的一个节点进行右旋转。
46C290	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::~_Tree<std::_Tmap_traits<...>>;(eax = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		销毁并释放字符串向存档的映射红黑树。
46C2D0	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::erase;(std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator _Last, ; std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator _First, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		移除字符串向存档的映射红黑树从 _First 至 _Last 之间的所有节点。
46C3A0	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Lbound;(const std::string& _Keyval, eax = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>* this)	eax = _Node* _Bound; ecx, edx		根据红黑树的有序性，在字符串向存档的映射红黑树中寻找可以放置 _Keyval 的最底层的一个节点。;其原理为：初始时记录红黑树的根节点，然后从根节点开始比较该节点处的键与 _Keyval 的大小，;若该节点的键小于 _Keyval 则取其右子节点继续比较，否则将记录值改为该节点并取其左子节点继续比较。;重复上述过程，直到遇到空节点，然后返回记录值。
46C410	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Buynode;(const std::pair<std::string, PlayerInfo>& _Val, ; std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Rarg, ; std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Parg, ; std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Larg)	eax = std::_Tree_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符串向存档的映射容器的节点，令该节点的父节点指针指向 _Parg，;并令该节点的左、右子节点指针分别指向 _Larg 和 _Rarg，同时赋值该节点处的对组值为 _Val。
46C4B0	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::const_iterator::_Inc;(esi = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::const_iterator* this)	eax, ecx, edx		字符串向存档的映射容器的常量迭代器自增。
46C520	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Buynode()	eax = _Node* _Pnode; ecx, edx		创建一个字符串向存档的映射红黑树的节点，令该节点的子节点和父节点指针为空指针，并初始化该节点的颜色。
46C560	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::const_iterator::_Dec;(esi = std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::const_iterator* this)	eax, ecx, edx		字符串向存档的映射容器的常量迭代器自减。
46C5F0	std::pair<std::string, PlayerInfo>::pair<std::string, PlayerInfo>;(ecx = const std::pair<std::string, PlayerInfo>& __that, std::pair<std::string, PlayerInfo>* this)	eax = *this; ecx, edx		复制字符串和存档的对组 __that 的数据以构造新字符串和存档的对组 this。;需要一个大小为 0x4834 的内存区域用于构造 this。
46C650	std::_Allocate<std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node>;(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符串向存档的映射容器的节点所需要的内存空间，单个节点占用的内存大小为 0x4850。;当 _Count 个链表容器的节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
46C6A0	Sexy::StringLessNoCase::operator()(eax = const std::string& s2, ecx = const std::string& s1)	al = bool less; ecx, edx		不区分大小写地比较 s1 和 s2 字符串，返回表示 s1 是否小于 s2 的逻辑值。
46C6F0	FloatApproxEqual(float theFloatVal2, float theFloatVal1)	eax = 0(不等) | 1(相等)	0x8	判断两个浮点数是否近似相等。当其差值小于 10-6 时，认为其近似相等。
46C730	Projectile::ProjectileInitialize;(ProjectileType theProjectileType, eax = int theRow, int theRenderOrder, int theY, int theX, Projectile* this)	eax, ecx, edx		初始化子弹信息和数据。
46CAA0	Projectile::FindCollisionTargetPlant(Projectile* this)	eax = Plant*? aPlant; ecx, edx		子弹对植物的碰撞检测，寻找子弹击中的植物。若不存在碰撞到的植物，则返回 0。
46CC30	Projectile::PeaAboutToHitTorchwood(edi = Projectile* this)	al = 0(否) | 1(是); ecx, edx		判断子弹是否位于其可用的火炬树桩附近。对于水平向右运动的豌豆和冰豌豆以外的子弹，一律返回“否”;若子弹右移 40 像素后与火炬树桩重叠超过 10 像素，则返回“是”，此时子弹将跳过对僵尸的碰撞检测。
46CD40	Projectile::FindCollisionTarget(Projectile* this)	eax = Zombie*? aZombie; ecx, edx		子弹对僵尸的碰撞检测，寻找子弹击中的僵尸。碰撞到多只僵尸时，返回其中横坐标最小的一只。;若不存在碰撞到的僵尸，则返回 0。特别地，当豌豆或冰豌豆即将进入火炬树桩时，不进行碰撞检测而直接返回 0。
46CE80	Projectile::CheckForCollision(Projectile* this)	eax, ecx, edx		水平运动的子弹的碰撞检测函数，若检测到击中目标植物或僵尸，则处理击中相关事件。;此函数会同时判断子弹的消失条件（子弹坐标、孢子的存在时间等）并依此决定是否令子弹消失。
46D090	Projectile::CantHitHighGround(ecx = Projectile* this)	al = 0(否，可以击中高地上的目标) | ;     1(是，不能击中高地上的目标)		判断子弹是否不能击中高地上的目标，亦用于判断子弹是否会被高地阻挡。;当返回 0 时，表示子弹不会击中高地，即子弹不会被高地阻拦，因而子弹可以正常击中高地上的目标。
46D0D0	Projectile::CheckForHighGround(esi = Projectile* this)	eax, ecx, edx		子弹击地的判断，若击中地面（高度低于一定值）或击中高地，则跳转至46E000的函数。
46D1F0	Projectile::IsSplashDamage(ecx = Zombie* theZombie = 0, eax = Projectile* this)	al = bool isSplash; ecx, edx		判断子弹对特定僵尸是否造成溅射伤害。
46D230	Projectile::GetDamageFlags(eax = Zombie* theZombie, edi = Projectile* this)	eax = unsigned int aDamageFlags; ecx, edx		取得子弹对特定僵尸的伤害类型。
46D2B0	Projectile::IsZombieHitBySplash(eax = Zombie* theZombie = 0, Projectile* this)	al = bool hit; ecx, edx		判断僵尸是否会受到子弹的溅射伤害，包括攻击能力和位置范围等判断。
46D390	Projectile::DoSplashDamage(Zombie* theZombie = 0, eax = Projectile* this)	eax, ecx, edx		带溅射的子弹令击中的僵尸本身（若存在）和溅射范围内的所有僵尸受到相应的伤害。
46D490	Projectile::UpdateLobMotion(Projectile* this)	eax, ecx, edx		投掷类子弹的运动更新及碰撞检测函数。
46D890	Projectile::UpdateNormalMotion(Projectile* this)	eax, ecx, edx		水平运动的子弹的运动更新函数，同时调用子弹对目标和对地面的碰撞检测函数。
46DC70	Projectile::UpdateMotion(esi = Projectile* this)	eax, ecx, edx		子弹运动更新函数。在根据子弹运动方式调用相应的运动函数后，额外对部分子弹进行针对屋顶的相关修正。
46DD30	Projectile::PlayImpactSound(Zombie* theZombie = 0, eax = Projectile* this)	eax, ecx, edx		播放子弹破裂的音效。若存在击中的僵尸，则额外根据僵尸的一类防具类型播放相应的音效。
46E000	Projectile::DoImpact(eax = Zombie* theZombie = 0, ecx = Projectile* this)	eax, ecx, edx		子弹击中物体，创建相应的音效和特效等，并令子弹消失。若击中僵尸，则同时处理对僵尸的伤害和特殊效果。
46E460	Projectile::Update(eax = Projectile* this)	eax, edx		子弹的总更新函数。
46E540	Projectile::Draw(Graphics* g, Projectile* this)	eax, ecx, edx		绘制子弹。
46E8C0	Projectile::DrawShadow(Graphics* g, esi = Projectile* this)	eax, ecx, edx		绘制子弹影子。
46EB20	Projectile::Die(eax = Projectile* this)	eax, edx		销毁子弹，解除绑定并销毁子弹的附件。
46EBC0	Projectile::GetProjectileRect(ecx = _Out_ Rect&& aRect, esi = Projectile* this)	eax = Rect&& aRect; ecx, edx		取得子弹的判定范围的矩形赋值给 aRect。
46ECB0	Projectile::ConvertToFireball(eax = int theGridX, ecx = Projectile* this)	eax, ecx, edx		豌豆穿过位于 theGridX 列的火炬树桩，转化为火豌豆。
46EE00	Projectile::ConvertToPea(ebx = int theGridX, eax = Projectile* this)	eax, ecx, edx		冰豌豆穿过位于 theGridX 列的火炬树桩，转化为豌豆。
46EE80	Sexy::SexyVector2::Normalize(edi = _Out_ SexyVector2&& aNormal, eax = SexyVector2* this)	eax = SexyVector2&& aNormal; ecx		平面向量标准化，即：计算给定平面向量方向上的单位向量。
46EF00	ReanimatorCache::UpdateReanimationForVariation;(edi = DrawVariation theDrawVariation, eax = Reanimation* theReanim)	eax, ecx, edx		根据绘图变化 theDrawVariation 更新金盏花动画的滤镜和叶片轨道的颜色。
46F100	ReanimatorCache::DrawReanimatorFrame;(DrawVariation theDrawVariation, ecx = const char* theTrackName, edx = ReanimationType theReanimationType, ; float thePosY, float thePosX, Graphics* g)	eax, ecx, edx		动画制图。于 (thePosX, thePosY) 处绘制 theReanimationType 动画 theTrackName 轨道上的动作的贴图。;此函数内部于栈上创建了 theReanimationType 动画并设置了动画的各项信息，绘制的实质是472E40的函数。
46F280	ReanimatorCache::MakeBlankMemoryImage(ecx = int theHeight, ebx = int theWidth)	eax = MemoryImage* aImage; ecx, edx		初始化创建一个横向宽度为 theWidth 纵向高度为 theHeight 的矩形空贴图。
46F330	ReanimatorCache::MakeCachedMowerFrame(LawnMowerType theMowerType)	eax = MemoryImage* aImage; ecx, edx		从动画制取指定 theMowerType 小推车的贴图缓存。
46F550	ReanimatorCache::MakeCachedPlantFrame(DrawVariation theDrawVariation, ecx = SeedType theSeedType)	eax = MemoryImage* aImage; ecx, edx		从动画以指定绘图变化 theDrawVariation 制取 theSeedType 植物的贴图缓存。
46F8A0	ReanimatorCache::MakeCachedZombieFrame(ecx = ZombieType theZombieType)	eax = MemoryImage* aImage; ecx, edx		从动画制取指定 theZombieType 僵尸的贴图缓存，但植物僵尸/暴走伽刚特尔会返回普通僵尸/伽刚特尔的贴图。
46FDC0	ReanimatorCache::ReanimatorCacheInitialize(edx = ReanimatorCache* this)	eax, ecx		初始化动画缓存系统。
46FED0	ReanimatorCache::ReanimatorCacheDispose(eax = ReanimatorCache* this)	eax, ecx, edx		释放动画缓存的所有贴图。
46FFB0	ReanimatorCache::DrawCachedPlant(edx = DrawVariation theDrawVariation, eax = SeedType theSeedType, ;                                 float thePosY, float thePosX, Graphics* g, ReanimatorCache* this)	eax, ecx, edx		绘制动画缓存的植物贴图，若无缓存的贴图则会制取贴图并写入缓存。
470110	ReanimatorCache::DrawCachedMower(esi = LawnMowerType theMowerType, float thePosY, float thePosX, ;                                 edi = Graphics* g, ebx = ReanimatorCache* this)	eax, ecx, edx		绘制动画缓存的小推车贴图，若无缓存的贴图则会制取贴图并写入缓存。
470170	ReanimatorCache::DrawCachedZombie(esi = ZombieType theZombieType, float thePosY, float thePosX, ;                                  edi = Graphics* g, ebx = ReanimatorCache* this)	eax, ecx, edx		绘制动画缓存的僵尸贴图，若无缓存的贴图则会制取贴图并写入缓存。
4701C0	TodList<ReanimCacheImageVariation>::AddHead;(const ReanimCacheImageVariation& theHead, ebx = TodList<ReanimCacheImageVariation>* this)	eax, ecx, edx		向动画缓存贴图样式链表的头部添加一项 theHead。
470250	ReanimAtlas::ReanimAtlas(eax = ReanimAtlas* this)	eax = *this; ecx, edx		初始化创建动画图集。
470290	ReanimAtlasMakeBlankMemoryImage(ebx = int theHeight, ecx = int theWidth)	eax = MemoryImage* aImage; ecx, edx		初始化创建一个横向宽度为 theWidth 纵向高度为 theHeight 的矩形空贴图。
470340	sSortByNonIncreasingHeight(const ReanimAtlasImage& image2, const ReanimAtlasImage& image1)	al = image1 < image2; ecx, edx	0x8	图集图片的排序函数。当返回 al = 1 时，表示 image1 排列于 image2 前，反之同理。;函数使图集图片以“图片高度、图片宽度、图片地址”的优先级降序排列。
470370	ReanimAtlas::PickAtlasWidth(eax = ReanimAtlas* this)	eax = int aWidth; ecx, edx		根据排序后的图集图片数组中的每张图片的尺寸，选取合适的宽度作为图集的宽度。
470420	ReanimAtlas::ImageFits(int theMaxWidth, const Rect& rectTest, int theImageCount, ReanimAtlas* this)	al = bool 是否能容纳; ecx, edx		判断一张占用范围为 rectTest 的图片能否容纳在图集中。其中，theMaxWidth 表示图集的最大宽度;theImageCount 表示当前已确定位置的图片的数量，“能容纳”要求指定矩形不与这些图片的任何一张有重合。
4704C0	ReanimAtlas::ImageFindPlaceOnSide(bool theToRight, int theMaxWidth, int theImageCount, ;                                  ReanimAtlasImage* theAtlasImageToPlace, ReanimAtlas* this)	al = bool 是否成功; ecx, edx		尝试将当前图片加入图集中的合适位置。若指定了 theToRight，则尝试将当前图片贴近其他图片的右侧放置;否则，尝试将图片贴近其他图片的底端放置。当指定方位上存在可容纳的位置时，设置图片位置并返回 1。
470580	ReanimAtlas::ArrangeImages(int& theAtlasHeight, int& theAtlasWidth, esi = ReanimAtlas* this)	eax, ecx, edx		将所有图集图片按高度降序排序，然后计算合适的图集高度并依次将每一张图片布局在图集中合适的位置。;将最终确定的图集宽度和高度分别写入 [&theAtlasWidth] 和 [&theAtlasHeight] 中。
470680	ReanimAtlas::ReanimAtlasCreate(ReanimatorDefinition* theReanimDef, ecx = ReanimAtlas* this)	eax, ecx, edx		制作一个包含动画定义中存在的所有贴图的图集。
4708D0	std::_Sort<ReanimAtlasImage*>(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), int _Ideal, ;                             ReanimAtlasImage* _Last, ReanimAtlasImage* _First)	eax, ecx, edx	0x10	根据给定的规则函数 _Pred 对图集图片数组进行排序。首次调用时，一般令 _Ideal = 图集图片数量。;函数默认递归调用自身，每次递归令 _Ideal /= 2, _Ideal += _Ideal / 2 后将其传递给下一次调用。;当 _ideal 的值减少至零时，将被认为递归的深度太深，函数将停止递归调用而转为调用堆排序。
470A20	std::_Unguarded_partition<ReanimAtlasImage*>(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ;                                            ReanimAtlasImage* _Last, ReanimAtlasImage* _First, ;                                            _Out_ std::pair<ReanimAtlasImage, ReanimAtlasImage>&& _Result)	eax = &&_Result(_MinItem, _MaxItem); ;ecx, edx	0x10	根据给定的规则函数将排序数组进行划分，返回划分结果的上下界组成的数值对。在给定的规则下，其满足：;_MinItem ≤ _MidItem ＜ _MaxItem，即所有与中值相等的项目都被包含在该数值对的两项之间。
470E60	std::_Insertion_sort<ReanimAtlasImage*>;(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ReanimAtlasImage* _Last, ReanimAtlasImage* _First)	eax, ecx, edx	0xC	根据给定的规则函数 _Pred 对 _First 和 _Last 之间的 ReanimAtlasImage 进行插入排序。;此函数仅在需要参与排序的项目数量较少（不超过 0x20 个）时被使用，用于提高排序的效率。
470EF0	std::_Median<ReanimAtlasImage*>(edi = bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ;                               ReanimAtlasImage* _Last, ebx = ReanimAtlasImagetem* _Medium, ;                               eax = ReanimAtlasImage* _First)	eax = RenderItem* _Mid; ecx, edx	0x4	当数组大小不大于 0x28 时，函数仅对数组首、中、尾的三个项目进行排序并返回中间值;当数组大小大于 0x28 时，将所有图集图片分隔为 8 段，并将其 9 个顶点的项目分 3 组进行排序，;然后将排序后的 3 组项目中每组的中间值再次进行排序，返回最终排序结果的中间值。
4710C0	std::iter_swap<ReanimAtlasImage*, ReanimAtlasImage*>;(eax = ReanimAtlasImage* _Right, ecx = ReanimAtlasImage* _Left)	eax, ecx, edx		交换两个图集图片指针指向的值，即：交换两个 ReanimAtlasImage 实例的数据（不改变其存储地址）。
471110	std::_Make_heap<ReanimAtlasImage*>(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ;                                  eax = ReanimAtlasImage* _Last, ecx = ReanimAtlasImage* _First)	eax, ecx, edx	0x4	将 _First 和 _Last 之间的图集图片数组转化为堆，排序规则函数决定了生成的堆为大堆顶或小堆顶。;在排序函数中，当 QuickSort 递归过深时，将转为使用堆排序，此函数为进行堆排序前的预备。
471190	std::_Sort_heap<ReanimAtlasImage*>(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ;                                  eax = ReanimAtlasImage* _Last, ebx = ReanimAtlasImage* _First)	eax, ecx, edx	0x4	根据给定的排序规则函数 _Pred 对 _First 和 _Last 之间的图集图片堆进行排序。
471220	std::_Adjust_heap<ReanimAtlasImage*>(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ;                                    ReanimAtlasImage _Val, int _Bottom, eax = int _Hole, ;                                    ebx = ReanimAtlasImage* _First)	eax, ecx, edx	0x1C	根据排序规则函数调整堆中的一个元素的位置：函数先令其下溯至堆底，再将其上溯至合适的位置。;其中，_First 指向堆顶，_Val 为调整的元素，_Hole 表示其原位置距离堆顶的高度，_Bottom 为堆高度。
4712F0	std::_Push_heap<ReanimAtlasImage*>(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ;                                  ReanimAtlasImage _Val, int _Top, eax = int _Hole, RenderItem* _First)	eax, ecx, edx	0x20	将 _Val 上溯至堆中合适的位置（完全二叉树中合适的节点处），且最高不能超过 _Top 指明的位置。;其中，参数的 _First 指向堆顶，_Hole 为该元素在经过下溯过程后所处于的位置距离堆顶的高度。;此函数在 _Adjust_heap() 的下溯过程完成后调用，参数的 _Top 的值等于传入该函数的 _Top。;即：元素可上溯至的最大高度，等于该元素在被调整之前位于堆中的高度。
471390	std::_Rotate<ReanimAtlasImage*>;(ReanimAtlasImage* _Last, eax = ReanimAtlasImage* _Mid, ReanimAtlasImage* _First)	eax, ecx, edx	0x8	将 [_First, _Last) 区间内的所有图集图片进行左旋转（类似循环左移），使得 _Mid 成为新的首项。
4714D0	std::_Pop_heap<ReanimAtlasImage*>;(bool (*_Pred)(ReanimAtlasImage&, ReanimAtlasImage&), ReanimAtlasImage _Val, ; eax = ReanimAtlasImage* _Dest, ecx = ReanimAtlasImage* _Last, edx = ReanimAtlasImage* _First)	eax, ecx, edx	0x18	将堆顶的元素移动至堆底，然后在不考虑当前堆底的情况下对原堆底的元素的位置进行调整。;调用时，_Last 和 _Dest 均指向原堆底的上一个元素，且值传递的 _Val = *_Last。
471540	ReanimatorTransform::ReanimatorTransform(eax = ReanimatorTransform* this)	eax = *this; ecx		初始化创建动画变换。需要一个大小为 0x2C 的内存区域用于构造 this。
471570	ReanimatorTransformConstructor(void* thePointer)	eax = void* thePointer; ecx	0x4	ReanimatorTransform 实例的构造函数。
4715B0	ReanimatorTrackConstructor(void* thePointer)	eax = void* thePointer; ecx	0x4	ReanimatorTrack 实例的构造函数。
4715D0	ReanimatorDefinitionConstructor(void* thePointer)	eax = void* thePointer; ecx	0x4	ReanimatorDefinition 实例的构造函数。
4715F0	ReanimationLoadDefinition(ReanimatorDefinition* theDefinition, eax = string& theFileName)	al = bool succeed; ecx, edx	0x4	加载文件名为 theFileName（即：reanim\xxx.reanim） 的动画文件定义数据存储在 theDefinition 中。
4717D0	ReanimationFreeDefinition(ebx = ReanimatorDefinition* theDefinition)	eax, ecx, edx		释放动画定义的 atlas 图集并根据动画定义结构图释放动画定义。
471890	ReanimatorTrackInstance::ReanimatorTrackInstance(edx = ReanimatorTrackInstance* this)	eax = *this; ecx		初始化构造动画轨道实例。需要一个大小为 0x60 的内存区域用于构造 this。
471920	Reanimation::Reanimation(edx = Reanimation* this)	eax = *this; ecx		初始化动画基础数据。创建新动画时调用，初始化动画的变换矩阵、颜色、播放数据等。
471A20	Reanimation::~Reanimation(esi = Reanimation* this)	eax, ecx, edx		销毁动画，同时回收动画轨道实例占用的内存区域。
471A60	Reanimation::ReanimationInitializeType;(esi = ReanimationType theReanimType, float theY, float theX, edi = Reanimation* this)	eax, ecx, edx		确保动画相应的定义数据的加载（若未加载则立即加载），然后以定义数据初始化动画。
471A90	ReanimationCreateAtlas(eax = ReanimationType theReanimationType, esi = ReanimatorDefinition* theDefinition)	eax, ecx, edx		生成指定类型动画的 atlas 图集。若动画定义中已存在图集或动画无需图集，则不进行任何操作。
471B00	Reanimation::ReanimationInitialize;(eax = ReanimatorDefinition* theDefinition, float theY, float theX, Reanimation* this)	eax, ecx, edx		根据动画定义初始化动画，包括生成动画图集、设定动画位置以及申请和初始化动画轨道等。
471BC0	Reanimation::Update(ecx = Reanimation* this)	eax, ecx, edx		动画更新。更新动画的循环数据及每一条轨道的变换混合、震动和附件的变换等。
471E50	BlendTransform(float theBlendFactor, eax = const ReanimatorTransform& theTransform2, ;               ecx = const ReanimatorTransform& theTransform1, edx = ReanimatorTransform* theResult)	eax, ecx	0x4	以 theBlendFactor 比例混合两个动画变换以进行动画补间的计算。;若需要直接在原变换上作修改，可令 theResult 指向需要修改的变换。
471F90	Reanimation::GetCurrentTransform;(eax = ReanimatorTransform* theTransformCurrent, ebx = int theTrackIndex, Reanimation* this)	eax, ecx, edx		获取动画当前时刻第 theTrackIndex 轨道在定义变换与覆写变换混合下的实际变换数据。
472020	Reanimation::GetTransformAtTime;(edi = ReanimatorFrameTime* theFrameTime, esi = ReanimatorTransform* theTransform, ; eax = int theTrackIndex, ecx = Reanimation* this)	eax, ecx, edx		根据动画当前时间信息及相关变换的定义数据，结合两帧之间的自然补间计算轨道当前时刻的基础变换数值。
4720F0	Reanimation::MatrixFromTransform;(esi = SexyMatrix3& theMatrix, edi = const ReanimatorTransform& theTransform)	eax, ecx, edx		根据动画变换的拉伸、倾斜及位移，创建相应的三阶变换矩阵。
472190	Reanimation::ReanimBltMatrix(eax = const Rect& theSrcRect, int theDrawMode, const Color& theColor, ;                             const Rect& theClipRect, ecx = SexyMatrix3& theTransform, Image* theImage, ;                             edx = Graphics* g, Reanimation* this)	eax, ecx, edx		依据动画参数标志的带矩阵绘图。利用矩阵计算绘图的位置、区域、拉伸等各项参数并绘制贴图。
4723B0	Reanimation::DrawTrack;(TodTriangleGroup* theTriangleGroup, int theTrackIndex, Graphics* g, Reanimation* this)	al = bool 是否成功; ecx, edx		当动画的指定轨道存在覆写的贴图时，先绘制当前 theTriangleGroup，然后直接绘制该覆写贴图;否则，将动画的指定轨道的绘制信息写入 theTriangleGroup，如需绘图则需要额外调用4461F0的函数。
472B70	Reanimation::GetCurrentTrackImage(esi = Reanimation* this)	eax = Image* aImage; ecx, edx		取得投石车僵尸动画“Zombie_catapult_pole”轨道的当前贴图。
472C00	Reanimation::GetTrackMatrix(SexyTransform2D& theMatrix, eax = int theTrackIndex, Reanimation* this)	eax, ecx, edx		获取动画指定轨道当前对图像进行变换作用（包括动画变换、覆写变换、轨道震动等的叠加）的矩阵。
472D90	Reanimation::GetFrameTime(edi = _Out_ ReanimatorFrameTime* theFrameTime, eax = Reanimation* this)	eax, ecx, edx		获取动画当前时间信息。需要一个大小为 0xC 的内存区域用于存储 *theFrameTime 的数据。其返回值结构如下：;[*theFrameTime+0] = mFraction，表示以循环率计算得到的浮点型当前帧在向下取整后的剩余小数部分;[*theFrameTime+4/+8] = mAnimFrameBeforeInt/mAnimFrameAfterInt，即浮点型当前帧的前/后一个整数帧。;一般地，可以取 theFrameTime->mAnimFrameBeforeInt 作为动画的当前帧。
472E40	Reanimation::DrawRenderGroup(int theRenderGroup, Graphics* g, ecx = Reanimation* this)	eax, ecx, edx		绘制动画的指定渲染分组，绘制该组中的所有轨道。
472F30	Reanimation::FindTrackIndex(const char* theTrackName, ebx = Reanimation* this)	eax = int aTrackIndex; ecx, edx		取得在自身动画中名为 theTrackName 的轨道所位于的层序数。
472F80	Reanimation::AttachToAnotherReanimation;(edx = const char* theTrackName, eax = Reanimation* theAttachReanim, esi = Reanimation* this)	eax, ecx, edx		将动画自身作为附件绑定至动画 theAttachReanim 的 theTrackName 轨道上。;若目标动画没有名为 theTrackName 的轨道，则将自身绑定至目标动画的首条轨道上。
472FD0	Reanimation::GetTrackBasePoseMatrix;(ebx = SexyTransform2D& theBasePosMatrix, int theTrackIndex, ecx = Reanimation* this)	eax, ecx, edx		取得动画指定轨道基准帧的定义变换的矩阵。若动画未设定基准帧，则以当前动作的起始帧代替。
473070	Reanimation::AttachParticleToTrack(float thePosY, float thePosX, TodParticleSystem* theParticleSystem, ;                                   eax = const char* theTrackName, ecx = Reanimation* this)	eax = AttachEffect*? aAttachEffect; ;ecx, edx		将粒子系统绑定至动画指定轨道的附件并设置位置偏移。当给定的粒子系统指针为空指针时，返回 0。
473110	Reanimation::GetAttachmentOverlayMatrix;(_Out_ SexyTransform2D& theOverlayMatrix, eax = int theTrackIndex, Reanimation* this)	eax, ecx, edx		取得动画指定轨道当前实际变换相较于基准帧上的定义变换的额外变换（动作、混合、覆写等）的矩阵。;即：以基准矩阵的逆矩阵乘以当前实际变换的矩阵。此矩阵在动画更新时可以用于设定上的附件的变换。
4731D0	Reanimation::GetFramesForLayer(int& theFrameCount, int& theFrameStart, edx = const char* theTrackName, eax = Reanimation* this)	eax, ecx, edx		获取动画的 theTrackName 轨道上第一个非空白关键帧作为动画开始帧赋值给 theFrameStart，;计算轨道上最后一个非空白帧与开始帧之间的长度为动画关键帧数量赋值给 theFrameCount。;若需播放动画在轨道上的动作，可以“lea &theFrameStart,[*this+18]，lea &theFrameCount,[*this+1C]”。
473280	Reanimation::SetFramesForLayer(const char* theTrackName, ecx = Reanimation* this)	eax, ecx, edx		令动画执行 theTrackName 动作，即：播放动画在 theTrackName 轨道上的动画。;此函数在内部根据动画速率初始化动画循环率和上一帧循环率后调用了4731D0的函数。
4732C0	Reanimation::TrackExist(const char* theTrackName, ebx = Reanimation* this)	al = 0(不存在) | 1(存在); ecx, edx		判断当前动画是否存在名为 theTrackName 的动作，即：动画的 .fla 文件是否存在 theTrackName 轨道。
473310	Reanimation::StartBlend(int theBlendTime, Reanimation* this)	eax, ecx, edx		补间动画开始混合时，分别记录每条轨道当前的变换数据作为混合补间的起始时刻（初始）数据。
4733F0	Reanimation::ReanimationDie(ecx = Reanimation* this)	eax, ecx, edx		令动画消失，同时令动画每条轨道上的附件消失。
473470	Reanimation::GetImageOverride(eax = const char* theTrackName, ecx = Reanimation* this)	eax = Image* aImageOverride; ecx, edx		取得动画的 theTrackName 轨道上的覆写贴图。
473490	Reanimation::SetImageOverride;(Image* theImage = 0, eax = const char* theTrackName, ecx = Reanimation* this)	eax, ecx, edx		将动画的 theTrackName 轨道上的图像用 theImage 替换。;当指定 theImage 为空指针时，表示清除该轨道上的覆写贴图。
4734B0	Reanimation::SetTruncateDisappearingFrames(eax = const char* theTrackName = 0, ecx = Reanimation* this)	eax, ecx, edx		设定动画指定轨道禁用截断消失帧，若指定的 trackName 为空指针，则依次设定动画的所有轨道。;截断消失帧：当从非空白帧过渡至空白帧时，若启用了截断消失帧，则略去过渡的过程而直接进入空白帧。
473500	ReanimationHolder::~ReanimationHolder(ReanimationHolder* this)	eax, ecx, edx		释放并销毁动画容器。
473590	ReanimationHolder::AllocReanimation(ebx = ReanimationType theReanimationType, int theRenderOrder, ;                                    float theY, float theX, eax = ReanimationHolder* this)	eax = Reanimation* aReanim; ecx, edx		动画容器从动画数据数组中申请新动画，并根据动画类型初始化动画。
4735E0	ReanimatorEnsureDefinitionLoaded(bool theIsPreloading, ReanimationType theReanimType)	eax, ecx, edx	0x8	确保 theReanimType 动画的定义数据已加载完成，若未加载则立即尝试加载，若加载失败则抛出相应错误。;参数 theIsPreloading 表示当前是否为预加载过程，预加载时若遇到程序退出则立即结束预加载。
473750	ReanimatorLoadDefinitions()	eax, ecx, edx		将 gLawnReanimationArray 指定为全局动画参数数组，并根据动画数量新建相应大小的动画定义数组。;此函数仅在 451880 的函数中（45224B 处）有过一次调用，故其原有的两个参数在原版中被内联至函数内：;【ReanimationParams* theReanimationParamArray（实参 = gLawnReanimationArray(0x6A1340)）】;动画参数（ReanimationParams）指定了一种动画类型与该动画的数据文件名及动画标志之间的对应关系;【int theReanimationParamArraySize（实参 = 143）】动画参数数组的长度，其值等于动画类型的数量。
473870	ReanimatorFreeDefinitions()	eax, ecx, edx		释放动画定义数组，清除全局动画参数数组指针。
4738D0	Reanimation::GetTrackVelocity(eax = Reanimation* this)	st(0) = aSpeed; eax, ecx, edx		取得动画 _ground 轨道的横向瞬时速度（从当前帧至下一帧的横向位移 * 动画速率 * 0.01）。;若动画不存在 _ground 轨道，则在获取轨道序号时会返回第 0 个轨道，取得的速度亦为该轨道的瞬时速度。
473930	Reanimation::IsTrackShowing(eax = Reanimation* this)	al = bool isShowing; ecx, edx		雪橇车动画专属，判断当前时刻 anim_wheelie2 轨道上是否存在图像，即判断当前时刻能否播放翻车动作。
473980	Reanimation::ShowOnlyTrack(Reanimation* this)	eax, ecx, edx		土豆地雷动画专属，将 anim_glow 以外的轨道全部隐藏。
4739E0	Reanimation::AssignRenderGroupToTrack;(int theRenderGroup, const char* theTrackName, ebx = Reanimation* this)	eax, ecx, edx		设置动画轨道在渲染绘制时的分组。通常情况下，分组为 -1 时表示隐藏该轨道。;此函数仅设置从下至上第一个名称恰好为 theTrackName 的图层（轨道）的渲染分组，不区分大小写。
473A40	Reanimation::AssignRenderGroupToPrefix;(int theRenderGroup, const char* theTrackName, Reanimation* this)	eax, ecx, edx		设置动画轨道在渲染绘制时的分组，通常情况下，分组为 -1 时表示隐藏该轨道。;此函数会依次设置所有名称以 theTrackName 开头的图层（轨道）的渲染分组，不区分大小写。
473AE0	Reanimation::PropagateColorToAttachments(ecx = Reanimation* this)	eax, ecx, edx		将动画的颜色应用到其所有轨道上的附件。
473B70	Reanimation::ShouldTriggerTimedEvent(float theEventTime, ecx = Reanimation* this)	al = 0(否) | 1(是)		判断动画在 theEventTime 时刻的事件是否应该触发。其中 theEventTime 的取值范围为 [0, 1]。
473BF0	Reanimation::PlayReanim(float theAnimRate, ReanimLoopType theLoopType, eax = int theBlendTime, ;                        const char* theTrackName, esi = Reanimation* this)	eax, ecx, edx		有补间地以 theAnimRate 速率播放动画 theTrackName 轨道上的动作。;可指定 theAnimRate 为 0 以表示不改变原有速率。theBlendTime 为补间动画的时长（帧数）。;此函数内部初始化了包括循环率、循环次数的动画相关属性，并调用了4731D0的函数。
473C60	Reanimation::ParseAttacherTrack;(AttacherInfo& theAttacherInfo, ecx = const ReanimatorTransform& theTransform)	eax, ecx, edx	0x4	根据动画变换中的文本，;分析读取附着轨道的动画名称、轨道名称、动画速率和循环类型并写入 theAttacherInfo 中。
473EB0	Reanimation::AttacherSynchWalkSpeed;(Reanimation* theAttachReanim, int theTrackIndex, esi = Reanimation* this)	eax, ecx, edx		根据附属动画及附着的轨道的当前状态，计算并赋值附属动画的速率及附属效果的横向变换等。;原版中，当且仅当附属动画的定义速率为默认值、存在地面轨道且播放行走动作时，此函数才会被调用。
4740B0	Reanimation::UpdateAttacherTrack(int theTrackIndex, Reanimation* this)	eax, ecx, edx		更新附着轨道，并根据轨道变换的文本相应更新其附属动画的类型、动作、速率和颜色等。
4745B0	Reanimation::IsAnimPlaying(edx = const char* theTrackName, esi = Reanimation* this)	al = 0(否) | 1(是); ecx, edx		判断动画是否正在播放 theTrackName 轨道上的动作。
4745F0	Reanimation::FindSubReanim(ReanimationType theReanimType, ecx = Reanimation* this)	eax = Reanimation*? aSubReanim; ecx, edx		从动画自身及其每条轨道的附属动画中寻找首个类型为 theReanimType 的动画。是一个递归调用的函数。
474650	DataArray<Reanimation>::DataArrayDispose(eax = DataArray<Reanimation>* this)	eax, ecx, edx		销毁动画数据数组中的所有动画并回收其占用的内存区域，然后释放动画数组占用的内存空间。
474680	DataArray<Reanimation>::DataArrayAlloc(esi = DataArray<Reanimation>* this)	eax = Reanimation* aReanim; ecx, edx		初始化创建动画，在动画数据数组中申请该动画的内存区域。
474700	Sexy::ExtractResourcesByName(const char* theName, ResourceManager* theManager)	al = bool 是否成功; ecx, edx	0x8	根据资源组的名称，提取相应组中的全部资源。【函数指针】[6A9EF8]
474A60	Sexy::ExtractDelayLoad_AlmanacResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、图鉴中使用的相关贴图。
475110	Sexy::ExtractDelayLoad_AwardScreenResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、奖励·便签界面中使用的相关贴图。
4751D0	Sexy::ExtractDelayLoad_Background1Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、白天草坪场景中使用的相关贴图。
475340	Sexy::ExtractDelayLoad_Background2Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、黑夜草坪场景中使用的相关贴图。
4754B0	Sexy::ExtractDelayLoad_Background3Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、白天泳池场景中使用的相关贴图。
475620	Sexy::ExtractDelayLoad_Background4Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、黑夜泳池场景中使用的相关贴图。
475840	Sexy::ExtractDelayLoad_Background5Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、白天屋顶场景中使用的相关贴图。
475950	Sexy::ExtractDelayLoad_Background6Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、月夜屋顶场景中使用的相关贴图。
475A60	Sexy::ExtractDelayLoad_BackgroundUnsoddedResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、白天不完整草坪的相关贴图（冒险模式初期及无草皮之地关卡使用）。
475BD0	Sexy::ExtractDelayLoad_ChallengeScreenResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、小游戏界面中使用的相关贴图。
475F00	Sexy::ExtractDelayLoad_CreditsResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、制作人名单及 MV 中使用的相关贴图。
476370	Sexy::ExtractDelayLoad_GreenHouseGardenResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、禅境花园温室中使用的相关贴图。
476430	Sexy::ExtractDelayLoad_GreenHouseOverlayResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、温室光效使用的相关贴图。
4764F0	Sexy::ExtractDelayLoad_MushroomGardenResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、禅境花园蘑菇园中使用的相关贴图。
4765B0	Sexy::ExtractDelayLoad_StoreResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、商店中使用的相关贴图。
476E80	Sexy::ExtractDelayLoad_TreeOfWisdomResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、智慧树场景中使用的相关贴图。
476E90	Sexy::ExtractDelayLoad_ZombieFinalNoteResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、冒险模式 5-9 关卡掉落的便签的文本贴图。
476F50	Sexy::ExtractDelayLoad_ZombieNoteResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的僵尸便签相关贴图。
477010	Sexy::ExtractDelayLoad_ZombieNote1Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、冒险模式 1-9 关卡掉落的便签的文本贴图。
4770D0	Sexy::ExtractDelayLoad_ZombieNote2Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、冒险模式 2-9 关卡掉落的便签的文本贴图。
477190	Sexy::ExtractDelayLoad_ZombieNote3Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、冒险模式 3-9 关卡掉落的便签的文本贴图。
477250	Sexy::ExtractDelayLoad_ZombieNote4Resources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、冒险模式 4-9 关卡掉落的便签的文本贴图。
477310	Sexy::ExtractDelayLoad_ZombieNoteHelpResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、帮助中的便签的文本贴图。
4773D0	Sexy::ExtractDelayLoad_ZombiquariumResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取延迟加载的、水族馆场景中使用的相关贴图。
477540	Sexy::ExtractInitResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取初始界面中使用的 PopCap Logo 等贴图。
4776B0	Sexy::ExtractLoaderBarResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		提取标题界面中使用的 PVZ Logo 及进度条相关的贴图。
4779E0	Sexy::ExtractLoadingFontsResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		启动时调用，提取游戏使用的字体资源。
477F50	Sexy::ExtractLoadingImagesResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		启动时调用，提取游戏使用的大部分贴图。
47D9A0	Sexy::ExtractLoadingSoundsResources(ecx = ResourceManager* theManager)	al = bool 是否成功; ecx, edx		启动时调用，提取游戏使用的音效资源。
47FBC0	GetIdByVariable(void* theVariable)	eax = ResourceId aResourceId; ecx, edx	0x4	根据给定的资源的值或指针，在资源编号映射容器中寻找该资源对应的编号（未找到时返回 0x272）。;若调用时全局变量 gNeedRecalcVariableToIdMap 为 true，则会在寻找前先重置上述映射容器。
47FD10	std::_Tree<std::_Tmap_traits<std::string, int>>::find;(ebx = const std::string& _Keyval, _Out_ std::_Tree<std::_Tmap_traits<std::string, int>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<<std::string, int>>* this)	eax = &&_Ret; ecx, edx		在字符串向整数的映射容器中寻找 _Keyval 字符串对应的整数值。;若找到，则返回指示该对组所在位置处的迭代器否则，返回相当于 map.end() 的迭代器。
47FD90	std::map<int, int>::operator[](ebx = const int& _Keyval)	eax = int& _Val; ecx, edx		<对资源编号映射容器特化>在资源编号映射容器中寻找 _Keyval 对应的值，返回对该值的引用。;若容器中原先不存在 _Keyval 键，则向容器中新添加一个 (_Keyval, 0) 对组。
47FE10	std::map<int, int>::clear()	eax, ecx, edx		<对资源编号映射容器特化>清除资源编号映射容器红黑树的所有节点并释放这些节点占用的内存空间。
47FE50	std::_Tree<std::_Tmap_traits<int, int>>::find;(edi = const int& _Keyval, ebx = _Out_ std::_Tree<std::_Tmap_traits<int, int>>::iterator&& _Ret)	eax = &&_Ret; ecx, edx		<对资源编号映射容器特化>在资源编号映射容器中寻找 _Keyval 键所在位置，返回对应位置处的迭代器。;当容器中不存在 _Keyval 键时，返回 aMap.end()。
47FED0	std::less<std::string>::operator()(eax = const std::string& _Right, ecx = const std::string& _Left)	al = bool _Less; ecx, edx		比较 _Left 和 _Right 字符串，返回表示 _Left 是否小于 _Right 的逻辑值。
47FF00	std::_Tree<std::_Tmap_traits<std::string, int>>::~_Tree<std::_Tmap_traits<std::string, int>>;(eax = std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax, ecx, edx		销毁并释放字符串向整数的映射红黑树。
47FF40	std::_Tree<std::_Tmap_traits<int, int>>::insert(std::_Tree<std::_Tmap_traits<int, int>>::iterator _Where, ;                                          const std::pair<int, int>& _Val, ;                                          _Out_ std::_Tree<std::_Tmap_traits<int, int>>::iterator&& _Ret)	eax = &&_Ret; ecx, edx		<对资源编号映射容器特化>;向资源编号映射红黑树中的指定位置添加一个对组 _Val，返回表示插入的键值在红黑树中的位置的迭代器。
480110	std::_Tree<std::_Tmap_traits<int, int>>::_Find_lower_bound;(const int& _Keyval, eax = _Out_ std::_Tree<std::_Tmap_traits<int, int>>::iterator&& _Result)	eax = &&_Result; ecx, edx		<对资源编号映射容器特化>根据红黑树的有序性，在资源编号映射红黑树中寻找可以放置 _Keyval 的最底层的一个节点，返回表示该节点所在位置的迭代器。
480150	std::_Tree<std::_Tmap_traits<int, int>>::~_Tree<std::_Tmap_traits<int, int>>()	eax, ecx, edx		<对资源编号映射容器特化>销毁并释放资源编号映射红黑树。
4801A0	std::_Tree<std::_Tmap_traits<std::string, int>>::insert;(const std::pair<std::string, int>& _Val, ; ebx = _Out_ std::pair<std::_Tree<std::_Tmap_traits<std::string, int>>::iterator, bool>&& _Ret, ; std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax = &&_Ret; ecx, edx		向字符串向整数的映射容器中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
480300	std::_Tree<std::_Tmap_traits<std::string, int>>::erase;(std::_Tree<std::_Tmap_traits<std::string, int>>::iterator _Last, ; std::_Tree<std::_Tmap_traits<std::string, int>>::iterator _First, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, int>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax = &&_Ret; ecx, edx		移除字符串向整数的映射红黑树从 _First 至 _Last 之间的所有节点。
4803D0	std::_Tree<std::_Tmap_traits<std::string, int>>::_Insert;(const std::pair<std::string, int>& _Val, ecx = std::_Tree_nod<std::_Tmap_traits<std::string, int>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<std::string, int>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax = &&_Ret; ecx, edx		在字符串向整数的映射红黑树中的指定节点下添加一个新的节点，返回表示插入的键值在红黑树中的位置的迭代器。
4805C0	std::_Tree<std::_Tmap_traits<std::string, int>>::_Lbound;(ecx = const std::string& _Keyval, eax = std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax = _Node* _Bound; ecx, edx		根据红黑树的有序性，在字符串向整数的映射红黑树中寻找可以放置 _Keyval 的最底层的一个节点。
480650	std::_Tree<std::_Tmap_traits<int, int>>::insert;(ebx = const std::pair<int, int>& _Val, _Out_ std::pair<std::_Tree<std::_Tmap_traits<int, int>>::iterator, bool>&& _Ret)	eax = &&_Ret; ecx, edx		<对资源编号映射容器特化>;向资源编号映射容器中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
480710	std::_Tree<std::_Tmap_traits<int, int>>::erase;(std::_Tree<std::_Tmap_traits<int, int>>::iterator _Last, std::_Tree<std::_Tmap_traits<int, int>>::iterator _First, ; _Out_ std::_Tree<std::_Tmap_traits<int, int>>::iterator&& _Ret)	eax = &&_Ret; ecx, edx		<对资源编号映射容器特化>;移除资源编号映射红黑树从 _First 至 _Last 之间的所有节点。
4807D0	std::_Tree<std::_Tmap_traits<int, int>>::_Insert;(const std::pair<int, int>& _Val, edi = std::_Tree_nod<std::_Tmap_traits<int, int>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<int, int>>::iterator&& _Ret)	eax = &&_Ret; ecx, edx		<对资源编号映射容器特化>;在资源编号映射红黑树中的指定节点下添加一个新的节点，返回表示插入的键值在红黑树中的位置的迭代器。
4809F0	std::_Tree<std::_Tmap_traits<std::string, int>>::erase;(std::_Tree<std::_Tmap_traits<std::string, int>>::iterator _Where, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, int>>::iterator&& _Ret, ; std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax = &&_Ret; ecx, edx		移除字符串向整数的映射红黑树的 _Where 处的节点。
480CD0	std::_Tree<std::_Tmap_traits<<std::string, int>>::_Buynode()	eax = _Node* _Pnode; ecx, edx		创建一个字符串向整数的映射红黑树的节点，令该节点的子节点和父节点指针为空指针，并初始化该节点的颜色。
480D10	std::_Tree<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Buynode;(char _Carg, const std::pair<std::string, PlayerInfo>& _Val, ; std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Rarg, ; std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Parg, ; std::_Tree_nod<std::_Tmap_traits<std::string, PlayerInfo, Sexy::StringLessNoCase>>::_Node* _Larg)	eax = std::_Tree_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符串向存档的映射容器的节点，赋值该节点的颜色为 _Carg，;并令该节点的父节点指针和左、右子节点指针分别指向 _Parg、 _Larg 和 _Rarg，;同时赋值该节点处的对组值为 _Val。
480DC0	std::_Tree<std::_Tmap_traits<int, int>>::erase;(std::_Tree<std::_Tmap_traits<int, int>>::iterator _Where, _Out_ std::_Tree<std::_Tmap_traits<int, int>>::iterator&& _Ret)	eax = &&_Ret; ecx, edx		<对资源编号映射容器特化>;移除资源编号映射红黑树的 _Where 处的节点。
481090	std::_Tree<std::_Tmap_traits<int, int>>::_Lrotate(ecx = std::_Tree_nod<std::_Tmap_traits<int, int>>* _Wherenode)	eax, ecx, edx		<对资源编号映射容器特化>对资源编号映射红黑树的一个节点进行左旋转。
4810E0	std::_Tree<std::_Tmap_traits<int, int>>::_Rrotate(ecx = std::_Tree_nod<std::_Tmap_traits<int, int>>* _Wherenode)	eax, ecx, edx		<对资源编号映射容器特化>对资源编号映射红黑树的一个节点进行右旋转。
481130	std::_Tree<std::_Tmap_traits<<Image*, Image*>>::_Buynode()	eax = _Node* _Pnode; ecx, edx		创建一个贴图指针向贴图指针的映射红黑树的节点，;令该节点的子节点和父节点指针为空指针，并初始化该节点的颜色。
481170	std::_Tree<std::_Tmap_traits<std::string, int>>::_Erase;(std::_Tree_nod<std::_Tmap_traits<std::string, int>>::_Node* _Rootnode, ; ecx = std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax, ecx, edx		移除并释放字符串向整数的映射容器的红黑树的一个节点及该节点的所有右节点。
4811D0	std::_Tree<std::_Tmap_traits<std::string, int>>::_Max;(eax = std::_Tree_nod<std::_Tmap_traits<std::string, int>>::_Node* _Pnode)	eax = _Node* _Maxnode; ecx, edx		取得字符串向整数的映射红黑树从 _Pnode 开始最右侧的一个节点。
4811F0	std::_Tree<std::_Tmap_traits<std::string, int>>::_Min;(eax = std::_Tree_nod<std::_Tmap_traits<std::string, int>>::_Node* _Pnode)	eax = _Node* _Minnode; ecx, edx		取得字符串向整数的映射红黑树从 _Pnode 开始最左侧的一个节点。
481210	std::_Tree<std::_Tmap_traits<std::string, int>>::const_iterator::_Dec;(esi = std::_Tree<std::_Tmap_traits<std::string, int>>::const_iterator* this)	eax, ecx, edx		字符串向整数的映射容器的常量迭代器自减。
481290	std::_Tree<std::_Tmap_traits<std::string, int>>::const_iterator::_Inc;(esi = std::_Tree<std::_Tmap_traits<std::string, int>>::const_iterator* this)	eax, ecx, edx		字符串向整数的映射容器的常量迭代器自增。
481300	std::_Tree<std::_Tmap_traits<int, int>>::const_iterator::_Inc;(esi = std::_Tree<std::_Tmap_traits<int, int>>::const_iterator* this)	eax, ecx, edx		整数向整数的映射容器的常量迭代器自增。
481370	std::_Allocate<std::_Tree_nod<Image*, Image*>::_Node>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个贴图指针映射容器的红黑树的节点所需要的内存空间，单个节点占用的内存大小为 0x18。;当 _Count 个节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
4813D0	SaveGameContext::SyncBytes(esi = int theReadSize, eax = void* theDest, ecx = SaveGameContext* this)	eax, ecx, edx		[读取模式下]从缓冲区中读取 theDest 的长度，若读取的长度不为 theReadSize 或缓冲区长度不足则失败。;读取成功时，将读取的 theReadSize 个字节依次写入 theDest 指向的地址;读取失败时，以 theReadSize 个 0 填充 theDest。;[写入模式下]先后将长度（theReadSize）和内容（theDest）的前 theReadSize 个字节写入缓冲区中。
481470	SaveGameContext::SyncInt(esi = int& theInt, eax = SaveGameContext* this)	eax, ecx, edx		[读取模式下]先检测存档环境的缓冲区剩余长度是否足够一个长整数（4 个字节），若长度不足则失败。;若失败，则赋值 theInt 为 0赋值，从缓冲区中读取一个长整数，并以读取的长整数赋值 theInt。;[写入模式下]将长整数 theInt 写入存档环境的缓冲区中。
4814C0	SaveGameContext::SyncReanimationDef;(eax = ReanimatorDefinition*& theDefinition, ecx = SaveGameContext* this)	eax, ecx, edx		[读取模式下]读取整数型的动画类型，若动画类型不存在则将 theDefinition 赋值为空指针，若动画类型非法则失败。否则，加载该动画类型的定义数据，并以全局动画定义数组中定义数据的指针赋值 theDefinition。;[写入模式下]寻找 theDefinition 对应的动画类型并以整数型写入缓冲区，若未找到则写入 -1 表示类型不存在。
481560	SaveGameContext::SyncParticleDef;(eax = TodParticleDefinition*& theDefinition, ecx = SaveGameContext* this)	eax, ecx, edx		[读取模式下]读取整数型的粒子系统类型，若类型不存在则将 theDefinition 赋值为空指针，若类型非法则失败。;否则，以全局粒子系统定义数组中该粒子系统类型的定义数据的指针赋值 theDefinition。;[写入模式下]寻找 theDefinition 对应的粒子系统类型并以整数型写入缓冲区，;若未找到则写入 -1 表示类型不存在。
4815F0	SaveGameContext::SyncTrailDef;(eax = TrailDefinition*& theDefinition, ecx = SaveGameContext* this)	eax, ecx, edx		[读取模式下]读取整数型的轨迹类型，若类型不存在则将 theDefinition 赋值为空指针，若类型非法则失败。;否则，以全局轨迹定义数组中该轨迹类型的定义数据的指针赋值 def。;[写入模式下]寻找 theDefinition 对应的轨迹类型并以整数型写入缓冲区，若未找到则写入 -1 表示类型不存在。
481690	SaveGameContext::SyncImage(edi = Image*& theImage, ebx = SaveGameContext* this)	eax, ecx, edx		[读取模式下]从存档环境的缓冲区中读取一个长整数，以该长整数作为资源编号获取相应资源赋值给 theImage。;[写入模式下]根据给定的 theImage 获取对应的资源编号，并将获取到的编号以长整数写入存档环境的缓冲区中。
481710	SyncDataIDList;(eax = TodAllocator* theAllocator, SaveGameContext& theContext, ecx = TodList<unsigned int>* theDataIDList)	eax, ecx, edx	0x4	[读取模式下]读取整数型的链表节点数量，然后依次读取相应数量的整数并添加至链表末尾。;[写入模式下]写入整数型的链表节点数量，然后依次以整数型写入链表每个节点的数据。
4817C0	SyncParticleEmitter(eax = SaveGameContext& theContext, TodParticleEmitter* theParticleEmitter, ;                    TodParticleSystem* theParticleSystem)	eax, ecx, edx	0x8	存档环境同步粒子发射器 theParticleEmitter 的定义数据、覆写贴图和粒子编号链表。
481880	SyncParticleSystem;(ebx = SaveGameContext& theContext, edi = TodParticleSystem* theParticleSystem, Board* theBoard)	eax, ecx, edx	0x4	存档环境同步粒子系统 theParticleSystem 的定义数据、发射器编号链表和系统中的每个发射器。
4818F0	SyncReanimation(eax = SaveGameContext& theContext, Reanimation* theReanimation, Board* theBoard)	eax, ecx, edx	0x8	存档环境同步动画 theReanimation 的定义数据和每一条轨道实例的数据。
4819D0	SyncBoard(Board* theBoard, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	[读取模式下]从存档环境的缓冲区中读取并赋值关卡的游戏数据。;[写入模式下]将关卡的所有游戏数据写入存档环境的缓冲区中。
481CE0	FixBoardAfterLoad(edi = Board* theBoard)	eax, ecx, edx		读档后，重新赋值关卡内各对象的 mApp 和 mBoard 指针以及音乐的 mApp 和 mMusicInterface 指针。
481FE0	LawnLoadGame(const std::string& theFilePath, ecx = Board* theBoard)	al = bool 是否成功; ecx, edx	0x4	读取游戏存档。通过 theFilePath 指定需要写入的存档文件的完整路径及文件名。
4820C0	SaveGameContext::~SaveGameContext(ecx = SaveGameContext& theContext)	eax, ecx, edx		销毁存档环境，销毁并释放缓冲区。
4820D0	LawnSaveGame(const std::string& theFilePath, edi = Board* theBoard)	al = bool 是否成功; ecx, edx	0x4	保存游戏存档。通过 theFilePath 指定需要写入的存档文件的完整路径及文件名。
482190	SyncDataArray<Zombie>(DataArray<Zombie>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步僵尸数据数组。
482280	SyncDataArray<Plant>(DataArray<Plant>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步植物数据数组。
482370	SyncDataArray<Projectile>(DataArray<Projectile>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步子弹数据数组。
482460	SyncDataArray<Coin>(DataArray<Coin>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步物品数据数组。
482550	SyncDataArray<LawnMower>(DataArray<LawnMower>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步小推车数据数组。
482650	SyncDataArray<GridItem>(DataArray<GridItem>& theDataArray, eax = SaveGameContext& theContext);SyncDataArray<Trail>(DataArray<Trail>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步场地物品/轨迹数据数组。
482740	SyncDataArray<TodParticleSystem>;(DataArray<TodParticleSystem>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步粒子系统数据数组。
482830	SyncDataArray<TodParticleEmitter>;(DataArray<TodParticleEmitter>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步粒子发射器数据数组。
482920	SyncDataArray<TodParticle>(DataArray<TodParticle>& theDataArray, eax = SaveGameContext& theContext);SyncDataArray<Reanimation>(DataArray<Reanimation>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步粒子/动画数据数组。
482A10	SyncDataArray<Attachment>(DataArray<Attachment>& theDataArray, eax = SaveGameContext& theContext)	eax, ecx, edx	0x4	存档环境同步附件数据数组。
482B00	ImitaterDialog::ImitaterDialog(ImitaterDialog* this)	eax = *this; ecx, edx		初始化创建模仿者对话。需要一个大小为 0x174 的内存区域用于构造 this。
482CE0	ImitaterDialog::`scalar deleting destructor'(unsigned int flags, ecx = ImitaterDialog* this)	eax = *this; ecx, edx		删除模仿者对话，删除其鼠标悬浮标签，当 flags 的第 0 位置 1 时会额外释放模仿者对话本身占用的内存空间。		【虚函数】[[[(ImitaterDialog*)]+0]+0]
482D30	ImitaterDialog::SeedHitTest(int y, int x, esi = ImitaterDialog* this)	eax = SeedType aSeedType; ecx, edx		选卡界面模仿者对话获取当前鼠标上的卡牌类型，若鼠标不位于任何一张模仿者卡牌上则返回 -1。
482DD0	ImitaterDialog::UpdateCursor(eax = ImitaterDialog* this)	eax, ecx, edx		模仿者对话更新鼠标光标样式。
482E50	ImitaterDialog::Update(ecx = ImitaterDialog* this)	eax, ecx, edx		模仿者对话更新，并更新其鼠标悬浮标签和鼠标光标样式。		【虚函数】[[[(ImitaterDialog*)]+0]+58]
482E70	ImitaterDialog::GetSeedPosition(int& y, int& x, ecx = int theIndex, eax = ImitaterDialog* this)	eax, ecx, edx		获取模仿者对话中第 theIndex 张模仿者植物卡牌的横、纵坐标，并分别赋值给 x 和 y。
482EC0	ImitaterDialog::Draw(Graphics* g, ecx = ImitaterDialog* this)	eax, ecx, edx		绘制选卡界面模仿者对话窗口，同时绘制其中的所有模仿者卡牌及鼠标悬浮标签。		【虚函数】[[[(ImitaterDialog*)]+0]+68]
483030	ImitaterDialog::ShowToolTip(edi = ImitaterDialog* this)	eax, ecx, edx		模仿者对话中，更新提示标签的显示与隐藏，若显示则同时更新其文本内容与位置等。
483270	ImitaterDialog::MouseDown(int theClickCount, int y, int x, ecx = ImitaterDialog* this)	eax, ecx, edx		模仿者对话中鼠标按下，若鼠标位于可用的模仿者选卡上，则在选卡界面选择该模仿者植物并结束模仿者对话。		【虚函数】[[[(ImitaterDialog*)]+0]+D8]
483370	ImitaterDialog::MouseUp(int theClickCount, int y, int x, ecx = ImitaterDialog* this)	此函数不改变任何寄存器		【废弃函数】模仿者对话鼠标松开。		【虚函数】[[[(ImitaterDialog*)]+0]+E0]
483380	SeedChooserScreen::SeedChooserScreen(SeedChooserScreen* this)	eax = *this; ecx, edx		初始化创建选卡界面，创建并设定各按钮和选卡及鼠标悬浮标签，同时选定多周目冒险模式的戴夫选卡。;需要一个大小为 0xD40 的内存区域用于构造 this。
483F50	SeedChooserScreen::`scalar deleting destructor'(unsigned int flags, ecx = SeedChooserScreen* this)	eax = *this; ecx, edx		删除选卡界面，当 flags 的第 0 位置 1 时会额外释放选卡界面本身占用的内存空间。		【虚函数】[[[(SeedChooserScreen*)]+0]+0]
483F70	SeedChooserScreen::CrazyDavePickSeeds(SeedChooserScreen* this)	eax, ecx, edx		在当前可用的植物中随机选取 3 种，将其选卡作为戴夫选卡放入卡槽中。
484220	SeedChooserScreen::Has7Rows(SeedChooserScreen* this)	al = 0(否) | 1(是); ecx, edx		判断选卡界面是否有 7 行卡牌（加入紫卡）。加入紫卡后，选卡的行距会被压缩以保证界面中足够放置所有选卡。
484400	SeedChooserScreen::GetSeedPositionInChooser;(int& y, ebx = int& x, ecx = int theIndex, edi = SeedChooserScreen* this)	eax, ecx, edx		选卡界面中，获取选卡框中第 theIndex 张卡牌的横、纵坐标，并分别赋值给 x 和 y。
484480	SeedChooserScreen::GetSeedPositionInBank;(int& y, int& x, edi = int theIndex, esi = SeedChooserScreen* this)	eax, ecx, edx		选卡界面中，获取卡槽中第 theIndex 张卡牌的横、纵坐标，并分别赋值给 x 和 y。
4844D0	SeedChooserScreen::~SeedChooserScreen(ecx = SeedChooserScreen* this)	eax, ecx, edx		销毁选卡界面，删除界面内的各按钮和鼠标悬浮标签。
4845E0	SeedChooserScreen::SeedNotRecommendedToPick(esi = SeedType theSeedType, SeedChooserScreen* this)	eax = unsigned int aNotRecFlags; ecx, edx		选卡界面中，判断当前是否不推荐携带 theSeedType 选卡，并返回不推荐携带的原因。;在41CC60的函数的基础上，若已选中咖啡豆，则不再不推荐携带夜行性植物。
484,620	SeedChooserScreen::SeedNotAllowedToPick(eax = SeedType theSeedType)	al = 0(可用) | 1(禁用)		判断 theSeedType 卡牌是否在谁笑到最后关卡被禁用。
484640	SeedChooserScreen::SeedNotAllowedDuringTrial(ebx = SeedType theSeedType, eax = SeedChooserScreen* this)	al = 0(可用) | 1(禁用); ecx, edx		判断 theSeedType 卡牌是否在试玩模式下被禁用。试玩模式下， 禁用窝瓜和三线射手。
484690	SeedChooserScreen::Draw(Graphics* g, ecx = SeedChooserScreen* this)	eax, ecx, edx		绘制选卡界面。		【虚函数】[[[(SeedChooserScreen*)]+0]+68]
484C30	SeedChooserScreen::UpdateViewLawn(SeedChooserScreen* this)	eax, ecx, edx		更新查看草坪过程及过程中的提示字幕和界面移动等。
484FD0	SeedChooserScreen::LandFlyingSeed(eax = ChosenSeed& theChosenSeed, ecx = SeedChooserScreen* this)	eax, ecx, edx		将由选卡框移向卡槽或由卡槽移向选卡框的选卡重置至其目标位置，并更新选卡及选卡界面的相关数据。
485040	SeedChooserScreen::UpdateCursor(eax = SeedChooserScreen* this)	eax, ecx, edx		选卡界面更新鼠标光标样式。
4851A0	SeedChooserScreen::Update(ecx = SeedChooserScreen* this)	eax, ecx, edx		选卡界面总更新，包括运动中的选卡、各个按钮、鼠标悬浮标签、查看草坪过程、鼠标样式等的更新。		【虚函数】[[[(SeedChooserScreen*)]+0]+58]
485340	SeedChooserScreen::DisplayRepickWarningDialog(ecx = SeedChooserScreen* this)	al = bool 是否确认开始关卡; ecx, edx		当玩家当前选卡组合不合理或可能导致无法过关时，弹出是否确定继续的警告弹窗。
485370	SeedChooserScreen::FlyersAreComming(eax = SeedChooserScreen* this)	al = 0(否) | 1(是); ecx, edx		判断当前关卡的出怪列表中是否含有气球僵尸。
4853D0	SeedChooserScreen::FlyProtectionCurrentlyPlanted(edi = SeedChooserScreen* this)	al = 0(否) | 1(是); ecx, edx		判断当前草坪上是否存在能击杀气球僵尸的植物（猫尾草或仙人掌）。
485420	SeedChooserScreen::CheckSeedUpgrade;(ecx = SeedType theSeedTypeFrom, SeedType theSeedTypeTo, SeedChooserScreen* this)	al = bool 是否继续; ecx, edx		用于选卡界面检查是否出现携带紫卡植物而未携带对应的原植物的情况。;非生存模式下，若玩家携带 theSeedTypeTo 植物而未携带 theSeedTypeFrom 植物，则弹出是否继续的警告弹窗。;若不存在上述情况，或玩家选择无视警告继续开始游戏，则返回“是”，否则返回“否”。
485600	SeedChooserScreen::OnStartButton(eax = SeedChooserScreen* this)	eax, ecx, edx		选卡界面点击开始游戏按钮时，针对不合理的选卡依次进行弹窗确认，若确认无误则结束选卡。
4859B0	SeedChooserScreen::PickRandomSeeds(SeedChooserScreen* this)	eax, ecx, edx		选卡界面点击调试试玩按钮时，以随机选卡填充卡槽，立即完成所有选卡的移动，然后结束选卡。
485BB0	SeedChooserScreen::ButtonDepress(int theId, ecx = SeedChooserScreen* this)	eax, ecx, edx		选卡界面中按下的游戏按钮松开时，触发相应游戏按钮的点击事件。		【虚函数】[[[(SeedChooserScreen*)]+0]+11C]
485D80	SeedChooserScreen::SeedHitTest(int y, int x, esi = SeedChooserScreen* this)	eax = SeedType aSeedType; ecx, edx		选卡界面获取当前鼠标上的卡牌类型，若鼠标不位于任何一张卡牌上则返回 -1。
485E20	SeedChooserScreen::FindSeedInBank(int theIndexInBank, esi = SeedChooserScreen* this)	eax = SeedType aSeedType; ecx, edx		选卡界面中，获取位于卡槽中第 theIndexInBank 格的选卡的植物类型，若该格不存在选卡则返回 -1。
485E90	SeedChooserScreen::ClickedSeedInBank(ChosenSeed& theChosenSeed, eax = SeedChooserScreen* this)	eax, ecx, edx		选卡界面中，鼠标点击位于卡槽上的选卡将其移下卡槽，设置相关选卡的运动，并禁用开始按钮。
486030	SeedChooserScreen::ClickedSeedInChooser(ChosenSeed& theChosenSeed, eax = SeedChooserScreen* this)	eax, ecx, edx		选卡界面中，鼠标点击位于选卡框中的选卡将其移上卡槽，若移动后卡槽已满则将开始按钮设为可用。
486150	SeedChooserScreen::ShowTooltip(SeedChooserScreen* this)	eax, ecx, edx		选卡界面中，更新提示标签的显示与隐藏，若显示则同时更新其文本内容与位置等。
486600	SeedChooserScreen::CancelLawnView(ecx = SeedChooserScreen* this)	eax		选卡界面取消查看草坪。
486630	SeedChooserScreen::MouseUp(int theClickCount, int y, int x, ecx = SeedChooserScreen* this)	eax, ecx, edx		选卡界面鼠标松开，处理左键单击时菜单按钮、开始按钮、图鉴按钮和商店按钮的点击事件。		【虚函数】[[[(SeedChooserScreen*)]+0]+E0]
4866E0	SeedChooserScreen::UpdateImitaterButton(SeedChooserScreen* this)	eax, ecx, edx		根据模仿者选卡的存在与否及选卡状态，设置模仿者按钮的可见、可用与否。
486770	SeedChooserScreen::MouseDown(int theClickCount, int y, int x, ecx = SeedChooserScreen* this)	eax, ecx, edx		选卡界面鼠标按下，处理各按钮的鼠标按下音效的播放、僵尸按下时的图鉴显示、选卡按下等事件。		【虚函数】[[[(SeedChooserScreen*)]+0]+D8]
486CE0	SeedChooserScreen::PickedPlantType(edi = SeedType theSeedType, ecx = SeedChooserScreen* this)	al = bool isPicked; ecx, edx		选卡界面中，判断 theSeedType 植物的选卡是否已被选择。此函数只会遍历模仿者及之前的卡牌。
486D20	SeedChooserScreen::CloseSeedChooser(ebx = SeedChooserScreen* this)	eax, ecx, edx		关闭选卡界面，根据选择的选卡设置卡槽中每张卡牌的类型及冷却状态等，并在关卡过场中结束选卡阶段。
486E80	SeedChooserScreen::KeyDown(KeyCode theKey, ecx = SeedChooserScreen* this)	eax, ecx, edx		选卡界面中键盘按键按下，进行游戏关卡内的按键检测。		【虚函数】[[[(SeedChooserScreen*)]+0]+C0]
486EA0	SeedChooserScreen::KeyChar(char theChar, ecx = SeedChooserScreen* this)	eax, ecx, edx		选卡界面输入 theChar 字符，触发按键对应的操作。		【虚函数】[[[(SeedChooserScreen*)]+0]+BC]
486F10	SeedChooserScreen::UpdateAfterPurchase(SeedChooserScreen* this)	eax, ecx, edx		从商店购物完成返回选卡界面时，刷新所有选卡的运动情况及开始按钮和模仿者按钮的状态。
487070	SeedPacket::PickNextSlotMachineSeed(SeedPacket* this)	eax, ecx, edx		选取并赋值老虎机下一个出现的卡牌内容。
487190	SeedPacket::FlashIfReady(esi = SeedPacket* this)	eax, ecx, edx		当未开启免费种植且卡牌可用时，创建卡牌闪光特效（传送带关卡除外）并设置点选卡牌相关的教程状态。
487250	SeedPacket::Update(eax = SeedPacket* this)	eax, ecx, edx		卡牌的更新，包括卡牌冷却时间的更新和老虎机转动的更新等。
487380	SeedPacketDrawSeed(float theScale, float theOffsetY, float theOffsetX, ebx = SeedType theImitaterType, ;                   SeedType theSeedType, float y, float x, esi = Graphics* g)	eax, ecx, edx		绘制卡牌内容的贴图。当卡牌内容为“seed_packet.png”中的植物且 g 的横向拉伸 ≤ 1 时，;参数 theOffsetX、theOffsetY 和 theScale 无实用，贴图绘制时的缩放采用与 g 相同的拉伸值。
4876F0	DrawSeedPacket(bool theUseCurrentCost, bool theDrawCost, ecx = int theGrayness, float thePercentDark, ;               SeedType theImitaterType, SeedType theSeedType, float y, float x, Graphics* g)	eax, ecx, edx	0x20	根据给定数据绘制卡牌贴图。其中，theGrayness 为卡牌的整体亮度，其取值范围为 [0, 255] 的整数;thePercentDark 用于冷却时间的描绘，表示从顶部开始的阴影部分占整张卡牌的比例，其取值范围为 [0, 1];theDrawCost 指定了是否绘制卡牌价格，theUseCurrentCost 指定了对于紫卡植物绘制的价格是否为当前价格。
488220	SeedPacket::Draw(Graphics* g, SeedPacket* this)	eax, ecx, edx		绘制卡牌。先计算相关数据，然后使用 DrawSeedPacket 绘制卡牌的贴图。
488500	SeedPacket::CanPickUp(esi = SeedPacket* this)	al = 0(否) | 1(是); edx		判断卡牌当前是否可用。包括暂停与否、阳光数量是否充足、紫卡条件是否满足等判断。
488590	SeedPacket::MouseDown(SeedPacket* this)	eax, ecx, edx		鼠标点击卡牌，包括普通卡牌的点选、创建上位音效和特殊卡牌的点击事件。
488EC0	SeedPacket::WasPlanted(eax = SeedPacket* this)	eax, ecx, edx		卡牌被使用后，根据卡牌类型和当前关卡状态等执行不同的操作（移除、刷新、冷却等）。
488F90	SeedPacket::MouseHitTest;(edi = HitResult* theHitResult, ebx = int theY, esi = int theX, eax = SeedPacket* this)	al = bool isOnSeedPacket; ecx, edx		卡牌的鼠标检测，其中 theX 和 theY 使用以卡牌所在卡槽为参考的相对坐标。;若 (theX, theY) 位于物品上，则赋值 *theHitResult = {this, 4}，否则赋值 *theHitResult = {0, 0}。
489000	SeedBank::SeedBank(ecx = SeedBank* this)	eax = *this; ecx, edx		初始化卡槽及其中每一张卡牌的矩形、图层、指针等基础数据。
489630	SeedBank::Draw(Graphics* g, SeedBank* this)	eax, ecx, edx		绘制卡槽（或传送带、老虎机）及其中每一张卡牌。
489970	SeedBank::MouseHitTest(eax = HitResult* theHitResult, int y, int x, SeedBank* this)	Bool al = isOnAnySeedPacket, ecx, edx = (辅助计算残留)		卡槽的鼠标检测，将绝对坐标转化为相对坐标后分别对其中每一张卡牌调用卡牌的鼠标检测函数。;若 (x, y) 位于某一卡牌上，则赋值 *theHitResult = {该卡牌指针, 4}，否则赋值 *theHitResult = {0, 0}。
489A20	SeedBank::ContainsPoint(esi = int theY, edx = int theX, eax = SeedBank* this)	eax = 0(否) | 1(是); ecx		判断点 (theX, theY) 是否位于卡槽内。
489A50	SeedBank::AddSeed(SeedType theSeedType, eax = SeedBank* this)	eax, ecx, edx		传送带创建新出现的卡牌，卡牌内容为 theSeedType。
489AC0	SeedBank::RemoveSeed(edx = int theIndex, esi = SeedBank* this)	eax, ecx, edx		传送带中的卡牌被使用，移除第 theIndex 张卡牌。
489B20	SeedBank::GetNumSeedsOnConveyorBelt(ecx = SeedBank* this)	eax = int aNumSeeds; ecx, edx		取得传送带中的卡牌数量。此函数亦可用于寻找普通卡槽或传送带中首个空白卡牌的位置。
489B50	SeedPacket::SetPacketType;(edx = SeedType theImitaterType = -1, edi = SeedType theSeedType, esi = SeedPacket* this)	eax, ecx		自选卡关卡选卡结束后及固定选卡关卡进入时调用，初始化设定卡牌内容及初次冷却时间。
489C70	SeedBank::UpdateConveyorBelt(esi = SeedBank* this)	eax, ecx, edx		传送带更新每一张卡牌的位置，同时更新鼠标悬浮标签。
489CD0	SeedBank::UpdateWidth(esi = SeedBank* this)	eax, ecx, edx		通过41BEE0的函数获取卡槽格数，并根据卡槽格数设置每张卡牌的位置。
489D50	SeedBank::RefreshAllPackets(SeedBank* this)	eax, ecx, edx		刷新卡槽中所有可冷却的卡牌。
489DA0	StoreScreen::StoreScreen(LawnApp* theApp, StoreScreen* this)	eax = *this; ecx, edx		初始化创建商店对话，延迟加载商店需要的贴图资源。需要一个大小为 0x230 的内存区域用于构造 this。
48A610	StoreScreen::`scalar deleting destructor'(unsigned int flags, ecx = StoreScreen* this)	eax = *this; ecx, edx		删除商店对话，当 flags 的第 0 位置 1 时会额外释放商店对话本身占用的内存空间。		【虚函数】[[[(StoreScreen*)]+0]+0]
48A630	StoreScreen::~StoreScreen(ecx = StoreScreen* this)	eax, ecx, edx		销毁商店对话，释放商店的物品数据数组，并删除商店内的按钮、控件及戴夫的话的字符串。
48A760	StoreScreen::GetStoreItemType(eax = int theSpotIndex, edx = StoreScreen* this)	eax = StoreItem aStoreItem		取得商店当前页中第 theSpotIndex 位置的商品的类型，若该位置不存在商品则返回 -1。
48A8D0	StoreScreen::IsFullVersionOnly(StoreItem theStoreItem, ebx = StoreScreen* this)	al = 0(否) | 1(是); ecx, edx		判断 theStoreItem 商品是否在当前的试玩模式下不可购买。若当前不处于试玩模式，则总是返回“否”。
48A940	StoreScreen::IsComingSoon(esi = StoreItem theStoreItem, eax = StoreScreen* this)	al = 0(否) | 1(是); ecx, edx		判断当前 theStoreItem 商品是否显示为即将出现。
48A9D0	StoreScreen::IsItemSoldOut(edi = StoreItem theStoreItem, ebx = StoreScreen* this)	al = 0(否) | 1(是); ecx, edx		判断当前 theStoreItem 商品是否已售空。
48AAD0	StoreScreen::IsItemUnavailable(eax = StoreItem theStoreItem, ecx = StoreScreen* this)	al = 0(否) | 1(是); ecx, edx		判断当前 theStoreItem 商品是否不可购买。不可购买的商品将不会被显示在商店中。
48AC50	StoreScreen::DrawItemIcon(bool theIsForHighlight, ecx = StoreItem theStoreItem, edx = int theSpotIndex, ;                          edi = Graphics* g, StoreScreen* this)	eax, ecx, edx		在商店当前页中的第 theSpotIndex 位置绘制 theStoreItem 商品的图标，部分商品额外绘制商品内容文本。;其中，参数 theIsForHighlight 决定了对于高亮中的图标，此次绘制的是图标的基础图像部分或高亮叠加部分。
48B170	StoreScreen::DrawItem(StoreItem theStoreItem, int theSpotIndex, Graphics* g, StoreScreen* this)	eax, ecx, edx		在商店当前页中的第 theSpotIndex 位置绘制 theStoreItem 商品的图标、价格和购买信息等。
48B4C0	StoreScreen::Draw(Graphics* g, ecx = StoreScreen* this)	eax, ecx, edx		绘制商店界面对话及其中的所有商品、文本以及疯狂戴夫。		【虚函数】[[[(StoreScreen*)]+0]+68]
48BA30	StoreScreen::DrawOverlay(Graphics* g, ecx = StoreScreen* this)	eax, ecx, edx		绘制商店界面对话内的悬浮控件，即绘制商店对话的物品数据数组中的所有物品。		【虚函数】[[[(StoreScreen*)]+0]+B0]
48BAA0	StoreScreen::SetBubbleText;(bool theClickToContinue, int theTime, eax = int theCrazyDaveMessage, edi = StoreScreen* this)	eax, ecx, edx		设置商店内戴夫的谈话内容的编号及持续时间，其中 theClickToContinue 表示是否可以点击进入下一句谈话。
48BAD0	StoreScreen::UpdateMouse(eax = StoreScreen* this)	eax, ecx, edx		商店中根据鼠标位置更新鼠标悬浮的商品类型并依此设置戴夫的谈话编号，同时更新鼠标光标的样式。
48BE30	StoreScreen::StorePreload(esi = StoreScreen* this)	eax, ecx, edx		预加载商店中可能用到的所有动画的定义数据，同时令戴夫入场。
48BF60	StoreScreen::Update(ecx = StoreScreen* this)	eax, ecx, edx		更新商店界面对话，包括场景、动态、光标、音乐、戴夫、物品等的更新，以及购买完整版的相关判定。		【虚函数】[[[(StoreScreen*)]+0]+58]
48C350	StoreScreen::AddedToManager(WidgetManager* theWidgetManager, ecx = StoreScreen* this)	eax, ecx, edx		将商店对话加入控件管理器，并将其翻页和返回按钮及悬浮控件加入其子控件链表中。		【虚函数】[[[(StoreScreen*)]+0]+50]
48C3B0	StoreScreen::RemovedFromManager(WidgetManager* theWidgetManager, ecx = StoreScreen* this)	eax, ecx, edx		将商店对话移出控件管理器，并将其翻页和返回按钮及悬浮控件移出其子控件链表，同时移除戴夫。		【虚函数】[[[(StoreScreen*)]+0]+54]
48C410	StoreScreen::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		商店中按钮按下时，若按下的不是翻页的按钮，则播放按下按钮的音效。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(StoreScreen*)]+88]+4]
48C440	StoreScreen::IsPageShown(StorePage thePage, ebx = StoreScreen* this)	al = 0(否) | 1(是); ecx, edx		判断商店当前是否可以解锁第 thePage 页。
48C4D0	StoreScreen::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		商店中按下的按钮松开时，触发相应按钮的点击事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(StoreScreen*)]+88]+8]
48C5F0	StoreScreen::KeyChar(char theChar, ecx = StoreScreen* this)	eax, ecx, edx		商店中输入 theChar 字符。若在点击以继续戴夫对话的模式下输入空格或换行符，则推进戴夫对话进程。		【虚函数】[[[(StoreScreen*)]+0]+BC]
48C620	StoreScreen::GetItemCost(ecx = StoreItem theStoreItem)	eax = int aCost; ecx		取得商店中 theStoreItem 商品的当前价格。
48C740	StoreScreen::PurchaseItem(StoreItem theStoreItem, ecx = StoreScreen* this)	eax, ecx, edx		商店中点击商品后进行是否购买的确认，以及确定购买后的存档写入和相关事件的触发或相关状态的刷新。
48CF50	StoreScreen::AdvanceCrazyDaveDialog(StoreScreen* this)	eax, ecx, edx		商店中推进戴夫对话，并触发部分特定语句时刻的特殊事件。
48D130	StoreScreen::MouseDown(int theClickCount, int y, int x, ecx = StoreScreen* this)	eax, ecx, edx		商店内的鼠标按下，判断并执行推进戴夫对话或购买商品等事件。		【虚函数】[[[(StoreScreen*)]+0]+D8]
48D2E0	StoreScreen::EnableButtons(bl = bool theEnable, edi = StoreScreen* this)	eax, ecx, edx		设置商店翻页和返回按钮是否可用。最终决定的是否可用的值会额外考虑页面的可用性等因素。
48D3A0	StoreScreen::SetupForIntro(int theDialogIndex, edi = StoreScreen* this)	eax, ecx, edx		部分冒险模式关卡过关后，从奖励界面进入商店时，设置戴夫对话的开始编号，同时进行相关的场景布置。;包括：关闭戴夫的车的后备箱，将返回按钮的文本更改为“下一关”，禁用翻页的按钮。
48D4B0	TitleScreen::TitleScreen(LawnApp* theApp, TitleScreen* this)	eax = *this; ecx, edx		初始化标题界面。需要一个大小为 0xC8 的内存区域用于构造 this。
48D6B0	TitleScreen::`scalar deleting destructor'(unsigned int flags, ecx = TitleScreen* this)	eax = *this; ecx, edx		删除标题界面，当 flags 的第 0 位置 1 时会额外释放界面本身占用的内存空间。		【虚函数】[[[(TtitleScreen*)]+0]+0]
48D6D0	TitleScreen::~TitleScreen(ecx = TitleScreen* this)	eax, ecx, edx		销毁标题界面，删除开始游戏按钮。
48D730	TitleScreen::Draw(Graphics* g, ecx = TitleScreen* this)	eax, ecx, edx		绘制标题界面。		【虚函数】[[[(TtitleScreen*)]+0]+68]
48DCB0	TitleScreen::Update(ecx = TitleScreen* this)	eax, ecx, edx		更新标题界面，并根据加载线程的进度相应地更新加载进度条及开始游戏按钮。		【虚函数】[[[(TtitleScreen*)]+0]+58]
48E5A0	TitleScreen::AddedToManager(WidgetManager* theWidgetManager, ecx = TitleScreen* this)	eax, ecx, edx		将标题界面加入控件管理器，并将其开始游戏按钮加入其子控件链表中。		【虚函数】[[[(TtitleScreen*)]+0]+50]
48E5D0	TitleScreen::RemovedFromManager(WidgetManager* theWidgetManager, ecx = TitleScreen* this)	eax, ecx, edx		将标题界面移出控件管理器，并将其开始游戏按钮移出其子控件链表。		【虚函数】[[[(TtitleScreen*)]+0]+54]
48E600	TitleScreen::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		标题界面按下按钮时，播放按钮点击的音效。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(TtitleScreen*)]+88]+4]
48E620	TitleScreen::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		标题界面按下的按钮松开时，判断点击的按钮并依此执行相应的事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(TtitleScreen*)]+88]+8]
48E650	TitleScreen::MouseDown(int y, int x, ecx = TitleScreen* this)	eax, ecx, edx		标题界面内的鼠标按下，若加载线程已完成则播放按钮点击音效并结束加载。		【虚函数】[[[(TtitleScreen*)]+0]+D4]
48E690	TitleScreen::KeyDown(KeyCode theKey, ecx = TitleScreen* this)	eax, ecx, edx		标题界面中键盘按键按下，视为界面内鼠标按下，同时若允许作弊按键则记录该按键为快速加载键。		【虚函数】[[[(TtitleScreen*)]+0]+C0]
48E6F0	TodDrawTriangle_8888_TEX1_TALPHA0_MOD0_GLOB0_BLEND1 | ;TodDrawTriangle_0888_TEX1_TALPHA0_MOD0_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8 或 r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，;不进行固有色混合，进行线性混合。
48F9C0	TodDrawTriangle_8888_TEX1_TALPHA0_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
490920	TodDrawTriangle_8888_TEX1_TALPHA0_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
4921A0	TodDrawTriangle_8888_TEX1_TALPHA0_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
493970	TodDrawTriangle_8888_TEX1_TALPHA0_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
495BB0	TodDrawTriangle_8888_TEX1_TALPHA0_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
497480	TodDrawTriangle_8888_TEX1_TALPHA0_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合。
4997D0	TodDrawTriangle_8888_TEX1_TALPHA1_MOD0_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合。
49A610	TodDrawTriangle_8888_TEX1_TALPHA1_MOD0_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合。
49BC90	TodDrawTriangle_8888_TEX1_TALPHA1_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
49CBB0	TodDrawTriangle_8888_TEX1_TALPHA1_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
49E400	TodDrawTriangle_8888_TEX1_TALPHA1_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
49FC10	TodDrawTriangle_8888_TEX1_TALPHA1_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
4A1DF0	TodDrawTriangle_8888_TEX1_TALPHA1_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
4A3710	TodDrawTriangle_8888_TEX1_TALPHA1_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合。
4A59B0	TodDrawTriangle_8888_TEX1_TALPHA0_MOD0_GLOB0_BLEND0 | ;TodDrawTriangle_0888_TEX1_TALPHA0_MOD0_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 a8r8g8b8 或 r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，;不进行固有色混合，不进行线性混合。
4A63C0	TodDrawTriangle_0888_TEX1_TALPHA0_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
4A70D0	TodDrawTriangle_0888_TEX1_TALPHA0_MOD0_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4A7D70	TodDrawTriangle_0888_TEX1_TALPHA0_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
4A9430	TodDrawTriangle_0888_TEX1_TALPHA0_MOD0_GLOB1_BLEND1_ADDITIVE;(edi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合，绘制模式为叠加。
4AAAA0	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
4AC0A0	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB0_BLEND0_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合，绘制模式为叠加。
4AD590	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
4AF5E0	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB0_BLEND1_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合，绘制模式为叠加。
4B1580	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
4B2C50	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4B42D0	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合。
4B63F0	TodDrawTriangle_0888_TEX1_TALPHA0_MOD1_GLOB1_BLEND1_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合，绘制模式为叠加。
4B84F0	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合。
4B9160	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB0_BLEND0_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合，绘制模式为叠加。
4B9D30	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合。
4BB200	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB0_BLEND1_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合，绘制模式为叠加。
4BC670	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
4BD380	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4BE040	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
4BF710	TodDrawTriangle_0888_TEX1_TALPHA1_MOD0_GLOB1_BLEND1_ADDITIVE;(SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x8	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合，绘制模式为叠加。
4C0D60	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
4C2380	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB0_BLEND0_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合，绘制模式为叠加。
4C38C0	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
4C5910	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB0_BLEND1_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合，绘制模式为叠加。
4C77C0	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
4C8ED0	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4CA580	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，进行线性混合。
4CC700	TodDrawTriangle_0888_TEX1_TALPHA1_MOD1_GLOB1_BLEND1_ADDITIVE;(SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x8	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r8g8b8，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，进行线性混合，;绘制模式为叠加。
4CE700	TodDrawTriangle_0565_TEX1_TALPHA0_MOD0_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合。
4CF170	TodDrawTriangle_0565_TEX1_TALPHA0_MOD0_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合。
4D0500	TodDrawTriangle_0565_TEX1_TALPHA0_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
4D1350	TodDrawTriangle_0565_TEX1_TALPHA0_MOD0_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4D20B0	TodDrawTriangle_0565_TEX1_TALPHA0_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
4D3880	TodDrawTriangle_0565_TEX1_TALPHA0_MOD0_GLOB1_BLEND1_ADDITIVE;(edi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合，绘制模式为叠加。
4D4F40	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
4D6670	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB0_BLEND0_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合，绘制模式为叠加。
4D7C20	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
4D9DD0	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB0_BLEND1_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合，绘制模式为叠加。
4DBDF0	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
4DD630	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4DED40	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合。
4E0FD0	TodDrawTriangle_0565_TEX1_TALPHA0_MOD1_GLOB1_BLEND1_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合，绘制模式为叠加。
4E3150	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合。
4E3ED0	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB0_BLEND0_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合，绘制模式为叠加。
4E4B90	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合。
4E61A0	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB0_BLEND1_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合，绘制模式为叠加。
4E76C0	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
4E8510	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4E92B0	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
4EAA90	TodDrawTriangle_0565_TEX1_TALPHA1_MOD0_GLOB1_BLEND1_ADDITIVE;(SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x8	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合，绘制模式为叠加。
4EC170	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
4ED8E0	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB0_BLEND0_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合，绘制模式为叠加。
4EEE70	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
4F1040	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB0_BLEND1_ADDITIVE;(ecx = SWHelper::SWTextureInfo* textureInfo, edx = unsigned int bytepitch, void* pFrameBuffer, ; eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合，绘制模式为叠加。
4F2FB0	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
4F4820	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB1_BLEND0_ADDITIVE;(esi = SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x4	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合，绘制模式为叠加。
4F5F90	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，进行线性混合。
4F8220	TodDrawTriangle_0565_TEX1_TALPHA1_MOD1_GLOB1_BLEND1_ADDITIVE;(SWHelper::SWDiffuse& globalDiffuse, ecx = SWHelper::SWTextureInfo* textureInfo, ; edx = unsigned int bytepitch, void* pFrameBuffer, eax = SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x8	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g6b5，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，进行线性混合，;绘制模式为叠加。
4FA280	TodDrawTriangle_0555_TEX1_TALPHA0_MOD0_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合。
4FACF0	TodDrawTriangle_0555_TEX1_TALPHA0_MOD0_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合。
4FC080	TodDrawTriangle_0555_TEX1_TALPHA0_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
4FCE50	TodDrawTriangle_0555_TEX1_TALPHA0_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
4FE560	TodDrawTriangle_0555_TEX1_TALPHA0_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
4FFB80	TodDrawTriangle_0555_TEX1_TALPHA0_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
501C80	TodDrawTriangle_0555_TEX1_TALPHA0_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
503390	TodDrawTriangle_0555_TEX1_TALPHA0_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，不需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合。
5054D0	TodDrawTriangle_0555_TEX1_TALPHA1_MOD0_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;不进行线性混合。
5061E0	TodDrawTriangle_0555_TEX1_TALPHA1_MOD0_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，不使用固有颜色，不进行固有色混合，;进行线性混合。
507710	TodDrawTriangle_0555_TEX1_TALPHA1_MOD0_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;不进行线性混合。
5084B0	TodDrawTriangle_0555_TEX1_TALPHA1_MOD0_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，不使用固有颜色，进行固有色混合，;进行线性混合。
509BD0	TodDrawTriangle_0555_TEX1_TALPHA1_MOD1_GLOB0_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;不进行线性混合。
50B230	TodDrawTriangle_0555_TEX1_TALPHA1_MOD1_GLOB0_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，使用固有颜色，不进行固有色混合，;进行线性混合。
50D2F0	TodDrawTriangle_0555_TEX1_TALPHA1_MOD1_GLOB1_BLEND0;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;不进行线性混合。
50EA10	TodDrawTriangle_0555_TEX1_TALPHA1_MOD1_GLOB1_BLEND1;(SWHelper::SWDiffuse& globalDiffuse, SWHelper::SWTextureInfo* textureInfo, ; unsigned int bytepitch, void* pFrameBuffer, SWHelper::SWVertex* pVerts)	eax, ecx, edx	0x14	将纹理图像以 globalDiffuse 颜色通过 pVerts 三角形映射绘制至 pFrameBuffer 中。其中：;纹理像素模式为 r5g5b5，使用纹理图像，需要alpha渲染，使用固有颜色，进行固有色混合，;进行线性混合。
510BC0	Tod_SWTri_AddAllDrawTriFuncs()	eax, ecx, edx		依次将 TEX1 的各个三角绘制函数的指针加入到绘制函数数组 gDrawTriFunc 中合适的位置。
5111A0	Sexy::ResourceManager::BaseRes::~BaseRes(ecx = ResourceManager::BaseRes* this)	eax, ecx, edx		销毁基础资源，释放其 Id、所属资源组、文件路径的字符串及 XML 属性的宽字符串映射容器。
511250	Sexy::ResourceManager::ImageRes::ImageRes(ResourceManager::ImageRes* this)	eax = *this; ecx, edx		初始化创建贴图资源。需要一个大小为 0x110 的内存区域用于构造 this。
5112F0	Sexy::ResourceManager::BaseRes::`scalar deleting destructor';(unsigned int flags, ecx = ResourceManager::BaseRes* this)	eax = *this; ecx, edx		删除基础资源，当 flags 的第 0 位置 1 时会额外释放基础资源本身占用的内存空间。		【虚函数】[[[(ResourceManager::BaseRes*)]+0]+0]
511310	Sexy::ResourceManager::ImageRes::`scalar deleting destructor';(unsigned int flags, ecx = ResourceManager::ImageRes* this)	eax = *this; ecx, edx		删除贴图资源，当 flags 的第 0 位置 1 时会额外释放贴图资源本身占用的内存空间。		【虚函数】[[[(ResourceManager::ImageRes*)]+0]+0]
511330	Sexy::ResourceManager::BaseRes::BaseRes(ResourceManager::BaseRes* this)	eax = *this; ecx, edx		初始化创建基础资源。需要一个大小为 0x6C 的内存区域用于构造 this。
5113C0	Sexy::ResourceManager::ImageRes::~ImageRes(ResourceManager::ImageRes* this)	eax, ecx, edx		销毁贴图资源，释放资源中的相关贴图、字符串和贴图动画信息等。
5114E0	TodGetCurrentLevelName(_Out_ std::string&& aLevelName)	eax = std::string&& aLevelName; ecx, edx	0x4	【默认占位函数】取得当前游戏关卡、场景或阶段的名称。总是返回“Unknown Level”。
511510	TodHasUsedCheatKeys() | TodAppCloseRequest()	al = 0		【默认占位函数】判断玩家是否使用过作弊按键/判断是否有关闭程序的请求。总是返回“否”。
511520	TodPickArrayItemFromWeightedArray(ebx = TodWeightedArray* theArray, edi = int theCount)	eax = TodWeightedArray* aPicked; ecx, edx		给定由若干个 (内容, 权重) 组成的数组的指针及可能性数 theCount，加权取得随机一种可能结果。
511570	TodPickFromWeightedGridArray(ebx = TodWeightedGridArray* theArray, edi = int theCount)	eax = TodWeightedGridArray* aPicked; ;ecx, edx		给定由若干个 (列, 行, 权重) 组成的场地格子数组的指针及可能性数 theCount，加权取得随机一个可能格子。
5115C0	TodCalcSmoothWeight(float aSecondLastPicked, float aLastPicked, float aWeight)	st(0) = aWeight; eax	0xC	根据基础权重和此项连续未被选中的轮数，按照一定规则计算其在本轮中的实际权重。
5116B0	TodPickFromSmoothArray(edi = TodSmoothArray* theArray)	eax = int aPickedItem; ecx, edx		从 6 个权重数组中加权随机地取得其中一个。每一个权重数组为类似如下四元数值对的结构：;(int mItem, float mWeight, float mLastPicked, float mSecondLastPicked)。;其中，mLastPicked 和 mSecondLastPicked 为此项距离上次和上上次被选中已经过的轮数。
5117F0	TodUpdateSmoothArrayPick(edx = int thePickIndex, ecx = TodSmoothArray* theArray)	eax, ecx, edx		当从 6 个权重数组中选中其中的第 thePickIndex 个后，重新更新每行的权重数组的各项数据。具体为：;将所有权重不为 0 的项的 mLastPicked 和 mSecondLastPicked 的值增加 +1，;然后将被选中项的 mLastPicked 的值转移至 mSecondLastPicked 中，并将其 mLastPicked 清零。
5118C0	TodCurveS(float theTime)	st(0) = aVal	0x4	三次 S 曲线，计算 aVal = f5(theTime)。其中 theTime 的取值范围为 [0, 1]。
5118F0	TodCurveInvQuadS(float theTime)	st(0) = aVal; eax	0x4	伪四次 S 曲线，计算 aVal = f7(theTime)。其中 theTime 的取值范围为 [0, 1]。
511970	TodCurveBounce(float theTime)	st(0) = aVal	0x4	弹跳效果曲线，计算 aVal = f9(theTime)。其中 theTime 的取值范围为 [0, 1]。
5119B0	TodCurveEvaluate(eax = TodCurves theCurve, float thePositionEnd, float thePositionStart, float theTime)	st(0) = aVal; eax	0xC	曲线计算函数。以 ftheCurve(theTime) 为插值令数据在 thePositionStart 和 thePositionEnd 之间过渡。;即：计算 aVal = (thePositionEnd - thePositionStart) * ftheCurve(theTime) + thePositionStart。;其中 theTime 的取值范围为 [0, 1]。
511B30	TodCurveEvaluateClamped;(ecx = TodCurves theCurve, float thePositionEnd, float thePositionStart, float theTime)	st(0) = aVal; eax	0xC	曲线计算预备。排除不符合标准时间范围规定的时间参数的情况，其他情况则调用曲线计算函数。;其中 theTime 的取值范围为 [0, 1]。
511BA0	TodAnimateCurveFloatTime(ecx = TodCurves theCurve, float thePositionEnd, float thePositionStart, ;                         float theTimeAge, float theTimeEnd, float theTimeStart)	st(0) = aPos; eax	0x14	浮点时间的动画曲线函数。
511BF0	TodAnimateCurveFloat(TodCurves theCurve, float thePositionEnd, float thePositionStart, ;                     eax = int theTimeAge, ecx = int theTimeEnd, edx = int theTimeStart)	st(0) = aPos; eax, ecx	0xC	浮点动画曲线函数。动画以 theCurve 曲线变化，在从 theTimeStart 至 theTimeEnd 的一段时间内，;其位置变化范围为 [thePositionStart, thePositionEnd]，则依此计算 theTimeAge 时刻对应的 aPos。;一般可以认为：给定的 theTimeStart 和 theTimeEnd 为曲线的横坐标的最小值和最大值;给定的 thePositionStart 和 thePositionEnd 为曲线的纵坐标的最小值和最大值。;但是，若需求与曲线相反的位置数值变化量（/变化趋势），则需交换曲线的起始和结束的位置（/时间）。
511C40	TodAnimateCurve(TodCurves theCurve, int thePositionEnd, int thePositionStart, ;                eax = int theTimeAge, ecx = int theTimeEnd, edx = int theTimeStart)	eax = int aPos; ecx	0xC	动画曲线函数。根据一段时间内动画在给定曲线上的位置变化范围，计算 theTimeAge 时刻在曲线上对应的 aPos。;一般可理解为，动画以 theCurve 曲线从 (theTimeStart, thePositionStart) 开始，;变化至 (theTimeEnd, thePositionEnd) 的过程中，计算当前时刻 theTimeAge 位置对应的当前位置 aPos。;此函数亦常用于计算数值增长/衰减等规则且平滑的数据变化。
511CB0	RandRangeFloat(float theMax, float theMin)	st(0) = aRandVal; eax, ecx, edx	0x8	取得一个 [theMin, theMax] 区间的随机浮点数存入 st(0)。此函数的本质即为5AF410的函数。
511CE0	TodDrawString(Color theColor, DrawStringJustification theJustification, ebx = Font* theFont, ;              int thePosY, ecx = int thePosX, edx = const std::string& theText, Graphics* g)	eax, ecx, edx	0x1C	以指定的字体和 theColor 颜色在指定位置处绘制文本。其中 theJustification 为文本的对齐方式：;0(左对齐) | 1(右对齐) | 2(居中对齐) | 3(左对齐，垂直居中) | 4(右对齐，垂直居中) | 5(完全居中)。;参数 theColor 采用值传递（一种传参方式是依次令颜色的 A、B、G、R 值依次入栈）。
511D90	TodDrawImageCelScaled(float theScaleY, float theScaleX, int theCelRow, int thePosY, int thePosX, ;                      esi = Image* theImageStrip, Graphics* g)	eax, ecx, edx	0x18	带拉伸地在 (thePosX, thePosY) 位置绘制分份贴图中位于第 0 列第 theCelRow 行的一份。
511E50	TodDrawStringMatrix(const Color& theColor, edx = const std::string& theString, ;                    const SexyMatrix3& theMatrix, Font* theFont, Graphics* g)	eax, ecx, edx	0x10	绘制经过矩阵变换后的样式的文本。此函数中使用的字体只能为贴图字体（ImageFont）。
512570	TodDrawImageCelF(int theCelCol, float thePosY, float thePosX, ecx = Image* theImageStrip, Graphics* g)	eax, ecx, edx	0x10	在 (thePosX, thePosY) 位置绘制线性分份贴图的第 theCelCol 份，非线性时仅取贴图的第 0 行。
5125D0	TodScaleRotateTransformMatrix;(float theScaleY, float theScaleX, float rad, float y, float x, esi = SexyMatrix3& m)	eax, ecx, edx	0x14	根据指定的坐标、旋转弧度和拉伸比例，设定给定矩阵的各项数值。
512650	TodBltMatrix(ebx = const Rect& theSrcRect, int theDrawMode, const Color& theColor, const Rect& theClipRect, ;             const SexyMatrix3& theTransform, eax = Image* theImage, esi = Graphics* g)	eax, ecx, edx	0x10	在 theClipRect 区域绘制贴图 theImage 的 theSrcRect 部分经过矩阵 theTransform 变换后的图像。;一般可以默认使用 theDrawMode = [*g+44]、&theClipRect = *g+20、&theColor = 0x72289C。
5127C0	TodDrawImageCelCenteredScaledF(float theScaleY, float theScaleX, int theCelCol, float thePosY, float thePosX, ;                               ecx = Image* theImageStrip, eax = Graphics* g)	eax, ecx, edx	0x14	浮点中心拉伸地在 (thePosX, thePosY) 位置绘制线性分份贴图的第 theCelCol 份。
512880	TodDrawImageCelScaledF(float theScaleY, float theScaleX, int theCelRow, int theCelCol, ;                       float thePosY, float thePosX, ecx = Image* theImageStrip, eax = Graphics* g)	eax, ecx, edx	0x18	浮点拉伸地在 (thePosX, thePosY) 位置绘制分份贴图位于第 theCelCol 列第 theCelRow 行的一份。
512950	TodDrawImageScaledF;(float theScaleY, float theScaleX, float thePosY, float thePosX, eax = Image* theImage, ecx = Graphics* g)	eax, ecx, edx	0x10	浮点拉伸地绘制贴图，拉伸原点为贴图的左上顶点。
512A10	TodDrawImageCenterScaledF;(float theScaleY, float theScaleX, float thePosY, float thePosX, eax = Image* theImage, ecx = Graphics* g)	eax, ecx, edx	0x10	浮点拉伸地绘制贴图，拉伸原点为贴图的中心点。
512AC0	AverageNearByPixels(int y, int x, unsigned long* thePixel, MemoryImage* theImage)	eax = unsigned long aAverageColor; ecx, edx	0x10	计算并返回贴图中指定像素点周围所有非透明像素的红蓝绿色值的平均值。返回值的不透明度值为 0。;参数中，指针 thePixel 指向上述指定的像素点，且 x 和 y 为该像素点位于贴图中的横、纵坐标值。
512C60	FixPixelsOnAlphaEdgeForBlending(edi = Image* theImage)	eax, ecx, edx		将贴图中所有透明像素的红蓝绿色值分别修正为其周围非透明像素的对应色值的平均值。;此函数中使用的贴图只能为内存贴图（MemoryImage）且必须已经存在像素集且存在不透明度通道。
512D00	SexyMatrix3Inverse(edx = _Out_ SexyMatrix3&& r, eax = const SexyMatrix3& m)	ecx		计算三阶方阵的逆矩阵 r = m-1。若需要直接在原方阵上作修改，可令 r 引用需要修改的方阵。
512E20	SexyMatrix3Multiply(eax = const SexyMatrix3& r, ecx = const SexyMatrix3& l, edx = _Out_ SexyMatrix3&& m)	ecx		计算三阶方阵乘法 m = l × r。若需要直接在原方阵上作修改，可令 m 引用需要修改的方阵。
512F20	GetFlashingColor(esi = int theFlashTime, int theCounter, edi = _Out_ Color&& aFlashColor)	eax = Color&& aFlashColor; ecx, edx	0x4	当亮度以 theFlashTime 为周期在 [55, 255] 范围内均匀变化时，计算并取得 theCounter 时刻的灰度颜色。
512F80	ColorsAdd(esi = const Color& theColor2, edi = const Color& theColor1, edx = _Out_ Color&& aColor)	eax = Color&& aColor; ecx		颜色相加。给定两种 RGBA 色彩，计算其混合而成的新颜色（线性减淡）。
513020	ColorComponentMultiply(eax = int theColor2, int theColor1)	eax = int aColor; ecx, edx	0x4	颜色某一通道的色值的叠加。计算 aColor = theColor1 * theColor2 / 255 并将其限定在 [0, 255] 内。
513050	ColorsMultiply(ebx = const Color& theColor2, edi = const Color& theColor1, esi = _Out_ Color&& aColor)	eax = Color&& aColor; ecx, edx		颜色叠加。给定两种 RGBA 色彩，计算其混合而成的新颜色（正片叠底）。
513120	TodLoadResources(const std::string& theGroup)	al = bool 是否成功; ecx, edx	0x4	加载 theGroup 组游戏资源。此函数以 gSexyAppBase->mResourceManager 为参数跳转至513140的函数。
513140	TodResourceManager::TodLoadResources(eax = const std::string& theGroup, ecx = TodResourceManager* this)	al = bool 是否成功; ecx, edx		加载名为 theGroup 的一组游戏资源，若该组资源已加载则直接返回，若发生错误则会弹出相应的错误弹窗。
513230	TodResourceManager::AddImageToMap;(SharedImageRef* theImage, edi = const std::string& thePath, TodResourceManager* this)	eax, ecx, edx		向资源管理器已加载的贴图资源的映射容器中加入一个图片路径和基础资源（BaseRes）指针的对组。;其中，基础资源的共享贴图引用将被赋值为 theImage，且基础资源的路径字符串将被赋值为 thePath。
513300	std::allocator<std::string>::destroy(std::string* _Ptr)	eax, ecx, edx		字符串的内存申请器销毁一个字符串。
513330	TodResourceManager::TodLoadNextResource(esi = TodResourceManager* this)	al = bool 是否成功; ecx, edx		继续加载当前正在加载的一组游戏资源的下一个资源。返回“否”时表示加载失败或该组资源已加载完毕。
513570	FindGlobalAllocator(edi = int theSize)	eax = TodAllocator* pAllocator; ecx, edx		在全局分配器数组中寻找一个用于管理内存大小为 theSize 的 Item 的内存分配的分配器，若不存在则创建。;每种分配器用于在每次需要时一次性申请若干个特定 Item 所需要的内存空间，避免频繁申请和释放内存。;【使用时】令 mTotalItems++，并检测 mFreeList 是否为空指针，是则调用4438C0的函数额外申请内存;否则取出 mFreeList 作为 Item 的指针，并以该 Item 的上一项指针重新赋值 mFreeList。;【回收时】令 mTotalItems--，并在需要回收的内存区域的首个四字节中存入原 mFreeList 的值，;然后以需要回收的内存区域的指针重新赋值 mFreeList。
513600	FreeGlobalAllocators()	eax, ecx, edx		释放所有全局内存申请器中所有已申请的内存区块。
513660	TodReplaceString(const std::string& theStringToSubstitute, ecx = const char* theStringToFind, ;                 edx = const std::string& theText, _Out_ std::string&& aFinalString)	eax = std::string&& aFinalString; ecx, edx	0x8	将 theText 文本字符串中的首个 theStringToFind 子字符串以 theStringToSubstitute 字符串替换，;返回替换后的新字符串。
513720	TodReplaceNumberString(int theNumber, ecx = const char* theStringToFind, ;                       edx = const std::string& theText, _Out_ std::string&& aFinalString)	eax = std::string&& aFinalString; ecx, edx	0x8	将 theText 文本字符串中的首个 theStringToFind 子字符串以 theNumber 转化的字符串替换，;返回替换后的新字符串。
5137F0	TodIsPointInPolygon(esi = const SexyVector2& theCheckPoint, edx = const SexyVecotr2* thePolygonPoint)	al = 0(否) | 1(是); ecx, edx		判断点 theCheckPoint 是否位于由 thePolygonPoint 的 4 个顶点依次连接组成的凸四边形的内部或边界上。
5138B0	std::_Tree<std::_Tmap_traits<char, int>>::find;(edi = const char& _Keyval, _Out_ std::_Tree<std::_Tmap_traits<char, int>::iterator&& _Ret, ; esi = std::_Tree<std::_Tmap_traits<char, int>* this)	eax = &&_Ret; ecx, edx		在字符向整数的映射容器中寻找 _Keyval 字符对应的整数值。;若找到，则返回指示该对组所在位置处的迭代器否则，返回相当于 map.end() 的迭代器。
513920	std::map<char, Rect>::operator[](const char& _Keyval, eax = std::map<char, Rect>* this)	eax = Rect& _Val; ecx, edx		在字符向矩形的映射容器中寻找 _Keyval 字符对应的矩形值，返回对该矩形的引用。;若容器中原先不存在 _Keyval 键，则向容器中新添加一个 (_Keyval, _R) 对组，其中 _R 为默认构造的矩形。
5139C0	std::vector<int>::~vector<int>(esi = std::vector<int>* this)	eax, ecx, edx		销毁整数的向量容器，释放数组占用的内存空间。
5139F0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::insert;(const std::string, int& _Val, ; ebx = _Out_ std::pair<std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::iterator, bool>&& _Ret, ; std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		向字符串的集合容器中添加一项 _Val，若新插入的项与原有的项重复则插入无效。;返回一个由表示插入的项在集合中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
513AF0	std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::insert;(const std::pair<std::string, ResourceManager::BaseRes*>& _Val, ; ebx = _Out_ std::pair<std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::iterator, bool>&& _Ret, ; std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>* this)	eax = &&_Ret; ecx, edx		向字符串向基础资源指针的映射容器中添加一个对组（_Val），若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
513C50	std::list<ResourceManager::BaseRes*>::_Const_iterator<1>::operator!=;(esi = const std::list<ResourceManager::BaseRes*>::_Const_iterator<1>& __that, ; edi = std::list<ResourceManager::BaseRes*>::_Const_iterator<1>* this)	al = bool _Neq; ecx, edx		判断两个基础资源指针的链表的迭代器是否不相等。
513C70	std::string::replace(eax = unsigned int _Count = -1, unsigned int _Roff, const std::string& _Right, ;                     unsigned int _N0 = -1, esi = unsigned int _Off, std::string* this)	eax = *this; ecx, edx		将字符串从 _Off 开始 _N0 长度的部分替换为 _Right 字符串从 _Roff 开始 _Count 长度的一个子字符串，;返回替换后的原字符串。
514020	std::_Tree<std::_Tmap_traits<char, Rect>>::insert;(std::_Tree<std::_Tmap_traits<char, Rect>>::iterator _Where, const std::pair<char, Rect>& _Val, ; _Out_ std::_Tree<std::_Tmap_traits<char, Rect>>::iterator&& _Ret, ; eax = std::_Tree<std::_Tmap_traits<char, Rect>>* this)	eax = &&_Ret; ecx, edx		向字符向矩形的映射红黑树中的指定位置添加一个对组 _Val，返回表示插入的键值在红黑树中的位置的迭代器。
5141E0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Insert;(const std::pair<std::string, int>& _Val, ; ecx = std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		在字符串的集合容器的红黑树中的指定节点下添加一个新的节点，返回表示插入的项在红黑树中的位置的迭代器。
5143C0	std::_Tree<std::_Tmap_traits<std::string, int>>::_Insert;(const std::pair<std::string, ResourceManager::BaseRes*>& _Val, ; ecx = std::_Tree_nod<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>* this)	eax = &&_Ret; ecx, edx		在字符串向基础资源指针的映射红黑树中的指定节点下添加一个新的节点，;返回表示插入的键值在红黑树中的位置的迭代器。
5145A0	std::list<ResourceManager::BaseRes*>::_Const_iterator<1>::operator++;(esi = std::list<ResourceManager::BaseRes*>::_Const_iterator<1>* this)	eax, ecx, edx		基础资源指针的链表的迭代器的自增操作符。
5145D0	std::_Tree<std::_Tmap_traits<char, Rect>>::insert;(const std::pair<char, Rect>& _Val, _Out_ std::pair<std::_Tree<std::_Tmap_traits<char, Rect>>::iterator, bool>&& _Ret, ; ebx = std::_Tree<std::_Tmap_traits<char, Rect>>* this)	eax = &&_Ret; ecx, edx		向字符向矩形的映射容器中添加一个对组（_Val），若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
5146B0	std::_Tree<std::_Tmap_traits<char, Rect>>::_Insert;(const std::pair<char, Rect>& _Val, ecx = std::_Tree_nod<std::_Tmap_traits<char, Rect>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<char, Rect>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<char, Rect>>* this)	eax = &&_Ret; ecx, edx		在字符向矩形的映射红黑树中的指定节点下添加一个新的节点，返回表示插入的键值在红黑树中的位置的迭代器。
5148A0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Lrotate;(ecx = std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* _Wherenode, ; std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		对字符串的集合容器的红黑树的一个节点进行左旋转。
5148F0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Rrotate;(ecx = std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* _Wherenode, ; std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		对字符串的集合容器的红黑树的一个节点进行右旋转。
514940	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Buynode;(const std::pair<std::string, PlayerInfo>& _Val, ; std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Node* _Rarg, ; std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Node* _Parg, ; std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Node* _Larg)	eax = std::_Tree_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符串的集合容器的节点，;并令该节点的父节点指针和左、右子节点指针分别指向 _Parg、 _Larg 和 _Rarg，;同时赋值该节点处的值为 _Val。
5149F0	std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Lrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>* this)	eax, ecx, edx		对字符串向基础资源指针的映射红黑树的一个节点进行左旋转。
514A40	std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Rrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>* this)	eax, ecx, edx		对字符串向基础资源指针的映射红黑树的一个节点进行右旋转。
514A90	std::_Tree<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Buynode;(const std::pair<std::string, ResourceManager::BaseRes*>& _Val, ; std::_Tree_nod<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Node* _Rarg, ; std::_Tree_nod<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Node* _Parg, ; std::_Tree_nod<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Node* _Larg)	eax = std::_Tree_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符串向基础资源指针的映射容器的节点，令该节点的父节点指针指向 _Parg，;并令该节点的左、右子节点指针分别指向 _Larg 和 _Rarg，同时赋值该节点处的对组值为 _Val。
514B40	std::_Tree<std::_Tmap_traits<char, Rect>>::_Lrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<char, Rect>>* _Wherenode, std::_Tree<std::_Tmap_traits<char, Rect>>* this)	eax, ecx, edx		对字符向矩形的映射红黑树的一个节点进行左旋转。
514B90	std::_Tree<std::_Tmap_traits<char, Rect>>::_Rrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<char, Rect>>* _Wherenode, std::_Tree<std::_Tmap_traits<char, Rect>>* this)	eax, ecx, edx		对字符向矩形的映射红黑树的一个节点进行右旋转。
514BE0	std::_Tree<std::_Tmap_traits<char, Rect>>::_Buynode;(char _Carg, esi = const std::pair<char, Rect>& _Val, std::_Tree_nod<std::_Tmap_traits<char, Rect>>::_Node* _Rarg, ; std::_Tree_nod<std::_Tmap_traits<char, Rect>>::_Node* _Parg, ; std::_Tree_nod<std::_Tmap_traits<char, Rect>>::_Node* _Larg)	eax = std::_Tree_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符向矩形的映射容器的节点，赋值该节点的颜色为 _Carg，;并令该节点的父节点指针和左、右子节点指针分别指向 _Parg、 _Larg 和 _Rarg，;同时赋值该节点处的对组值为 _Val。
514C30	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::const_iterator::_Dec;(esi = std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::const_iterator* this)	eax, ecx, edx		字符串的集合容器的常量迭代器自减。
514CB0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Max;(eax = std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Node* _Pnode)	eax = _Node* _Maxnode; ecx, edx		取得字符串的集合容器的红黑树从 _Pnode 开始最右侧的一个节点。
514CD0	std::_Tree<std::_Tmap_traits<char, Rect>>::const_iterator::_Dec;(esi = std::_Tree<std::_Tmap_traits<char, Rect>>::const_iterator* this)	eax, ecx, edx		字符向矩形的映射容器的常量迭代器自减。
514D50	std::_Tree<std::_Tmap_traits<char, Rect>>::const_iterator::_Inc;(esi = std::_Tree<std::_Tmap_traits<char, Rect>>::const_iterator* this)	eax, ecx, edx		字符向矩形的映射容器的常量迭代器自增。
514DC0	std::_Tree<std::_Tmap_traits<char, Rect>>::_Max(eax = std::_Tree_nod<std::_Tmap_traits<char, Rect>>::_Node* _Pnode)	eax = _Node* _Maxnode; ecx, edx		取得字符向矩形的映射红黑树从 _Pnode 开始最右侧的一个节点。
514DE0	std::_Tree<std::_Tmap_traits<char, Rect>>::_Min(eax = std::_Tree_nod<std::_Tmap_traits<char, Rect>>::_Node* _Pnode)	eax = _Node* _Minnode; ecx, edx		取得字符向矩形的映射红黑树从 _Pnode 开始最左侧的一个节点。
514E00	std::_Allocate<std::_Tree_nod<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Node>;(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符串的集合容器的红黑树的节点所需要的内存空间，;单个节点占用的内存大小为 0x30。当 _Count 个节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
514E50	std::_Allocate<std::_Tree_nod<std::_Tmap_traits<std::string, ResourceManager::BaseRes*>>::_Node>;(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符串向基础资源指针的映射容器的红黑树的节点所需要的内存空间，;单个节点占用的内存大小为 0x30。当 _Count 个节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
514EA0	TodErrorMessageBox(ecx = const char* theMessage)	eax, ecx, edx	0x4	弹出一个标题为“Error”、内容为 theMessage 的错误弹窗。
514ED0	FoleyTypeData::FoleyTypeData(ecx = FoleyTypeData* this)	eax = *this; ecx		初始化创建音效类型数据实例。需要一个大小为 0xA4 的内存区域用于构造 this。
514F70	SoundSystemReleaseFinishedInstances(TodFoley* theSoundSystem)	eax, ecx, edx	0x4	释放所有已播放完成的上位音效实例。
514FE0	SoundSystemHasFoleyPlayedTooRecently(eax = FoleyType theFoleyType, TodFoley* theSoundSystem)	al = 0(无) | 1(有), ecx, edx	0x4	判断 theFoleyType 音效是否有过在近 10cs 内开始播放的音效实例。用于避免重叠播放同种非循环音效。
515020	TodFoley::PlayFoleyPitch(float thePitch, eax = FoleyType theFoleyType, ecx = TodFoley* this)	eax, ecx, edx		以指定音高 thePitch 播放 theFoleyType 音效。一般情况下，音高不应超出音效固有的音高范围。
515240	TodFoley::PlayFoley(esi = FoleyType theFoleyType, TodFoley* this)	eax, ecx, edx		播放 theFoleyType 音效。此函数在内部在音效固有的音高范围内随机取得音高后调用了515020的函数。
515290	TodFoley::StopFoley(eax = FoleyType theFoleyType, edi = TodFoley* this)	eax, ecx, edx		停止 theFoleyType 音效。将其中首个使用中的上位音效实例减少 1 次引用，若减少后无引用则直接释放。
5152D0	TodFoley::GamePause(bool theEnteringPause, eax = TodFoley* this)	eax, ecx, edx		游戏暂停（取消暂停）时，令所有在游戏暂停时应当静默的音效进入（解除）暂停状态。
5153F0	TodFoley::CancelPausedFoley(eax = TodFoley* this)	eax, ecx, edx		释放所有处于暂停状态的拟音音效实例。
515460	TodFoley::ApplyMusicVolume(ecx = FoleyInstance* theFoleyInstance)	eax, ecx, edx		设定音效实例的音量值以使其实际音量等于游戏音乐的音量。
5154A0	TodFoley::RehookupSoundWithMusicVolume(eax = TodFoley* this)	eax, ecx, edx		游戏音乐音量设置变更时调用，根据更新后的音量值重新设定当前所有“使用音乐音量”的音效的音量。
515560	TodFoley::IsFoleyPlaying(eax = FoleyType theFoleyType, edi = TodFoley* this)	al = 0(否) | 1(是); ecx, edx		判断当前是否存在 theFoleyType 类型的音效的实例。
5155A0	ParticleFieldConstructor(void* thePointer)	eax = void* thePointer; ecx	0x4	ParticleField 实例的构造函数。
5155C0	TodEmitterDefinitionConstructor(void* thePointer)	eax = void* thePointer; ecx	0x4	TodEmitterDefinition 实例的构造函数。
515620	TodParticleDefinitionConstructor(void* thePointer)	eax = void* thePointer; ecx	0x4	TodParticleDefinition 实例的构造函数。
515640	TodParticleLoadADef(ecx = const char* theParticleFileName, TodParticleDefinition* theParticleDef)	al = bool 是否成功; ecx, edx	0x4	从指定粒子系统定义文件（实际为对应的.compiled文件）中读取粒子系统定义数据并存储在 theParticleDef 中。
515CE0	TodParticleLoadDefinitions()	eax, ecx, edx		根据粒子参数分别从相应文件加载所有粒子系统的定义数据。当出现加载失败时，会弹出错误弹窗。;此函数仅在 4528E0 的函数中（452BAA 处）有过一次调用，故其原有的两个参数在原版中被内联至函数内：;【ParticleParams* theParticleParamArray（实参 = gLawnParticleArray(0x6A0FF0)）】;粒子参数（ParticleParams）指定了一种粒子系统类型与该粒子系统的数据文件的文件名之间的对应关系;【int theParticleParamArraySize（实参 = 106）】粒子参数数组的长度，其值等于粒子系统类型的数量。
515E30	TodParticleFreeDefinitions()	eax, ecx, edx		根据粒子系统定义结构图释放粒子系统定义数组，清除全局粒子系统参数数组指针。
515E90	TodParticleSystem::TodParticleInitializeFromDef;(edx = ParticleEffect theEffectType, TodParticleDefinition* theDefinition, ecx = int theRenderOrder, ; float theY, float theX, TodParticleSystem* this)	eax, ecx, edx		根据粒子系统定义数据在指定位置初始化粒子系统及系统中的所有发射器。;当场上的粒子系统、粒子发射器和粒子中任一者的数量超过 900 时，部分粒子系统将不再允许被创建。
515F70	TodParticleEmitter::TodEmitterInitialize(TodEmitterDefinition* theEmitterDef, TodParticleSystem* theSystem, ;                                         float theY, float theX, ecx = TodParticleEmitter* this)	eax, ecx, edx		根据粒子发射器定义数据初始化粒子发射器，并立即进行一次更新。
5160C0	TodParticleSystem::ParticleSystemDie(TodParticleSystem* this)	eax, ecx, edx		令粒子系统消失，同时处理粒子系统内发射器、粒子等的消失及相关事件。
516160	TodParticleEmitter::SpawnParticle(int theSpawnCount, int theIndex, ecx = TodParticleEmitter* this)	eax = TodParticle* aParticle; ecx, edx		粒子发射器发射粒子，并根据各轨道上的定义初始化粒子。粒子初始化完成后会立即进行一次更新。;参数的 theSpawnCount 和 theIndex 分别表示本次发射粒子的总个数及当前粒子在本次发射粒子中的序数，;此二参数仅在粒子发射器的发射路径为圆周等距（原版仅魅惑特效使用该路径）时，用于计算发射角度。
5167F0	FloatTrackEvaluateFromLastTime(float theInterp, float theTimeValue, FloatParameterTrack& theTrack)	st(0) = aTrackVal; eax, ecx, edx	0xC	若给定的时间值小于 0，则返回 0否则，根据给定的时间和插值计算浮点参数轨道的当前值。
516820	TodParticleEmitter::UpdateParticleField;(eax = int theFieldIndex, float theParticleTimeValue, ecx = ParticleField* theParticleField, ; esi = TodParticle* theParticle, TodParticleEmitter* this)	eax, ecx, edx		粒子发射器更新一个粒子场对粒子运动的影响。参数 theParticleTimeValue 为粒子生命周期已经过的比率，;参数 theFieldIndex 表示当前粒子场的序数，用于取得粒子初始化时被赋予的对应场中的插值。
516D70	TodParticleEmitter::UpdateSystemField(eax = int theFieldIndex, float theParticleTimeValue, ;                                      esi = ParticleField* theParticleField, edi = TodParticleEmitter* this)	eax, ecx, edx		粒子发射器更新一个系统粒子场对自身位置的影响。参数 theParticleTimeValue 为自身生命周期已经过的比率，;参数 theFieldIndex 表示当前系统粒子场的序数，用于取得发射器初始化时被赋予的对应场中的插值。
516E70	TodParticleEmitter::CrossFadeParticleToName;(eax = const char* theEmitterName, TodParticle* theParticle, TodParticleEmitter* this)	al = bool 是否成功; ecx, edx		在同一粒子系统中创建一个名为 theEmitterName 的发射器，并令粒子 theParticle 交叉混合至该发射器。;若发射器所在粒子系统不含有指定名称的发射器，或当前发射器数量已达到上限，则交叉混合失败。
516F00	TodParticleEmitter::UpdateParticle(eax = TodParticle* theParticle, ecx = TodParticleEmitter* this)	al = bool isDead; ecx, edx		粒子发射器更新一个粒子，包括对粒子生命周期、运动、旋转及动画（若有定义）等的更新。;当返回 false 时，表示该粒子的生命周期和交叉混合均已结束（或不存在），后续将删除该粒子。
517160	TodParticleEmitter::UpdateSpawning(eax = TodParticleEmitter* this)	eax, ecx, edx		粒子发射器更新粒子的发射。若发射器处于交叉混合过程中，则发射的粒子会同步交叉混合至目标发射器。
5172C0	TodParticleEmitter::DeleteNonCrossFading(edi = TodParticleEmitter* this)	eax, ecx, edx		删除粒子发射器中所有不处于交叉混合过程中的粒子。
517300	TodParticleEmitter::DeleteAll(edx = TodParticleEmitter* this)	eax, ecx		删除并释放粒子发射器中的所有粒子。
517370	TodParticleSystem::Update(TodParticleSystem* this)	eax, ecx, edx		更新粒子系统中的所有发射器。若更新后系统中不存在活动的发射器，则粒子系统自身消失。
5173E0	TodParticleEmitter::CrossFadeParticle;(esi = TodParticleEmitter* theToEmitter, edi = TodParticle* theParticle, ebx = TodParticleEmitter* this)	al = bool 是否成功; ecx, edx		在目标发射器中发射一个粒子作为交叉混合的目标粒子，并设定源粒子的混合时间及目标粒子的持续时间。;若源粒子已处于交叉混合过程中或目标发射器未定义交叉混合时长，则交叉混合失败。
517490	TodParticleEmitter::DeleteParticle(TodParticle* theParticle, ecx = TodParticleEmitter* this)	eax, ecx, edx		删除并释放指定粒子。若该粒子处于交叉混合过程中，则同时删除并释放交叉混合的源粒子。
517550	TodParticleEmitter::Update(eax = TodParticleEmitter* this)	eax, ecx, edx		粒子发射器更新，包括发射器生命周期、交叉混合、发射器位置及粒子发射等的更新。;若更新后发射器的生命周期已结束，则删除发射器中所有不处于交叉混合中的粒子并令发射器本身消失。
5176A0	TodParticleEmitter::GetRenderParams(_Out_ ParticleRenderParams* theParams, TodParticle* theParticle)	al = 1; ecx, edx	0x8	获取粒子渲染所需的各项参数并写入 theParams 中。需要一个大小为 0x18 的内存区域用于存储 *theParams 的数据。当粒子为交叉混合过程中的目标粒子时，会额外将该粒子的渲染参数与源粒子进行一定比例的混合以过渡。
517E20	RenderParticle(TodTriangleGroup* theTriangleGroup, eax = ParticleRenderParams* theParams, ;               const Color& theColor, ecx = TodParticle* theParticle, Graphics* g)	eax, ecx, edx	0xC	根据粒子渲染参数、颜色及粒子本身的数据和状态等，计算粒子的绘制信息并将其写入至三角组中。;当粒子启用全屏模式时，则改为先绘制三角组，然后以 theColor 颜色填充一个屏幕大小的矩形区域。
518210	TodParticleEmitter::DrawParticle(TodTriangleGroup* theTriangleGroup, edi = TodParticle* theParticle, ;                                 Graphics* g, ebx = TodParticleEmitter* this)	eax, ecx, edx		获取粒子的渲染参数和颜色等信息并渲染粒子。不渲染不透明度为 0 的粒子，不主动渲染交叉混合的源粒子。;若粒子无图像，则改为渲染其交叉混合的源粒子（若存在）。渲染完成后，实际绘制位于 5183A0 的函数内。
518370	TodParticleSystem::Draw(ebx = Graphics* g, edi = TodParticleSystem* this)	eax, ecx, edx		绘制粒子系统中的所有发射器。
5183A0	TodParticleEmitter::Draw(Graphics* g, ecx = TodParticleEmitter* this)	eax, ecx, edx		绘制发射器中的所有粒子。若定义了仅软件(/硬件)渲染，则仅在未(/已)开启 3D 加速时才会执行绘制。
518440	TodParticleSystem::SystemMove(float theY, float theX, edi = TodParticleSystem* this)	eax, ecx, edx		将粒子系统中的所有发射器移动至浮点坐标 (theX, theY) 位置。
518480	TodParticleEmitter::SystemMove(float theY, float theX, edx = TodParticleEmitter* this)	eax, ecx, edx		将粒子发射器移动至浮点坐标 (theX, theY) 位置，并相应地移动发射器中的所有粒子。
518560	TodParticleSystem::OverrideColor;(const Color& theColor, ebx = const char* theEmitterName = 0, TodParticleSystem* this)	eax, ecx, edx		更改粒子系统中所有名为 theEmitterName（不区分大小写）的发射器中的粒子的颜色。;若指定 theEmitterName 为空指针，则更改粒子系统中所有发射器的粒子的颜色。
5185D0	TodParticleSystem::OverrideExtraAdditiveDraw;(dl = bool theEnableExtraAdditiveDraw, esi = TodParticleSystem* this)	eax, ecx, edx		更改粒子系统内所有发射器中粒子的高亮与否。
518600	TodParticleSystem::OverrideImage(esi = Image* theImage, edx = TodParticleSystem* this)	eax, ecx, edx		将粒子系统内所有发射器中粒子的图像用 *img 替换。
518630	TodParticleSystem::OverrideScale(float theScale, edx = TodParticleSystem* this)	eax, ecx, edx		更改粒子系统内所有发射器中的粒子的尺寸大小。
518670	TodParticleSystem::FindEmitterDefByName(const char* theEmitterName, TodParticleSystem* this)	eax = TodEmitterDefinition*? aDef; ecx, edx		在粒子系统定义中寻找名为 theEmitterName 的发射器的定义数据，若未找到目标发射器则返回 0。
5186D0	TodParticleEmitter::CrossFadeEmitter(eax = TodParticleEmitter* theToEmitter, ecx = TodParticleEmitter* this)	eax, ecx, edx		将当前发射器交叉混合至目标发射器，并设定当前发射器的交叉混合倒计时及目标发射器的持续时间。;同时，依次将当前发射器中的所有粒子交叉混合至目标发射器。
518790	TodParticleSystem::CrossFade(eax = const char* theEmitterName, TodParticleSystem* this)	eax, ecx, edx		在粒子系统中，依次创建新发射器并将所有名称不为 theEmitterName 的发射器交叉混合至该发射器。;若不存在该名称的发射器，或该名称的发射器未定义交叉混合时长，或发射器数量已达上限，则交叉混合失败。
518870	TodParticleHolder::~TodParticleHolder(eax = TodParticleHolder* this)	eax, ecx, edx		释放并销毁粒子系统容器。
518900	TodParticleHolder::InitializeHolder(edi = TodParticleHolder* this)	eax, ecx, edx		初始化粒子系统容器，初始化其粒子系统、发射器和粒子的数据数组及相关的内存申请器。
5189A0	TodParticleHolder::DisposeHolder(esi = TodParticleHolder* this)	eax, ecx, edx		释放粒子系统容器，释放其粒子系统、发射器和粒子的数据数组及相关的内存申请器申请的内存。
518A70	TodParticleHolder::AllocParticleSystem;(ParticleEffect theParticleEffect, int theRenderOrder, float theY, float theX, esi = TodParticleHolder* this)	eax = TodParticleSystem* aParticle; ;ecx, edx		在 theRenderOrder 图层的 (theX, theY) 处创建并初始化 theParticleEffect 粒子特效。
518AD0	TodList<ParticleID>::AddHead(const ParticleID& theHead, ebx = TodList<ParticleID>* this)	eax, ecx, edx		向粒子编号的链表的头部添加一项 theHead。对于其他整数或相当于整数的类型的链表同样适用。
518B50	TodList<ParticleID>::RemoveAll(esi = TodList<ParticleID>* this)	eax, ecx, edx		移除粒子编号的链表的所有项并回收其占用的内存区域。对于其他整数或相当于整数的类型的链表同样适用。
518B90	DataArray<TodParticleSystem>::DataArrayAlloc(edx = DataArray<TodParticleSystem>* this)	eax = TodParticleSystem* aParticleSystem; ;ecx, edx		初始化创建一个不包含任何数据的新粒子系统，在粒子系统数据数组中申请该粒子系统的内存区域。
518C20	DataArray<TodParticleEmitter>::DataArrayAlloc(edi = DataArray<TodParticleEmitter>* this)	eax = TodParticleEmitter* aEmitter; ecx, edx		初始化创建一个不包含任何数据的新粒子发射器，在粒子发射器数据数组中申请该粒子发射器的内存区域。
518CB0	DataArray<TodParticle>::DataArrayAlloc(esi = DataArray<TodParticle>* this)	eax = TodParticle* aParticle; ecx, edx		初始化创建一个不包含任何数据的新粒子，在粒子数据数组中申请该粒子的内存区域。
518D30	DataArray<TodParticle>::DataArrayTryToGet(ecx = unsigned int theId, edx = DataArray<TodParticle>* this)	eax = TodParticle*? aParticle; edx		在粒子数据数组中取得指定编号的粒子，若该编号的粒子不存在则返回 0。
518D60	GetPakPtr_TodStringFile()	eax = PakInterfaceBase*? aPak; ecx, edx		从 TodStringFile 的资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
518DD0	p_fopen_TodStringFile()	eax = PFILE*? pFile; ecx, edx		以二进制只读模式读取 LawnStrings.txt，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，;失败则返回 0。优先尝试通过资源包文件接口在 pak 资源包内读取文件，当无法获取接口时尝试直接读取文件。
518E40	TodStringListReadName(ecx = std::string& theName, const char*& thePtr)	al = bool 是否读取成功; ecx, edx	0x4	从 thePtr 指向的字符数组中读取下一个标签名称（中括号内的部分，如“[X]”中的 “X”），;将读取到的名称存储在 theName 字符串中，然后将 thePtr 指针移动至指向后中括号的下一个字符处。
518F60	TodStringRemoveReturnChars(eax = std::string& theString)	eax, ecx, edx		删去字符串 theString 中的所有换行符（0xD = '\r'）。
518FB0	TodStringListReadValue(ecx = std::string& theValue, const char*& thePtr)	al = bool 是否读取成功; ecx, edx	0x4	从 thePtr 指向的字符数组中读取标签内容（从当前位置至下一个“[”前，若无下一个“[”则读取剩余全部），;将读取到的内容存储在 theValue 字符串中，然后将 thePtr 指针移动至指向下一个“[”（若无则改为结尾）处。
519080	TodStringListReadItems(const char* theFileText)	al = bool 是否完整读取成功; ecx, edx	0x4	从 theFileText 中读取所有的字符串标签及内容，并将其一一对应地加入游戏字符串属性的容器中。
519240	TodStringListReadFile()	al = bool 是否加载成功; ecx, edx		加载“Properties\LawnStrings.txt”。
519390	TodStringListLoad()	eax, ecx, edx		尝试加载“Properties\LawnStrings.txt”，若加载失败则弹出错误弹窗。
519410	TodStringListFind(ecx = const std::string& theName, _Out_ std::string&& aValueString)	eax = std::string&& aValueString; ecx, edx	0x4	给定一个 theName 字符串，在游戏字符串属性容器中寻找 theName 对应的文本，若未找到则返回 <Missing %s>。
519520	TodStringTranslate(edx = const std::string& theName, edi = _Out_ std::string&& aValueString)	eax = std::string&& aValueString; ecx, edx		给定一个“[X]”格式的 theName 字符串，从游戏字符串属性容器中获取“X”对应的译文字符串。
5195D0	TodStringTranslate(ecx = const char* theName, esi = _Out_ std::string&& aValueString)	eax = std::string&& aValueString; ecx, edx		给定一个“[X]”格式的 theName 字符数组，从游戏字符串属性容器中获取“X”对应的译文字符串。;若在游戏字符串属性容器中未找到相应文本，则返回 <Missing %s> 字符串（其中 %s = X）。;对于不符合格式的 theName，则直接将 theName 转化为字符串。若 theName 指定空指针，则返回空字符串。
5196C0	TodStringListExists(edx = const std::string& theName)	al = 0(不存在) | 1(存在); ecx, edx		给定一个“[X]”格式的 name 字符数组，判断在 LawnStrings.txt 中是否存在与之对应的文本内容。;对于不符合“[X]”格式的 name 字符数组，则总是返回“不存在”。
5197B0	TodWriteStringSetFormat(TodStringListFormat& theCurrentFormat, const char* theFormat)	eax, ecx, edx	0x8	根据给定的“{X}”格式的字段，在 gTodStringFormats 中寻找相应的格式信息并依此修改 theCurrentFormat。
519870	TodWriteString;(int theLength = -1, int theOffset, bool drawString, DrawStringJustification theJustification, int theWidth, ; TodStringListFormat& theCurrentFormat, int theY, int theX, const std::string& theString, Graphics* g)	eax = int 实际绘制区域宽度; ecx, edx	0x28	计算以指定的格式绘制字符串从 theOffset 位置开始 theLength 长度的部分时的实际绘制区域宽度，;当 theLength = -1 时，绘制部分改为从 theOffset 位置开始至字符串结束。;当 drawString = 1 时，会同时直接在 (theX, theY) 位置处以 theWidth 为参考宽度绘制字符串（不换行）。
519B50	TodDrawStringWrappedHelper(Color theColor, bool drawString, DrawStringJustification theJustification, ;                           Font* theFont, const Rect& theRect, const std::string& theText, Graphics* g)	eax = int 实际绘制区域高度; ecx, edx	0x28	辅助计算自动换行绘制文本时的实际绘制区域高度，以便于根据对齐方式调整实际绘制起点的纵坐标。;当 drawString = 1 时，会同时直接在 theRect 矩形区域内自动换行地绘制字符串。;参数 theColor 采用值传递（一种传参方式是依次令颜色的 A、B、G、R 值依次入栈）。
51A040	TodDrawStringWrapped(DrawStringJustification theJustification, esi = const Color& theColor, Font* theFont, ;                     ebx = const Rect& theRect, edx = const std::string& theText, Graphics* g)	eax, ecx, edx	0xC	在 theRect 矩形区域内以指定的字体和对齐方式（参考 TodDrawString 函数注释）自动换行地绘制字符串。;对于“[X]”格式的字符串，会自动获取相应的翻译后的文本。;支持在字符串中使用如 {SHORTLINE} 等特殊字段，具体可参考 LawnStrings 中图鉴介绍的相关文本。;对于 { 和 } 之间的文本（含括号本身），无论其是否属于特殊字段，均不会被实际绘制。
51A150	std::wstring::~basic_string(ecx = std::wstring* this)	eax, ecx, edx		销毁宽字符串，并释放宽字符串的 c_str 占用的内存空间。
51A180	std::_Tree<std::_Tmap_traits<std::string, std::wstring>>::find;(ebx = const std::string& _Keyval, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, std::wstring>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, std::wstring>>* this)	eax = &&_Ret; ecx, edx		在字符串向宽字符串的映射容器中寻找 _Keyval 字符串对应的宽字符串。;若找到，则返回指示该对组所在位置处的迭代器否则，返回相当于 map.end() 的迭代器。
51A200	std::string::replace(unsigned int _Count, eax = unsigned int _Off, edi = std::string* this)	eax = *this; ecx, edx		以空字符串（0x65540C）的前 _Count 个字符替换自身从 _Off 开始的 1 个字符。
51A400	std::wstring::_Tidy(unsigned int _Newsize, bool _Built, ecx = std::wstring* this)	eax, ecx, edx		重置宽字符串长度为 _Newsize，即将宽字符串 _Newsize 位置的宽字符替换为终止字符。;若指定了 _Built 且宽字符串原长度大于 15 字节，则先将内存块中的数据迁移至自身的缓冲区中并释放内存块。
51A450	std::_Tree<std::_Tmap_traits<std::string, std::wstring>>::_Lbound;(ecx = const std::string& _Keyval, eax = std::_Tree<std::_Tmap_traits<std::string, std::wstring>>* this)	eax = _Node* _Bound; ecx, edx		根据红黑树的有序性，在字符串向宽字符串的映射红黑树中寻找可以放置 _Keyval 的最底层的一个节点。
51A4E0	wmemcpy_s(unsigned int _N, const wchar_t* _S2, unsigned int _N1, wchar_t* _S1)	eax, ecx, edx	0x10	将宽字符串 _S2 的前 _N 个宽字符拷贝至 _S1 处，_N1 表示 _S1 处的最大容量。
51A500	std::wstring::_Eos(unsigned int _Newsize, ecx = std::wstring* this)	eax, ecx		强制宽字符串在 _Newsize 位置处结束，并舍弃该位置开始向后的内容。
51A530	ToolTipWidget::GetLines(std::vector<std::string>& theLines, ToolTipWidget* this)	eax, ecx, edx		将鼠标悬浮标签的正文文本的每一行文字分别作为一个字符串元素存储在向量容器 theLines 中。;处理换行时，若一个由空格或换行符分隔的自然行的宽度未达到宽度参考值，则将下一行并入此行，可叠加。
51A710	ToolTipWidget::CaculateSize(ToolTipWidget* this)	eax, ecx, edx		先根据标题和警告文本计算并赋值悬浮标签的一个宽度参考值，依此分隔并取得正文每一行的文本，;然后综合考虑标题、警告和每一行正文的字符串以计算并赋值悬浮标签的大小。
51A8D0	ToolTipWidget::SetLabel(edx = const std::string& theLabel, esi = ToolTipWidget* this)	eax, ecx, edx		设置鼠标悬浮标签的正文文本。对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。
51A950	ToolTipWidget::SetTitle(edx = const std::string& theTitle, esi = ToolTipWidget* this)	eax, ecx, edx		设置鼠标悬浮标签的标题文本。对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。
51A9D0	ToolTipWidget::SetWarningText(edx = const std::string& theWarningText, esi = ToolTipWidget* this)	eax, ecx, edx		设置鼠标悬浮标签的红字提示文本。对于“[X]”格式的字符串，会自动在 LawnStrings 中获取相应文本。
51AA50	ToolTipWidget::Draw(ebx = Graphics* g, ToolTipWidget* this)	eax, ecx, edx		绘制鼠标悬浮标签及标签上的所有文本。
51AE30	std::vector<std::string>::size(ecx = std::vector<std::string>* this)	eax = int _Size; ecx, edx		计算字符串的向量容器中包含的字符串元素数量，即：(末尾指针 - 头部指针) / 0x1C。
51AE60	std::vector<std::string>::operator[](unsigned int _Pos, ecx = std::vector<std::string>* this)	eax = std::string& _Val; ecx, edx		获取字符串的向量容器中的第 _Pos 个字符串，返回对该字符串的引用。
51AEA0	std::vector<std::string>::push_back(const std::string& _Val, esi = std::vector<std::string>* this)	eax, ecx, edx		在字符串的向量容器的尾部添加一个字符串元素。
51AF50	std::vector<std::string>::insert;(std::vector<std::string>::iterator _Where, const std::string& _Val, ; _Out_ std::vector<std::string>::iterator&& _Ret, eax = std::vector<std::string>* this)	eax = &&_Ret; ecx, edx		在字符串的向量容器的 _Where 位置插入一个字符串元素 _Val，并返回指示该元素所在位置的迭代器。
51B010	std::vector<std::string>::_Buy(esi = unsigned int _Capacity, edi = std::vector<std::string>* this)	al = 1; ecx, edx		将字符串的向量容器扩容至 _Capacity。
51B050	std::vector<std::string>::~vector<std::string>(esi = std::vector<std::string>* this)	eax, ecx, edx		销毁字符串的向量容器，释放数组占用的内存空间。
51B090	std::vector<std::string>::_Ufill<std::string*>;(edx = const std::string& _Val, esi = unsigned int _Count, edi = std::string* _Ptr)	eax = std::string* _Last, ecx, edx		以 _Val 字符串填充从 _First 开始的 _Count 个未初始化的字符串区域，;返回填充完成后指向目标字符串区域中最后一个被填充的字符串的指针。
51B0C0	std::vector<std::string>::_Insert_n;(std::vector<std::string>::iterator _Where, const std::string& _Val, std::vector<std::string>* this)	eax, ecx, edx		在字符串的向量容器的 _Where 位置插入 1 个字符串元素 _Val。
51B3D0	std::vector<std::string>::_Xlen()	eax, ecx, edx		当字符串的向量容器过长时，抛出错误。
51B450	std::_Allocate<std::string>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符串所需要的内存空间，单个字符串占用的内存大小为 0x1C。;当 _Count 个字符串的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
51B4B0	std::vector<std::string>::_Umove<std::string*>;(edx = std::string* _Ptr, edi = std::string* _Last, esi = std::string* _First)	eax, ecx, edx		将 _First 和 _Last 之间的字符串移动至 _Ptr 处的未初始化区域。
51B4E0	std::fill<std::string*, std::string>;(ebx = const std::string& _Val, edi = std::string* _Last, eax = std::string* _First)	eax, ecx, edx		以 _Val 字符串填充 _First 至 _Last 之间的所有字符串。
51B500	stdext::_Unchecked_move_backward<std::string*, std::string*>;(edi = std::string* _Dest, eax = std::string* _Last, ebx = std::string* _First)	eax = std::string* _Begin, ecx, edx		将 _First 和 _Last 之间的字符串移动以 _Dest 为结尾的未初始化区域，;返回移动完成后指向目标字符串区域中第一个字符串的指针。
51B550	std::_Uninit_fill_n<std::string*>;(std::_Range_checked_iterator_tag __formal, std::_Nonscalar_ptr_iterator_tag __formal, ; const std::string& _Val, ecx = unsigned int _Count, std::string* _First)	eax, ecx, edx	0x10	以 _Val 字符串填充从 _First 开始的 _Count 个未初始化的字符串区域。
51B5F0	std::_Destroy_range<std::string>;(std::_Nonscalar_ptr_iterator_tag __formal, edi = std::string* _Last, eax = std::string* _First)	eax, ecx, edx	0x4	销毁从 _First 至 _Last 之间的所有字符串。
51B630	std::_Uninit_move<std::string*, string*>(std::_Range_checked_iterator_tag __formal, std::_Swap_move_tag __formal, ;                                    std::string* _Dest, std::string* _Last, ecx = std::string* _First)	eax, ecx, edx	0x10	将 _First 和 _Last 之间的字符串移动至 _Dest 处的未初始化区域。
51B750	stdext::_Move_backward_opt<std::string*, std::string*>;(std::_Range_checked_iterator_tag __formal, std::_Swap_move_tag __formal, std::forward_iterator_tag __formal, ;eax = std::string* _Dest, ecx = std::string* _Last, std::string* _First)	eax, ecx, edx	0x10	将 _First 和 _Last 之间的字符串移动以 _Dest 为结尾的未初始化区域。
51B7C0	TrailDefinition::TrailDefinition(ecx = TrailDefinition* this)	eax = *this; ecx, edx		初始化创建轨迹定义。需要一个大小为 0x38 的内存区域用于构造 this。
51B7F0	TrailDefinitionConstructor(void* thePointer)	eax = void* thePointer; ecx	0x4	TrailDefinition 实例的构造函数。
51B830	TrailLoadADef(ecx = const char* theTrailFileName, edi = TrailDefinition* theTrailDef)	al = bool 是否加载成功; ecx, edx	0x4	从指定轨迹定义文件（实际为对应的 .compiled 文件）中读取轨迹定义数据并存储在 theTrailDef 中。
51B960	TrailLoadDefinitions()	eax, ecx, edx		根据轨迹参数分别从相应文件加载所有轨迹的定义数据。当出现加载失败时，会弹出错误弹窗。;此函数仅在 4528E0 的函数中（452B9C 处）有过一次调用，故其原有的两个参数在原版中被内联至函数内：;【TrailParams* theTrailParamArray（实参 = gLawnTrailArray(0x6A19F4)）】;轨迹参数（TrailParams）指定了一种轨迹类型与该轨迹的数据文件的文件名之间的对应关系;【int theTrailParamArraySize（实参 = 1）】轨迹参数数组的长度，其值等于轨迹类型的数量。
51BAB0	TrailFreeDefinitions()	eax, ecx, edx		根据轨迹定义结构图释放轨迹定义数组，清除全局轨迹参数数组指针。
51BB30	Trail::AddPoint(float y, float x, esi = Trail* this)	eax, ecx, edx		为轨迹增加一个最新的轨迹点 (x, y)。当已有轨迹点数量达到上限时，舍弃最早的一个轨迹点。
51BC00	Trail::Update(eax = Trail* this)	ecx, edx		轨迹更新，当其存在时间达到总时长时，若循环则将其存在时间重置为 0，否则令其消失。
51BC40	Trail::GetNormalAtPoint(esi = SexyVector2& theNormal, eax = int nIndex, ecx = Trail* this)	al = 0(向量不存在) | 1(向量存在); ecx, edx		取得轨迹在第 nIndex 个轨迹点处的瞬时速度的法向上的一个标准向量赋值给 theNormal。
51BDD0	Trail::Draw(Graphics* g, Trail* this)	eax, ecx, edx		绘制轨迹。
51C470	TypingCheck::TypingCheck(edi = const std::string& thePhrase, TypingCheck* this)	eax, ecx, edx		初始化指令内容字符串及当前记录。需要一个大小为 0x38 的内存区域用于构造 this。
51C4D0	TypingCheck::SetPhrase(edi = const std::string& thePhrase, ebx = TypingCheck* this)	eax, ecx, edx		令指令内容额外增加一个字符串。本质上是依次将字符串中的每个字符通过 AddChar() 函数加入到指令表达式中。
51C510	TypingCheck::AddChar(char theChar, TypingCheck* this)	eax, ecx, edx		令指令内容额外增加一个字符，实际加入指令表达式的字符为 theChar 对应的按键值。
51C5A0	TypingCheck::Check(KeyCode theKey, TypingCheck* this)	al = bool isCodeTyped; ecx, edx		更新指令对当前按键情况的记录，当指令被完整输入后清空记录并返回 al = 1。
51C6A0	std::string::basic_string(char _Ch, unsigned int _Count, ecx = std::string* this)	eax = *this; ecx, edx		以 _Count 个 _Ch 字符创建字符串。需要一个大小为 0x1C 的内存区域用于构造 this。
51C6D0	std::string::assign(char _Ch, unsigned int _Count, ecx = std::string* this)	eax = *this; ecx, edx		将字符串的文本内容设置为 _Count 个 _Ch 字符。
51C760	UserDialog::UserDialog(LawnApp* theApp, UserDialog* this)	eax = *this; ecx, edx		初始化创建用户对话，需要一个大小为 0x184 的内存区域用于构造 this。
51CBC0	UserDialog::`scalar deleting destructor'(unsigned int flags, ecx = UserDialog* this)	eax = *this; ecx, edx		删除用户对话，当 flags 的第 0 位置 1 时会额外释放对话本身占用的内存空间。		【虚函数】[[[(UserDialog*)]+0]+0]
51CBE0	UserDialog::~UserDialog(ecx = UserDialog* this)	eax, ecx, edx		销毁用户对话，删除用户列表、重命名按钮和删除按钮。
51CC80	UserDialog::Resize(int theHeight, int theWidth, int theY, int theX, ecx = UserDialog* this)	eax, ecx, edx		设置用户对话内用户列表、重命名按钮和删除按钮及其本身的位置和大小。		【虚函数】[[[(UserDialog*)]+0]+A0]
51CD20	UserDialog::GetPreferredHeight(int theWidth, ecx = UserDialog* this)	eax = int aHeight; ecx, edx		当指定用户对话的宽度时，计算对话的首选高度值。		【虚函数】[[[(UserDialog*)]+0]+124]
51CD40	UserDialog::AddedToManager(WidgetManager* theWidgetManager, ecx = UserDialog* this)	eax, ecx, edx		用户对话加入控件管理器，并将其用户列表、重命名按钮和删除按钮加入其子控件链表中。		【虚函数】[[[(UserDialog*)]+0]+50]
51CDC0	UserDialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = UserDialog* this)	eax, ecx, edx		用户对话移出控件管理器，并将其用户列表、重命名按钮和删除按钮移出其子控件链表。		【虚函数】[[[(UserDialog*)]+0]+54]
51CE10	UserDialog::GetSelName(esi = _Out_ std::string&& aSelName, ecx = UserDialog* this)	eax = std::string&& aSelName, ecx, edx		取得用户对话中当前选中的用户的用户名。
51CE70	UserDialog::FinishDeleteUser(esi = UserDialog* this)	eax, ecx, edx		用户对话中完成删除用户对话后，在用户列表中移除被删除的用户。
51CF50	UserDialog::Draw(Graphics* g, ecx = UserDialog* this)	eax, ecx, edx		绘制用户对话。		【虚函数】[[[(UserDialog*)]+0]+68]
51CF60	UserDialog::ListClicked(int theClickCount, int theIdx, int theId, ecx = ListListener* this)	eax, ecx, edx		鼠标点击用户对话中编号为 theId 的列表的第 theIdx 行，若点击“创建新用户”行则进行创建新用户对话，;否则若双击其他行则视为选择切换到点击的用户存档并结束用户对话。		【虚函数】[[[(ListListener*)]+0]+0]/[[[(UserDialog*)]+16C]+0]
51CFA0	UserDialog::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		UserDialog 中按下按钮时，判断按下的按钮并依此执行相应的事件。		【虚函数】[[[(ButtonListener*)]+0]+8]
51D060	UserDialog::EditWidgetText(const std::string& theString, int theId, ecx = EditListener* this)	eax, ecx, edx		输入字符串，视为在游戏中按下了 theId + 2000 编号的按钮。		【虚函数】[[[(EditListener*)]+0]+0]/[[[(UserDialog*)]+170]+0]
51D080	UserDialog::AllowChar(char theChar, int theId, ecx = EditListener* this)	al = 0(不允许) | 1(允许); ecx, edx		判断是否允许输入 theChar 字符。当且仅当字符为十进制数字时返回允许。		【虚函数】[[[(EditListener*)]+0]+8]/[[[(UserDialog*)]+170]+8]
51D0A0	std::operator!=(eax = const std::string& _Right, ecx = const std::string& _Left)	al = bool _Neq; ecx, edx		判断两个字符串是否不相等。
51D0E0	ZenGarden::DrawPottedPlantIcon;(eax = PottedPlant* thePottedPlant, float y, float x, ecx = Graphics* g, edx = ZenGarden* this)	eax, edx		绘制盆栽植物图标，即：以 0.7 倍缩放绘制带花盆的盆栽植物。
51D110	ZenGarden::DrawPottedPlant;(bool theDrawPot, float theScale, PottedPlant* thePottedPlant, float y, float x, Graphics* g, ZenGarden* this)	eax, ecx, edx		绘制盆栽植物。其中 theDrawPot 指定是否绘制花盆。
51D3A0	ZenGarden::PlacePottedPlant(int thePottedPlantIndex, ZenGarden* this)	eax = Plant* aPlant; ecx, edx		禅境花园中，放置用户存档中第 thePottedPlantIndex 株盆栽植物，并根据存档更新该植物部分基础状态。
51D5C0	ZenGarden::RemovePottedPlant(eax = Plant* thePlant, ZenGarden* this)	eax, ecx, edx		禅境花园中移除一株植物。
51D630	ZenGarden::ZenGardenInitLevel(esi = ZenGarden* this)	eax, edx		禅境花园初始化关卡，放置花园相应的盆栽植物和蜗牛，同时播放花园的背景音乐。
51D6B0	ZenGarden::PlantCanHaveChocolate(eax = Plant* thePlant, edx = ZenGarden* this)	al = 0(否) | 1(是); ecx, edx		判断植物当前是否可以使用巧克力。
51D710	ZenGarden::CanDropChocolate(eax = ZenGarden* this)	al = 0(不能) | 1(能); ecx, edx		判断能否将巧克力作为掉落物。当且仅当玩家已购买蜗牛且巧克力数量未达到上限时，返回“能”。
51D740	ZenGarden::IsZenGardenFull(bool theIncludeDroppedPresents, esi = ZenGarden* this)	al = 0(否) | 1(是); ecx, edx		判断禅境花园的温室中是否所有的植物位置均已被占满。;其中 theIncludeDroppedPresents 指定是否包含当前场上已掉落的盆栽植物礼盒可能需要预留的位置。
51D7B0	ZenGarden::FindOpenZenGardenSpot(int& theSpotY, int& theSpotX, eax = ZenGarden* this)	eax, ecx, edx		一定程度随机地取得一个空置的盆栽植物位，将其行数和列数分别赋值给 theSpotY 和 theSpotX。
51D8C0	ZenGarden::AddPottedPlant(edx = PottedPlant* thePottedPlant, ZenGarden* this)	eax, ecx, edx		禅境花园增加新盆栽植物，将该植物写入用户存档。若当前位于禅境花园中，则立即放置该盆栽植物。
51D970	ZenGarden::GetPlantSellPrice(eax = Plant* thePlant, edx = ZenGarden* this)	eax = int aPrice; ecx, edx		禅境花园中，取得植物的出售价格。
51DA00	ZenGarden::MouseDownWithMoneySign(Plant* thePlant, ZenGarden* this)	eax, ecx, edx		禅境花园中手持金钱标记时点击植物，进行确认出售植物的戴夫对话，若确定出售则执行出售的相关事件。
51DF40	ZenGarden::PlantFertilized(esi = Plant* thePlant, ZenGarden* this)	eax, ecx, edx		需要施肥的植物被施肥后，生长并掉落一定数量的钱币。
51E110	ZenGarden::PlantFulfillNeed(esi = Plant* thePlant, ZenGarden* this)	eax, ecx, edx		存在高级需求的植物的需求被满足后，掉落一定数量的钱币。
51E290	ZenGarden::PlantsNeedWater(ZenGarden* this)	al = 0(否) | 1(是); ecx, edx		判断禅境花园中是否有植物需要浇水。
51E2F0	ZenGarden::PlantCanBeWatered(eax = Plant* thePlant, ecx = ZenGarden* this)	al = 0(否) | 1(是); ecx, edx		禅境花园中，判断植物是否需要被浇水。
51E320	ZenGarden::CountPlantsNeedingFertilizer(ZenGarden* this)	eax = int aCount; ecx, edx		取得禅境花园中需要施肥的盆栽植物的数量。
51E390	ZenGarden::AllPlantsHaveBeenFertilized(ecx = ZenGarden* this)	al = 0(否) | 1(是); ecx, edx		判断禅境花园中是否所有盆栽植物均至少已被有效施肥一次，即判断花园中是否不存在处于发芽阶段的盆栽。
51E3D0	ZenGarden::PlantWatered(eax = Plant* thePlant, ecx = ZenGarden* this)	eax, ecx, edx		需要浇水的植物被浇水后，更新植物的需求并更新教程状态。
51E560	ZenGarden::UpdatePlantEffectState(eax = Plant* thePlant, ZenGarden* this)	eax, ecx, edx		禅境花园中，更新植物的状态，并依此处理植物愉悦特效的创建或移除等事件。
51E730	ZenGarden::AddPlantHappyEffect(ecx = Plant* thePlant, eax = ZenGarden* this)	eax, ecx, edx		创建植物愉悦特效。
51E7E0	ZenGarden::RemovePlantHappyEffect(edi = Plant* thePlant, ZenGarden* this)	eax, ecx, edx		移除植物愉悦特效。
51E890	ZenGarden::WasPlantNeedFulfilledToday(PottedPlant* thePottedPlant)	al = 0(否) | 1(是); ecx, edx		判断今天盆栽植物的需求是否已被满足。
51E910	ZenGarden::PlantShouldRefreshNeed(PottedPlant* thePottedPlant)	al = 0(否) | 1(是); ecx, edx		判断盆栽植物是否应当刷出新的需求。
51E990	ZenGarden::UpdatePlantNeeds(ZenGarden* this)	eax, ecx, edx		更新盆栽植物的需求状态。同时当盆栽植物的需求需要刷新时，刷新随机的植物需求。
51EA30	ZenGarden::GetPottedPlantNeed(esi = PottedPlant* thePottedPlant)	eax = PottedPlantNeed aNeed; ecx, edx		禅境花园中，取得盆栽植物的当前需求。
51EB70	ZenGarden::MouseDownWithFeedingTool(CursorType theCursorType, int y, int x, eax = ZenGarden* this)	eax, ecx, edx		禅境花园中，手持 theCursorType 进给工具下，鼠标左键或中键点击 (x, y) 位置处。
51F220	ZenGarden::FeedChocolateToPlant(eax = Plant* thePlant, ebx = ZenGarden* this)	eax, ecx, edx		禅境花园中给植物喂食巧克力。
51F2A0	ZenGarden::DoFeedingTool(GridItemState theToolType, int y, int x, ZenGarden* this)	eax, ecx, edx		禅境花园中，theToolType 进给工具生效。
51F580	ZenGarden::MouseDownWithTool(eax = CursorType theCursorType, int y, int x, ecx = ZenGarden* this)	eax, ecx, edx		禅境花园中，手持 theCursorType 工具下，鼠标左键或中键点击 (x, y) 位置处。
51F700	ZenGarden::MovePlant(int theGridY, int theGridX, Plant* thePlant, ZenGarden* this)	eax, ecx, edx		禅境花园中，将植物及其相关的粒子系统等移动至 (theGridX, theGridY) 格子中。
51F950	ZenGarden::PlantPottedDrawHeightOffset(float theScale, eax = SeedType theSeedType)	st(0) = aOffset		根据植物的大小，计算盆栽植物位置的纵向偏移高度。
51FB40	ZenGarden::AddStinky(ZenGarden* this)	eax, ecx, edx		禅境花园创建蜗牛。当且仅当玩家已购买蜗牛，且当前所在的花园为温室种植园时，蜗牛才会被成功创建。
51FCD0	ZenGarden::StinkyPickGoal(GridItem* theStinky, ZenGarden* this)	eax, ecx, edx		计算并赋值蜗牛应当移动至的目标位置坐标。
520120	ZenGarden::StinkyWakeUp(esi = GridItem* theStinky, eax = ZenGarden* this)	eax, ecx, edx		蜗牛醒来，播放唤醒动画并销毁睡眠特效动画。
5201D0	ZenGarden::StinkyStartFallingAsleep(edi = GridItem* theStinky, eax = ZenGarden* this)	eax, ecx, edx		蜗牛开始进入睡眠状态，播放蜷缩动画。
520240	ZenGarden::StinkyFinishFallingAsleep(int theBlendTime, GridItem* theStinky, ZenGarden* this)	eax, ecx, edx		蜗牛进入睡眠状态，播放睡眠动画，同时创建并绑定睡眠特效动画。蜗牛首次睡觉时额外设置唤醒的提示字幕。
5203E0	ZenGarden::StinkyWakeUp(bool theStinkyHighOnChocolate, esi = GridItem* theStinky, eax = ZenGarden* this)	eax, ecx, edx		当蜗牛不处于兴奋状态时，清除所有轨迹残影否则，更新蜗牛的轨迹残影。
520470	ZenGarden::StinkyAnimRateUpdate(eax = GridItem* theStinky, edi = ZenGarden* this)	eax, ecx, edx		根据蜗牛的当前动作及兴奋状态，更新蜗牛动画的速率。
520500	ZenGarden::StinkyUpdate(GridItem* theStinky, ZenGarden* this)	eax, ecx, edx		禅境花园中蜗牛的动作、状态、行为等的更新。
520AC0	ZenGarden::ZenToolUpdate(eax = GridItem* theZenTool, edi = ZenGarden* this)	eax, ecx, edx		禅境花园中正在使用中的花园工具的更新。
520B30	ZenGarden::ZenGardenUpdate(ecx = ZenGarden* this)	eax, ecx, edx		禅境花园的关卡状态、戴夫状态、植物、蜗牛、花园工具、教程状态等的总更新。
520CF0	ZenGarden::GetStinky(ebx = ZenGarden* this)	eax = GridItem*? aStinky; ecx, edx		取得禅境花园中编号最小的一只蜗牛，若不存在蜗牛则返回 0。
520D30	ZenGarden::GoToNextGarden(ZenGarden* this)	eax, ecx, edx		离开当前花园，进入下一个花园，并延迟加载下一个花园需要的贴图资源。
5210F0	ZenGarden::MouseDownWithFullWheelBarrow(int y, int x, ZenGarden* this)	eax, ecx, edx		禅境花园中，鼠标手持装载盆栽植物的手推车点击 (x, y) 位置处，尝试将盆栽植物放置在目标位置。
521280	ZenGarden::MouseDownWithEmptyWheelBarrow(eax = Plant* thePlant, ecx = ZenGarden* this)	eax, ecx, edx		禅境花园中，鼠标手持空的手推车点击 thePlant 植物，将盆栽植物装入手推车中。
521310	ZenGarden::GetPottedPlantInWheelBarrow(eax = ZenGarden* this)	eax = PottedPlant* aPottedPlant; ecx, edx		禅境花园中，取得手推车中的盆栽植物。
521350	ZenGarden::PixelToGridX(edi = int theY, ebx = int theX, eax = ZenGarden* this)	eax = int aGridX; ecx, edx		禅境花园中，根据指定的坐标，计算该点位于当前花园中的列数。
5213D0	ZenGarden::PixelToGridY(edi = int theY, ebx = int theX, eax = ZenGarden* this)	eax = int aGridY; ecx, edx		禅境花园中，根据指定的坐标，计算该点位于当前花园中的行数。
521450	ZenGarden::GridToPixelX(esi = int theGridY, edi = int theGridX, eax = ZenGarden* this)	eax = int aPixelX; ecx, edx		禅境花园中，根据给定的行数和列数，取得相应格子的横坐标。
5214C0	ZenGarden::GridToPixelY(esi = int theGridY, edi = int theGridX, eax = ZenGarden* this)	eax = int aPixelY; ecx, edx		禅境花园中，根据给定的行数和列数，取得相应格子的纵坐标。
521530	ZenGarden::DrawBackdrop(Graphics* g, ZenGarden* this)	eax, ecx, edx		水族馆中手持手推车或手套时，在所有可以放置植物的位置处绘制阴影。
521660	ZenGarden::ShowTutorialArrowOnWateringCan(ZenGarden* this)	eax, ecx, edx		播放拿起水壶的字幕并在水壶按钮处显示教程箭头。
5217A0	ZenGarden::AdvanceCrazyDaveDialog(eax = ZenGarden* this)	eax, ecx, edx		禅境花园中，推进戴夫对话的进程。
521880	ZenGarden::MouseDownZenGarden;(ecx = HitResult* theHitResult, int theClickCount, int y, int x, ZenGarden* this)	al = bool 是否为有特殊意义的鼠标按下; ;ecx, edx		禅境花园中鼠标按下时，根据鼠标处的物体分别执行不同的鼠标按下事件。
521AC0	ZenGarden::SetPlantAnimSpeed(Plant* thePlant, eax = ZenGarden* this)	eax, ecx, edx		禅境花园中，根据植物的类型及状态等设置植物的动画速率并同步植物各部分动画的循环率。
521CC0	ZenGarden::PlantGetMinutesSinceHappy(eax = Plant* thePlant, edx = ZenGarden* this)	eax = int aMinitus; ecx, edx		禅境花园中，取得植物距离上次被满足需求经过的分钟数，一定程度上时间越久则植物生产钱币的间隔就会越长。;若植物正处于兴奋状态（在近 5 分钟内被喂食过巧克力），则返回 0。
521D40	ZenGarden::PlantUpdateProduction(esi = Plant* thePlant, edi = ZenGarden* this)	eax, ecx, edx		禅境花园中，更新植物的生产过程及生产速率。
521E70	ZenGarden::PottedPlantUpdate(eax = Plant* thePlant, ecx = ZenGarden* this)	eax, ecx, edx		禅境花园中更新盆栽植物。
521F30	ZenGarden::PottedPlantUpdate(eax = Plant* thePlant, edx = Graphics* g, ecx = ZenGarden* this)	eax, ecx, edx		禅境花园中，当植物存在需求时，绘制植物的需求气泡。
521FE0	ZenGarden::WakeStinky(eax = ZenGarden* this)	eax, ecx, edx		禅境花园中点击睡觉的蜗牛时唤醒蜗牛，并重新赋值存档中关于蜗牛状态的记录值。
522090	ZenGarden::IsStinkyHighOnChocolate(ZenGarden* this)	al = 0(否) | 1(是); ecx, edx		判断蜗牛当前是否处于食用巧克力后 1 小时内的亢奋状态。
5220C0	ZenGarden::ShouldStinkyBeAwake(esi = ZenGarden* this)	al = 0(不能) | 1(能); ecx, edx		判断蜗牛能否继续工作。蜗牛在近 1 小时内未食用过巧克力且已经连续工作超过 3 分钟时将开始睡觉。
522110	ZenGarden::OpenStore(ZenGarden* this)	eax, ecx, edx		从禅境花园进入戴夫的商店第 1 页，并等待商店对话结束后重新播放禅境花园的背景音乐和放置蜗牛。
5222D0	ZenGarden::SetupForZenTutorial(ecx = ZenGarden* this)	eax, ecx, edx		根据关卡界面的教程状态，相应地进行对按钮、戴夫等的设定和对花园场景的布置。
5223B0	ZenGarden::PickRandomSeedType()	eax = SeedType aSeedType; ecx, edx		从豌豆射手至西瓜投手的植物中（花盆和金盏花除外），随机取得一种植物类型。
5223F0	ZenGarden::LeaveGarden(ebx = ZenGarden* this)	eax, ecx, edx		禅境花园切换或离开花园时，令当前场上即将生效的花园工具立即生效、收集中的钱币立即完成收集。
522510	Zombie::Zombie(eax = Zombie* this)	eax = *this; ecx, edx		初始化僵尸基础数据。创建新僵尸时调用，初始化僵尸的图像矩形、判定矩形、图层、指针等。
522580	Zombie::ZombieInitialize(int theFromWave, Zombie* theParentZombie = 0, bool theVariant, ;                         ZombieType theZombieType, eax = int theRow, Zombie* this)	eax, ecx, edx		初始化僵尸信息和数据。
524040	Zombie::SetupDoorArms(bool theShow, ebx = Reanimation* aReanim)	eax, ecx, edx	0x4	根据铁栅门的显示或隐藏（theShow），设定铁栅门僵尸手部相关动画轨道的渲染分组。
5240B0	Zombie::SetupReanimLayers(esi = ZombieType theZombieType, eax = Reanimation* aReanim)	eax, ecx, edx		初始化设置以普通僵尸为基本模型的僵尸的各动画轨道的渲染分组。
524210	Zombie::ShowDoorArms(bool theShow, esi = Zombie* this)	eax, ecx, edx		根据铁栅门的显示或隐藏（theShow）及僵尸手臂的存在情况，设定铁栅门僵尸手部相关动画轨道的渲染分组。
524280	Zombie::ReanimIgnoreClipRect(bool theIgnoreClipRect, const char* theTrackName, ecx = Zombie* this)	eax, edx		依次设定僵尸动画所有名称恰好为 theTrackName 的轨道是否可以在绘图时无视裁剪矩形而显示完整图像。
524310	Zombie::ReanimReenableClipping(eax = Zombie* this)	eax, ecx, edx		设定僵尸动画所有轨道均不能在绘图时无视裁剪矩形。
524370	Zombie::LoadPlainZombieReanim(edi = Zombie* this)	eax, ecx, edx		对以普通僵尸为基本模型的僵尸调用，初始化其各轨道属性，是其他各初始化普通僵尸形象的函数的外层函数。
524470	Zombie::LoadReanim(ReanimationType theReanimationType, eax = Zombie* this)	eax = Reanimation* aBodyReanim, ecx, edx		初始化加载僵尸的动画，初始化僵尸时调用。该函数会新创建一个 theReanimationType 动画作为僵尸的动画。;可以作为更改僵尸动画的函数使用，但需要额外调用4733F0函数令原僵尸动画消失。
524590	Zombie::CountBungeesTargetingSunFlowers(Zombie* this)	eax = int aCount; ecx, edx		取得场上正在锁定阳光生产类植物的蹦极僵尸的数量。
5246A0	Zombie::PickBungeeZombieTarget(int theColumn = -1, Zombie* this)	eax, ecx, edx		在第 theColumn 列寻找蹦极僵尸的目标格子，当 theColumn = -1 时取消列的限制而在全屏内寻找目标。;若成功取得目标格子，则以此格子赋值僵尸的行、列数及横、纵坐标当无可用目标时，直接令僵尸消失。
524970	Zombie::BungeeDropZombie;(eax = int theGridY, ecx = int theGridX, Zombie* theDroppedZombie, ebx = Zombie* this)	eax, ecx, edx		令蹦极僵尸在 (theGridX, theGridY) 格子处空投 theDroppedZombie 僵尸。
524A70	Zombie::PickRandomSpeed(eax = Zombie* this)	eax, ecx, edx		在可能的范围内随机僵尸动画速度。此函数内部根据僵尸状态等分别以不同的传参调用了52F050的函数。
524C70	Zombie::BungeeStealTarget(eax = Zombie* this)	eax, ecx, edx		蹦极僵尸寻找并锁定目标植物。
524D70	Zombie::BungeeLiftTarget(eax = Zombie* this)	eax, ecx, edx		蹦极僵尸开始偷走目标植物。
524EF0	Zombie::BungeeLanding(Zombie* this)	eax, ecx, edx		蹦极僵尸下落及落地相关事件的触发，包括音效的播放、保护伞的判定、空投僵尸的释放等。
525180	Zombie::UpdateZombieBungee(edi = Zombie* this)	eax, ecx, edx		【僵尸特性函数】蹦极僵尸的特性更新函数。
525350	Zombie::PogoBreak(unsigned int theDamageFlags, Zombie* this)	eax, ecx, edx		跳跳僵尸失去起跳器。特别地，当伤害类型的 DOESNT_LEAVE_BODY 标志为 1 时，不创建掉落的粒子特效。
525460	Zombie::IsBouncingPogo(eax = Zombie* this)	al = 0(否) | 1(是)		判断僵尸是否为弹跳中的跳跳僵尸。
525480	Zombie::UpdateZombiePogo(edi = Zombie* this)	eax, ecx, edx		【僵尸特性函数】跳跳僵尸的特性更新函数。
525730	Zombie::ZombieCatapultFire(eax = Plant* thePlant = 0, ecx = Zombie* this)	eax, ecx, edx		僵尸对植物投掷篮球。若指定 thePlant 为 0，则改为对前方 300 距离的位置投掷篮球。
525890	Zombie::FindCatapultTarget(Zombie* this)	eax = Plant*? aTargetPlant; ecx, edx		取得投石车僵尸攻击的目标植物，若不存在目标植物则返回 0。
5259D0	Zombie::UpdateZombieCatapult(eax = Zombie* this)	eax, edx		【僵尸特性函数】投石车僵尸的特性更新函数。
525B60	Zombie::LandFlyer(unsigned int theDamageFlags, eax = Zombie* this)	eax, ecx, edx		气球僵尸开始下坠。特别地，当伤害类型的 DOESNT_LEAVE_BODY 标志为 1 时，不会造成气球破裂。
525BE0	Zombie::UpdateZombieFlyer(edi = Zombie* this)	eax, ecx, edx		【僵尸特性函数】气球僵尸的特性更新函数。
525CE0	Zombie::UpdateZombieNewspaper(Zombie* this)	eax, ecx, edx		【僵尸特性函数】读报僵尸的特性更新函数。
525DC0	Zombie::UpdateZombiePolevaulter(Zombie* this)	eax, ecx, edx		【僵尸特性函数】撑杆僵尸的特性更新函数。
526190	Zombie::IsTanglekelpTarget(edi = Zombie* this)	al = 0(否) | 1(是); ecx, edx		判断僵尸是否为缠绕海草所缠绕的目标僵尸。
5261E0	Zombie::UpdateZombieDolphinRider(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】海豚骑士僵尸的特性更新函数。
526720	Zombie::UpdateZombieSnorkel(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】潜水僵尸的特性更新函数。
526AE0	Zombie::UpdateZombieJackInTheBox(Zombie* this)	eax, ecx, edx		【僵尸特性函数】玩偶匣僵尸的特性更新函数。
526D10	Zombie::UpdateZombieGargantuar(Zombie* this)	eax, ecx, edx		【僵尸特性函数】伽刚特尔、暴走伽刚特尔的特性更新函数。
5272E0	Zombie::UpdateZombieImp(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】小鬼僵尸的特性更新函数。
5273D0	Zombie::UpdateZombiePeaHead(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】豌豆射手僵尸的特性更新函数。
5275C0	Zombie::UpdateZombieJalapenoHead(edi = Zombie* this)	eax, ecx, edx		【僵尸特性函数】火爆辣椒僵尸的特性更新函数。
527750	Zombie::UpdateZombieGatlingHead(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】机枪射手僵尸的特性更新函数。
527AA0	Zombie::UpdateZombieSquashHead(Zombie* this)	eax, ecx, edx		【僵尸特性函数】窝瓜僵尸的特性更新函数。
527F20	Zombie::BobsledCrash(ebx = Zombie* this)	eax, ecx, edx		雪橇僵尸小队失去雪橇，重置其中每一只僵尸的状态、坐标、动画速率等数据。
528050	Zombie::UpdateZombieBobsled(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】雪橇僵尸（小队）的特性更新函数。
528240	Zombie::DiggerLoseAxe(eax = Zombie* this)	eax, ecx, edx		矿工僵尸失去镐子。
528310	Zombie::UpdateZombieDigger(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】矿工僵尸的特性更新函数。
528760	Zombie::SummonBackupDancer(int thePosX, int theRow, eax = Zombie* this)	eax = ZombieID aZombieID; ecx, edx		在 theRow 行 thePosX 位置召唤伴舞僵尸，召唤成功则返回该伴舞僵尸的编号，召唤失败则返回 0。
528970	Zombie::SummonBackupDancers(esi = Zombie* this)	eax, ecx, edx		补齐召唤伴舞僵尸，并重新赋值跟随僵尸编号数组中的相关数据。
528A50	Zombie::NeedsMoreBackupDancers(edi = Zombie* this)	al = 0(否) | 1(是); ecx, edx		判断舞王僵尸是否需要且可以召唤新的伴舞僵尸。
528B00	Zombie::PlayZombieReanimation(float theAnimRate, int theBlendTime, ReanimLoopType theLoopType, ;                              const char* theTrackName, edi = Zombie* this)	eax, ecx, edx		以 theAnimRate 速率有补间地播放僵尸 theTrackName 轨道上的动画。;当速率 theAnimRate 不为 0 时，将其记录为僵尸的原始动画速率。
528B80	Zombie::UpdateZombieBackupDancer(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】伴舞僵尸的特性更新函数。
528CA0	Zombie::UpdateZombieDancer(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】舞王僵尸的特性更新函数。
528EC0	Zombie::UpdateZombieRiseFromGrave(esi = Zombie* this)	eax, ecx, edx		更新从墓碑中出现的僵尸的高度，并于其完全出土后对其状态等进行适当的设置。
528F70	Zombie::ZombiquariumFindClosestBrain(eax = Zombie* this)	al = bool isTargetingBrain; ecx, edx		水族馆潜水僵尸寻找最近的脑子并依此设定僵尸相关状态，当脑子在僵尸附近时则直接食脑。
5291E0	Zombie::UpdateZombiquarium(eax = Zombie* this)	eax, ecx, edx		水族馆僵尸的运动、状态、生产阳光等的更新。
5295F0	Zombie::UpdateZombiePool(edi = Zombie* this)	eax		更新进入泳池、离开泳池和被缠绕海草拖入水底过程中的僵尸的高度及运动状态。
5296E0	Zombie::UpdateZombieHighGround(ecx = Zombie* this)	eax		更新走上高地和走下高地过程中的僵尸的高度及运动状态。
529770	Zombie::UpdateZombieFalling(esi = Zombie* this)	eax, ecx		更新下坠（包括从扶梯下行、气球僵尸坠落、跳跃时被高坚果阻挡等情况）过程中的僵尸的高度及运动状态。
5297F0	Zombie::OverrideParticleScale(edx = TodParticleSystem* aParticle, eax = Zombie* this)	eax, ecx, edx		根据僵尸的大小设置粒子系统的大小。
529810	Zombie::OverrideParticleColor(ecx = TodParticleSystem* aParticle, eax = Zombie* this)	eax, ecx, edx		根据僵尸的减速、魅惑与否设置粒子系统的颜色和高亮。
529870	Zombie::DropFlag(ebx = Zombie* this)	eax, ecx, edx		销毁旗帜动画，处理僵尸动画手部相关动作，并创建旗帜掉落的粒子特效。此函数仅对旗帜僵尸有效。
529970	Zombie::DropPole(esi = Zombie* this)	eax, ecx, edx		撑杆僵尸失去撑杆，处理僵尸动画手部相关动作。此函数仅对撑杆僵尸有效。
529A30	Zombie::DropHead(unsigned int theDamageFlags, Zombie* this)	eax, ecx, edx		僵尸断头。特别地，当伤害类型的 DOESNT_LEAVE_BODY 标志为 1 时，不创建头颅掉落的粒子特效。
529EF0	Zombie::DropArm(unsigned int theDamageFlags, ebx = Zombie* this)	eax, ecx, edx		僵尸断手。特别地，当伤害类型的 DOESNT_LEAVE_BODY 标志为 1 时，不创建手臂掉落的粒子特效。
52A470	Zombie::UpdateDamageStates(edi = unsigned int theDamageFlags, eax = Zombie* this)	eax, ecx, edx		更新僵尸受伤状态，并依此判断和执行僵尸的断头、断手、死亡、掉落等事件。
52A580	Zombie::ZombieTargetLeadX(float theTime, eax = Zombie* this)	st(0) = aTargetCenterX; eax, ecx, edx		根据僵尸当前的运动，粗略估算僵尸经过 theTime 时间后的受伤判定范围中心的横坐标。
52A610	Zombie::ZombieNotWalking(eax = Zombie* this)	al = bool isNotWalking; ecx, edx		根据僵尸类型、状态等判断僵尸是否被禁止移动（禁止前进）。
52A7B0	Zombie::UpdateZamboni(esi = Zombie* this)	eax, edx		【僵尸特性函数】雪橇车僵尸的特性更新函数。
52A8E0	Zombie::UpdateYeti(eax = Zombie* this)	ecx		【僵尸特性函数】雪人僵尸的特性更新函数。
52A930	Zombie::UpdateLadder(ebx = Zombie* this)	eax, ecx, edx		【僵尸特性函数】扶梯僵尸的特性更新函数。
52AA40	Zombie::UpdateZombieWalking(esi = Zombie* this)	eax, ecx, edx		更新僵尸前进时的横坐标数值变化，并在部分僵尸的动画的特定时刻创建脚步扬尘的粒子特效。
52AD30	Zombie::UpdateZombiePosition(eax = Zombie* this)	eax, ecx, edx		更新僵尸的位置，包括僵尸前进和吹飞的更新、车类僵尸碾压的判定及部分情况下的僵尸纵坐标的更新。
52AE40	Zombie::IsOnBoard(eax = Zombie* this)	al = bool isOnBoard		根据僵尸出现的波数判断是否为关卡内的僵尸：为 -2(选卡界面) 或 -3(图鉴中) 则返回“否”。
52AE60	Zombie::Update(eax = Zombie* this)	eax, ecx, edx		僵尸的总更新函数。蹦极僵尸和跳跳僵尸的特性也在此函数中进行更新。
52B010	Zombie::UpdateClimbingLadder(esi = Zombie* this)	eax, ecx, edx		僵尸爬梯子动作的更新，包括爬梯过程中的高度更新、横坐标调整和爬梯结束的条件的判断。
52B110	Zombie::UpdateActions(eax = Zombie* this)	eax, ecx, edx		僵尸行为动作的更新，包括僵尸运动状态的更新和除蹦极僵尸、跳跳僵尸、僵王博士以外的僵尸特性的更新。
52B280	Zombie::CheckForBoardEdge(eax = Zombie* this)	eax, ecx, edx		检测僵尸是否抵达场地边缘，并依此触发相应的事件。当反向行走的僵尸越过场地右侧边界时，令僵尸消失;当僵尸抵达家门处时，触发僵尸进家和游戏失败的处理当僵尸抵达场地左侧边界时，令濒死状态的僵尸即死。
52B340	Zombie::UpdatePlaying(edi = Zombie* this)	eax, ecx, edx		正常游戏下存活僵尸角色的更新，包括僵尸呻吟、异常状态、行为、位置等的更新及濒死时流血伤害的触发，;同时，从墓碑或水中钻出的僵尸的状态，以及僵王博士的技能和特性的更新也在此处进行。
52B560	Zombie::HasYuckyFaceImage(eax = Zombie* this)	al = 0(不存在) | 1(存在); ecx		判断僵尸是否存在吃到大蒜的表情的贴图。
52B5B0	Zombie::ShowYuckyFace(isShow, eax = Zombie* this)	eax, ecx, edx		设置显示或取消显示僵尸吃到大蒜后的表情。
52B6A0	Zombie::UpdateYuckyFace(eax = Zombie* this)	eax, ecx, edx		僵尸吃到大蒜后的计时的更新及各时刻事件触发的判断。
52B940	Zombie::AnimateChewSound(eax = Zombie* this)	eax, ecx, edx		播放僵尸啃食的音效。当僵尸正在啃食部分特殊植物（魅惑菇、大蒜）时，触发植物对僵尸的作用效果。
52BB40	Zombie::AnimateChewEffect(edi = Zombie* this)	eax, ecx, edx		更新僵尸啃食的目标脑子或目标植物的被啃食倒计时，当僵尸正在啃食坚果或高坚果时，创建啃食的粒子特效。
52BCA0	Zombie::Animate(eax = Zombie* this)	eax, ecx, edx		僵尸动态的更新函数，包括僵尸贴图效果的更新、吃到大蒜的更新及啃食音效、特效的时机判断和触发。
52BE80	Zombie::DrawZombie(const ZombieDrawPosition& theDrawPos, Graphics* g, eax = Zombie* this)	eax, ecx, edx		【废弃函数】内测版中原用于以分份贴图的形式绘制僵尸，正式版中此函数无实用且一般不会调用。
52BEE0	Zombie::IsWalkingBackwards(ecx = Zombie* this)	al = 0(否) | 1(是)		判断僵尸是否反向。正向与反向：僵尸朝向左侧时为正向，朝向右侧时为反向。
52BF60	Zombie::DrawZombiePart;(eax = const ZombieDrawPosition& theDrawPos, int theFrame, esi = Graphics* g, Zombie* this)	eax, ecx, edx		【废弃函数】内测版中原用于绘制僵尸的贴图，正式版中存在严重代码错误且一般不会调用。
52C310	Zombie::UpdateReanim(eax = Zombie* this)	eax, ecx, edx		更新僵尸本体动画和被碾压动画的变换矩阵数据，同时将本体动画颜色应用至所有附件。
52C6D0	Zombie::DrawBobsledReanim;(al = bool theBeforeZombieDrawn, const ZombieDrawPosition& theDrawPos, Graphics* g, esi = Zombie* this)	eax, ecx, edx		绘制雪橇小队僵尸的雪橇。此函数在绘制僵尸本体前后各调用一次，以 theBeforeZombieDrawn 参数为区分。;选卡界面中：绘制僵尸前绘制雪橇背面，绘制僵尸后绘制雪橇正面;雪橇损坏消失的过程中：在绘制小队的领头僵尸结束后绘制雪橇背面与正面;推雪橇过程中、跳上雪橇过程中或被化为灰烬时：在绘制第 2 只小队僵尸前绘制雪橇背面和正面;乘坐雪橇时：绘制第 3 只（末位）僵尸前绘制雪橇背面，绘制小队的领头僵尸结束后绘制雪橇正面。
52CA90	Zombie::DrawBungeeReanim(Graphics* g, ecx = Zombie* this)	eax, ecx, edx		绘制蹦极僵尸绳索及本体动画，同时绘制其空投的僵尸或偷走的植物（若存在）的动画。
52CCA0	Zombie::DrawBungeeTarget(Graphics* g, edi = Zombie* this)	eax, ecx, edx		绘制蹦极僵尸的靶子贴图。
52CDF0	Zombie::DrawDancerReanim(Graphics* g, edi = Zombie* this)	eax, ecx, edx		绘制舞王僵尸动画，若僵尸存在聚光灯效果则同时绘制相应颜色的光圈和光柱。
52D020	Zombie::DrawReanim;(int theBaseRenderGroup, const ZombieDrawPosition& theDrawPos, Graphics* g, ecx = Zombie* this)	eax, ecx, edx		赋值僵尸动画颜色并绘制僵尸动画。其中 theBaseRenderGroup 指定僵尸本体所在的渲染分组（一般为 0）。
52D6D0	Zombie::GetHelmDamageIndex(eax = Zombie* this)	eax = int aDamageIndex; ecx, edx		取得僵尸一类饰品当前受伤的阶段。
52D710	Zombie::GetBodyDamageIndex(eax = Zombie* this)	eax = int aDamageIndex; ecx, edx		取得僵尸本体当前受伤的阶段。
52D780	Zombie::GetShieldDamageIndex(eax = Zombie* this)	eax = int aDamageIndex; ecx, edx		取得僵尸二类饰品当前受伤的阶段。
52D7C0	Zombie::DrawBungeeCord(int theOffsetX, ebx = Graphics* g, Zombie* this)	eax, ecx, edx		绘制蹦极僵尸的绳索贴图。当僵王博士相关关卡内不存在僵王博士时，此函数内可能导致崩溃。
52D9E0	Zombie::GetDrawPos(esi = ZombieDrawPosition& theDrawPos, ecx = Zombie* this)	eax, ecx, edx		取得僵尸绘制位置数据。 需要一个大小为 0x1C 的内存区域用于存储 theDrawPos 的数据。
52DF90	Zombie::GetDancerFrame(eax = Zombie* this)	eax = int aFrame; ecx, edx		根据游戏内置的时钟获取舞王僵尸和伴舞僵尸当前的舞蹈动作帧。
52DFE0	Zombie::GetDancerPhase(eax = Zombie* this)	eax = ZombiePhase aDancerPhase; ecx, edx		根据游戏内置的时钟获取舞王僵尸和伴舞僵尸当前的舞蹈动作阶段（状态）。
52E020	Zombie::DrawIceTrap;(bool theFront, edx = const ZombieDrawPosition& theDrawPos, ecx = Graphics* g, eax = Zombie* this)	eax, ecx, edx		绘制僵尸冰冻效果的贴图。此函数在绘制僵尸动画前后各调用一次，分别绘制僵尸身体后侧和前侧的冰冻效果。
52E150	Zombie::DrawButter(eax = const ZombieDrawPosition& theDrawPos, Graphics* g, ecx = Zombie* this)	eax, ecx, edx		绘制僵尸被黄油固定的效果的贴图。
52E2E0	Zombie::Draw(Graphics* g, ebx = Zombie* this)	eax, ecx, edx		绘制僵尸及僵尸的附件（若存在）。
52E4C0	Zombie::CanTargetPlant(ZombieAttackType theAttackType, Plant* thePlant, ecx = Zombie* this)	al = 0(不能) | 1(能); ecx, edx		判断僵尸能否将植物作为目标。theAttackType = 0(啃食/锤砸) | 1(车类碾压) | 2(跳跃) | 3(搭梯)。
52E780	Zombie::FindPlantTarget(ZombieAttackType theAttackType, Zombie* this)	eax = Plant*? aTargetPlant; ecx, edx		僵尸对植物索敌函数。寻找僵尸以 theAttackType 方式攻击的目标植物，不存在可攻击植物时返回 0。
52E840	Zombie::FindZombieTarget(Zombie* this)	eax = Zombie*? aTargetZombie; ecx, edx		僵尸对僵尸索敌函数。若僵尸攻击范围内有敌方阵营的僵尸则返回该僵尸，否则返回 0。
52E920	Zombie::SquishAllInSquare(ZombieAttackType theAttackType, int theGridY, int theGridX, edi = Zombie* this)	eax, ecx, edx		压扁一格内的所有植物。
52E9A0	Zombie::ZamboniDeath(unsigned int theDamageFlags, eax = Zombie* this)	eax, ecx, edx		雪橇车僵尸死亡。当伤害类型的 SPIKE 标志为 1 时，令僵尸进入爆胎阶段，否则直接令僵尸消失。
52EC00	Zombie::CatapultDeath(unsigned int theDamageFlags, eax = Zombie* this)	eax, ecx, edx		投石车僵尸死亡。当伤害类型的 SPIKE 标志为 1 时，令僵尸进入爆胎阶段，否则直接令僵尸消失。
52EDB0	Zombie::CheckSquish(Zombie* this)	eax, ecx, edx		车类僵尸检测并碾压其攻击范围内的植物，我是僵尸模式中额外检测并碾压其攻击范围内的脑子。
52EEF0	Zombie::IsImmobilized(eax = Zombie* this)	al = 0(否) | 1(是)		判断僵尸是否被控制。若僵尸被黄油定身或被冰冻，则返回“是”，否则返回“否”。
52EF10	Zombie::IsMovingAtChilledSpeed(eax = Zombie* this)	al = 0(否) | 1(是); ecx, edx		判断僵尸是否处于减速状态。若僵尸自身被减速或舞王队列五人中任一被减速，则返回“是”。
52EFD0	Zombie::SetAnimRate(float theAnimRate, eax = Zombie* this)	eax, ecx, edx		记录 theAnimRate 为僵尸的原速率，然后调用52EFF0的函数以根据僵尸减速情况设置实际动画速度。
52EFF0	Zombie::ApplyAnimRate(float theAnimRate, eax = Zombie* this)	eax, ecx, edx		根据僵尸是否处于减速状态，设置僵尸动画速度为 theAnimRate 或 theAnimRate/2。
52F050	Zombie::UpdateAnimSpeed(esi = Zombie* this)	eax, ecx, edx		僵尸运动或状态改变时调用，更新僵尸动画速度。僵尸啃食动画速度和部分特殊动作速度也在此函数内有定义。
52F250	Zombie::StartEating(eax = Zombie* this)	eax, ecx, edx		根据僵尸状态播放相应的啃食动画。若僵尸已处于啃食状态，则不作任何操作且不改变寄存器。
52F2E0	Zombie::StartWalkAnim(esi = int theBlendTime, eax = Zombie* this)	eax, ecx, edx		根据僵尸类型、状态等设置僵尸的前进动作及速度。
52F440	Zombie::StopEating(edi = Zombie* this)	eax, ecx, edx		僵尸结束啃食状态，播放行走动画并重置动画速度。
52F4C0	Zombie::CheckIfPreyCaught(eax = Zombie* this)	eax, ecx, edx		僵尸啃食的判定函数，具有啃食能力的僵尸依次检查啃食的目标僵尸、植物和脑子（仅我是僵尸模式）。;若成功取得啃食的目标，则调用相应的啃食函数若已处于啃食状态的僵尸丢失啃食目标，则结束啃食状态。
52F6D0	Zombie::PoolSplash(bool theInToPoolSound, eax = Zombie* this)	eax, ecx, edx		创建僵尸出入水的音效及水花动画，其中 theInToPoolSound 的值决定了播放的音效为出水或入水音效。
52F870	Zombie::CheckForPool(Zombie* this)	eax, ecx, edx		可进入泳池的僵尸对水池格子的检测，包括僵尸开始进入泳池、开始离开泳池和水面冻结的判定。
52F9C0	Zombie::IsOnHighGround(Zombie* this)	al = 0(否) | 1(是); ecx, edx		判断僵尸是否位于高地。
52FA20	Zombie::CheckForHighGround(esi = Zombie* this)	eax, ecx, edx		可进入高地的僵尸对高地的检测，包括僵尸开始走上高地和开始走下高地的判定。
52FA60	Zombie::StartMindControlled(esi = Zombie* this)	eax, ecx, edx		魅惑僵尸，播放相应的上位音效，重置僵尸使用传送门的列数，并解除相互关联的僵尸之间的联系。
52FB40	Zombie::EatPlant(ecx = Plant* thePlant, Zombie* this)	eax, ecx, edx		僵尸尝试啃食植物，进行僵尸啃食植物的相关判断并可能依次更改僵尸的部分状态，包括：;(1)当以太空步入场的舞王僵尸啃食植物时，重置其太空步状态的倒计时为 1，暂不处理啃食的事件;(2)当啃食的目标植物所在的格子内存在梯子时，令僵尸（矿工僵尸除外）进入爬上扶梯的运动状态;当僵尸成功啃食植物时，播放僵尸啃食动作，扣除植物相应的血量，并处理植物被啃食时的相关事件。
52FE10	Zombie::EatZombie(eax = Zombie* theZombie, edi = Zombie* this)	eax, ecx, edx		播放啃食中的僵尸的啃食动作，同时对被啃食的僵尸造成伤害。
52FE50	Zombie::TrySpawnLevelAward(Zombie* this)	al = bool spawned; ecx, edx		当僵尸被击杀时，判断是否达成过关的条件，若达成则处理过关的相关事件并掉落当前关卡相应的过关奖品。
530170	Zombie::DropLoot(eax = Zombie* this)	eax, ecx, edx		僵尸掉落事件函数。一般用于处理僵尸死亡时的掉落事件。
5302F0	Zombie::DieWithLoot(ecx = Zombie* this)	eax, ecx, edx		令僵尸消失，同时处理包括掉落在内的僵尸消失相关事件。
530310	Zombie::BobsledDie(edi = Zombie* this)	eax, ecx, edx		雪橇僵尸小队中的任一只僵尸死亡时，令队伍中的全部 4 只僵尸消失。
5303A0	Zombie::BobsledBurn(edi = Zombie* this)	eax, ecx, edx		雪橇僵尸小队中的任一只僵尸被化为灰烬时，将队伍中的全部 4 只僵尸化为灰烬。
530410	Zombie::BungeeDropPlant(esi = Zombie* this)	eax, ecx, edx		抱住植物但未离开的蹦极僵尸死亡时，处理被偷取的植物：植物仅被抱住则还原，已被抱起则直接消失。
530480	Zombie::BungeeDie(eax = Zombie* this)	eax, ecx, edx		蹦极僵尸死亡时，尝试处理被偷取的植物，并令被偷取的植物和被空投的僵尸消失。
530510	Zombie::DieNoLoot(ecx = Zombie* this)	eax, ecx, edx		令僵尸消失，移除僵尸附件和动画，同时处理除掉落外的僵尸消失相关事件（会触发过关奖品掉落的判定）。
530640	Zombie::PlayZombieAppearSound(ecx = Zombie* this)	eax, ecx, edx		创建僵尸出场音效。包括：海豚叫声、气球充气声和雪橇车启动声。
530770	Zombie::StartZombieSound(esi = Zombie* this)	eax, ecx, edx		僵尸出场及解除控制时调用，创建僵尸背景音效。包括：玩偶匣僵尸音效、矿工挖地道音效。
530850	Zombie::StopZombieSound(Zombie* this)	eax, ecx, edx		停止僵尸的自带音乐。包括：舞王僵尸音乐、玩偶匣僵尸音效、矿工挖地道音效。
530950	Zombie::ApplyChill(bool theIsIceTrap, eax = Zombie* this)	eax, ecx, edx		令僵尸减速 10 秒（若 theIsIceTrap 为 true 则改为减速 20 秒），同时处理减速后僵尸速度相关事件。
530A00	Zombie::DropShield(unsigned int theDamageFlags, Zombie* this)	eax, ecx, edx		僵尸掉落二类防具。特别地，当伤害类型的 DOESNT_LEAVE_BODY 标志为 1 时，不创建掉落的粒子特效。
530BC0	Zombie::TakeShieldDamage(unsigned int theDamageFlags, int theDamage, eax = Zombie* this)	eax = int aDamageRemaining; ecx, edx		令僵尸二类防具受伤，同时播放二类防具受伤的音效。;当伤害超过二类防具剩余耐久时，返回溢出的伤害值，未溢出则返回 0。
530E30	Zombie::DropHelm(unsigned int theDamageFlags, eax = Zombie* this)	eax, ecx, edx		僵尸掉落一类防具。特别地，当伤害类型的 DOESNT_LEAVE_BODY 标志为 1 时，不创建掉落的粒子特效。
530FE0	Zombie::TakeHelmDamage(ebx = unsigned int theDamageFlags, eax = int theDamage, Zombie* this)	eax = int aDamageRemaining; ecx, edx		令僵尸一类防具受伤。当伤害超过一类防具剩余耐久时，返回溢出的伤害值，未溢出则返回 0。
5312D0	Zombie::TakeBodyDamage(unsigned int theDamageFlags, int theDamage, Zombie* this)	eax, ecx, edx		令僵尸本体受伤，即：对僵尸造成无视任何防具的伤害。同时更新僵尸本体的受伤阶段。
5317C0	Zombie::TakeDamage(eax = unsigned int theDamageFlags, int theDamage, esi = Zombie* this)	eax, ecx, edx		令僵尸受伤，会根据僵尸状态及防具情况结算伤害，同时处理僵尸受伤的相关事件。
531880	Zombie::GetPosYBasedOnRow(int theRow, eax = Zombie* this)	st(0) = aPosY; eax		结合僵尸当前状态等，计算僵尸在第 theRow 行的浮点纵坐标。
531930	Zombie::~Zombie(esi = Zombie* this)	eax, ecx, edx		销毁僵尸，销毁僵尸的附件，停止僵尸的音效。
531990	Zombie::CanBeChilled(esi = Zombie* this)	al = 0(不能) | 1(能); ecx		判断僵尸能否被减速。
531A10	Zombie::CanBeFrozen(eax = Zombie* this)	al = 0(不能) | 1(能); ecx		判断僵尸能否被冰冻。额外地，不可被冻结的僵尸一定不可被黄油固定。
531A80	Zombie::EffectedByDamage(unsigned int theDamageRangeFlags, esi = Zombie* this)	al = 0(不能) | 1(能); ecx, edx		判断僵尸是否在给定攻击能力类型的可攻击范围内，判断依据是能力类型而非坐标范围。
531C90	Zombie::RiseFromGrave(int theRow, eax = int theCol, ebx = Zombie* this)	eax, ecx, edx		令僵尸开始从墓碑（或水底）出现，设定僵尸位置和状态等数据，并创建相应的音效和特效。
532060	Zombie::ZombieTypeCanGoInPool(ZombieType theZombieType)	al = 0(不能) | 1(能)		判断 theZombieType 类型的僵尸能否进入泳池。用于判断僵尸能否出现在水路。
5320B0	Zombie::GetZombieRect(edi = _Out_ Rect&& aZombieRect, ebx = Zombie* this)	eax = Rect&& aZombieRect; ecx, edx		取得僵尸受伤判定范围的矩形。此函数获取的矩形亦可认为是僵尸本身的矩形。
532140	Zombie::GetZombieAttackRect(edi = _Out_ Rect&& aZombieAttackRect, ebx = Zombie* this)	eax = Rect&& aZombieAttackRect; ecx, edx		取得僵尸攻击判定范围的矩形。
5321F0	Zombie::AddAttachedParticle(ParticleEffect theEffect, int thePosY, int thePosX, eax = Zombie* this)	eax = TodParticleSystem* aParticle; ecx,edx		创建 theEffect 粒子系统并绑定至僵尸的附件。
5322C0	Zombie::AddAttachedReanim;(edx = ReanimationType theReanimType, int thePosY, int thePosX, esi = Zombie* this)	eax = Reanimation* aReanim; ecx, edx		创建 theReanimType 动画并绑定至僵尸的附件。
532350	Zombie::RemoveIceTrap(eax = Zombie* this)	eax, ecx, edx		解除僵尸的冻结效果，重置僵尸动画速率并重新开始播放僵尸的音效。
5323C0	Zombie::HitIceTrap(eax = Zombie* this)	eax, ecx, edx		冻结僵尸，并造成 20 点非正面伤害。
5324B0	Zombie::IsTangleKelpTarget(edi = Zombie* this)	al = 0(否) | 1(是); ecx, edx		判断僵尸是否被缠绕海草缠绕，或者被拖入水底。部分特殊索敌会绕过已被缠绕住或被拖入水底的僵尸。
532510	Zombie::BalloonPropellerHatSpin(bool theSpinning, eax = Zombie* this)	eax, ecx, edx		设置气球僵尸螺旋桨的旋转与否（旋转动画的开始或停止）。
532570	Zombie::RemoveButter(eax = Zombie* this)	eax, ecx, edx		僵尸移除黄油的固定效果，重置本体、植物僵尸头部等动画的速率，并重新开始僵尸的音效。
5326D0	Zombie::ApplyButter(eax = Zombie* this)	eax, ecx, edx		使用黄油定住僵尸，停止僵尸动画，并处理僵尸被定身的相关事件。
5327E0	Zombie::MowDown(edi = Zombie* this)	eax, ecx, edx		僵尸被小推车碾压，同时创建相应的音效和特效。
532B40	Zombie::RemoveColdEffects(eax = Zombie* this)	eax, ecx, edx		移除僵尸的寒冷效果（冰冻和减速）。
532B70	Zombie::ApplyBurn(ecx = Zombie* this)	eax, ecx, edx		将僵尸化为灰烬，对于本体血量高于 1800 的僵尸及部分免疫灰烬效果的僵尸，对其造成 1800 点伤害。
533000	Zombie::AttachShield(eax = Zombie* this)	eax, ecx, edx		根据僵尸二类饰品的类型，设置相应的部分动画轨道的渲染分组。;当僵尸二类饰品类型不为铁栅门、报纸或扶梯时，可能会导致程序崩溃。
5330E0	Zombie::DetachShield(eax = Zombie* this)	eax, ecx, edx		僵尸失去二类饰品，同时抹除二类饰品血量并处理僵尸的动画变化的相关事件。
5331C0	Zombie::ReanimShowPrefix(int theRenderGroup, const char* theTrackPrefix, eax = Zombie* this)	eax, ecx, edx		设置僵尸动画轨道在绘制时的渲染分组，组号越大则图层越上层，为 -1 时隐藏。;此函数内部在判断并获取僵尸动画后调用了473A40的函数。
533200	Zombie::ReanimShowTrack(const char* theTrackName, ecx = Zombie* this)	eax, ecx, edx		设置僵尸动画图层渲染分组为 -1 。此函数内部在判断并获取僵尸动画后调用了4739E0的函数。
533240	Zombie::PlayDeathAnim(unsigned int theDamageFlags, eax = Zombie* this)	eax, ecx, edx		清除僵尸的冰冻、黄油固定等状态，设定僵尸动画并播放死亡动作。对于僵王，则额外触发 BOSS 死亡事件。;当伤害类型的 DOESNT_LEAVE_BODY 标志为 1 时，除非僵尸为巨人或僵王，否则直接令僵尸消失。
5335A0	Zombie::DoDaisies(esi = Zombie* this)	eax, ecx, edx		当僵尸死亡时，若 [DAISIES] 指令开启，则创建雏菊粒子特效。
5336B0	Zombie::UpdateDeath(eax = Zombie* this)	eax, ecx, edx		更新僵尸的正常死亡过程，处理该过程中的各个时刻触发的事件，并在死亡动作播放完成后令僵尸开始消失。
533F10	Zombie::UpdateMowered(eax = Zombie* this)	eax, ecx, edx		更新僵尸被小推车碾压的死亡过程，当被碾压的动画播放完成时，触发僵尸断头断手的事件并令僵尸消失。
533F70	Zombie::HasShadow(ecx = Zombie* this)	al = 0(不存在) | 1(存在); edx		判断僵尸是否存在影子。
534040	Zombie::SetupDrawZombieWon(eax = Graphics* g, ecx = Zombie* this)	al = 0(不绘制) | 1(绘制); ecx, edx		绘制僵尸和绘制僵尸影子时调用，为绘制进家的僵尸进行适当的 Graphics 裁剪矩形的调整。;返回值表示此次是否需要继续对当前僵尸进行绘制。当僵尸不为进家的僵尸时，函数直接返回 al = 1。
5340C0	Zombie::DrawShadow(Graphics* g, edi = Zombie* this)	eax, ecx, edx		绘制僵尸的影子。
5345F0	Zombie::GetTrackPosition;(edi = float& thePosY, float& thePosX, const char* theTrackName, esi = Zombie* this)	eax, ecx, edx		取得僵尸动画 theTrackName 轨道的绝对位置，并将其横、纵坐标分别赋值给 thePosX 和 thePosY。
534680	Zombie::IsFlying(eax = Zombie* this)	al = 0(否) | 1(是)		判断僵尸是否为空中的气球僵尸，若气球僵尸正在飞行中或气球破裂即将落地则返回“是”。
5346A0	Zombie::GetBobsledPosition(ecx = Zombie* this)	eax = int aIndex; ecx, edx		取得雪橇僵尸在雪橇僵尸小队中的位置，即获取僵尸是雪橇僵尸小队中的第几只雪橇僵尸。;对于非雪橇僵尸的其他僵尸，以及当雪橇僵尸小队不存在雪橇（雪橇已损坏）时，返回 -1。;此函数通常用于判断僵尸是否为雪橇僵尸、雪橇小队是否存在雪橇以及雪橇僵尸是否位于雪橇小队中等。
534700	Zombie::IsDeadOrDying(eax = Zombie* this)	al = 0(否) | 1(是)		判断僵尸是否死亡。若僵尸消失或僵尸状态为血量为零/化为灰烬/推车碾压，则返回“是”。
534730	Zombie::UpdateZombieChimney(esi = Zombie* this)	eax, ecx, edx		更新从烟囱进家的僵尸的高度。
534780	Zombie::WalkIntoHouse(eax = Zombie* this)	eax, ecx, edx		僵尸进入房子，将僵尸标记为进家的僵尸，并调整僵尸的位置、状态、图层和动画动作等。
534920	Zombie::BossPlayIdle(eax = Zombie* this)	eax, ecx, edx		令僵王博士进入站立的闲置状态，赋值其状态倒计时，并播放 anim_idle 动画。
534960	Zombie::DrawBossFireBall(esi = Graphics* g, eax = Zombie* this)	eax, ecx, edx		绘制僵王博士火球（或冰球）的动画。
5349E0	Zombie::DrawBossBackArm(const ZombieDrawPosition& theDrawPos, Graphics* g, ecx = Zombie* this)	eax, ecx, edx		绘制僵王博士的内侧手臂（即：释放蹦极僵尸和砸车的手臂）。
534AC0	Zombie::BossRVAttack(eax = Zombie* this)	eax, ecx, edx		僵王博士开始砸车攻击，解除其冰冻和减速状态，并选定砸车的目标行列。
534B90	Zombie::BossRVLanding(edi = Zombie* this)	eax, ecx, edx		僵王博士砸车攻击落地，压扁范围内的所有植物，并重置各技能的倒计时。
534C70	Zombie::BossSpawnAttack(eax = Zombie* this)	eax, ecx, edx		僵王博士开始放置僵尸，解除其冰冻和减速状态，重置放置僵尸倒计时，并选定放置僵尸的行数。
534DC0	Zombie::BossSpawnContact(esi = Zombie* this)	eax, ecx, edx		僵王博士选取放置的僵尸类型，并在目标行放置僵尸。
534E30	Zombie::BossStompAttack(eax = Zombie* this)	eax, ecx, edx		僵王博士开始跺脚攻击，解除其冰冻和减速状态，重置跺脚倒计时，并选定跺脚的目标行。;当不存在可作为跺脚目标的行时，取消跺脚攻击。
534F60	Zombie::BossCanStompRow(edi = int theRow, Zombie* this)	al = 0(不能) | 1(能); ecx, edx		判断僵王博士能否在第 theRow 行跺脚，即：判断第 theRow 行的跺脚范围内是否存在可被压扁的植物。
534FF0	Zombie::BossStompContact(eax = Zombie* this)	eax, ecx, edx		僵王博士跺脚，压扁范围内的所有植物。
5350C0	Zombie::BossBungeeAttack(eax = Zombie* this)	eax, ecx, edx		僵王博士开始释放蹦极僵尸，解除其冰冻和减速状态，重置释放蹦极僵尸倒计时，并选定蹦极僵尸的目标列。
5351F0	Zombie::BossBungeeSpawn(Zombie* this)	eax, ecx, edx		僵王博士释放蹦极僵尸。
5352B0	Zombie::BossBungeeLeave(eax = Zombie* this)	eax, ecx, edx		僵王博士收回蹦极僵尸，令其中所有被黄油固定的蹦极僵尸直接死亡。
535340	Zombie::BossAreBungeesDone(eax = Zombie* this)	al = 0(否) | 1(是); ecx, edx		判断僵王博士是否应当收回蹦极僵尸。当任意蹦极僵尸离开或所有蹦极僵尸死亡时，返回“是”。
5353A0	Zombie::BossHeadAttack(eax = Zombie* this)	eax, ecx, edx		僵王博士开始低头，重置低头倒计时。
535440	Zombie::BossHeadSpit(eax = Zombie* this)	eax, ecx, edx		僵王博士开始吐球，移除旧有冰、火球动画，并选定吐球的目标行和球的类型。
535630	Zombie::BossDestroyIceball(eax = Zombie* this)	eax, ecx, edx		清除僵王博士的冰球，并清除冰球相关动画和粒子系统等。
5356D0	Zombie::BossDestroyFireball(Zombie* this)	eax, ecx, edx		清除僵王博士的火球，并清除火球相关动画和粒子系统等。
535870	Zombie::BossHeadSpitEffect(eax = Zombie* this)	eax, ecx, edx		创建僵王博士吐球时的音效和粒子特效。
535A70	Zombie::BossHeadSpitContact(eax = Zombie* this)	eax, ecx, edx		僵王博士吐球，创建火球（或冰球）的动画，并设定火球（或冰球）及埃德加本体的动画。
535C60	Zombie::UpdateBossFireball(ebx = Zombie* this)	eax, ecx, edx		更新僵王博士的冰、火球的位置、动作及动画，对植物和小推车进行碾压判定，同时创建球的轨迹的特效。
535FB0	Zombie::BossStartDeath(eax = Zombie* this)	eax, ecx, edx		僵王博士开始死亡。令僵王博士起身，并创建相关的音效和特效，然后跳转至执行僵王博士死亡。
536080	Zombie::UpdateBoss(eax = Zombie* this)	eax, ecx, edx		【僵尸特性函数】僵王博士的技能和特性更新函数。
5366D0	Zombie::BossDie(ecx = Zombie* this)	eax, ecx, edx		僵王博士死亡，清除其冰、火球，淡出当前背景音乐，清除全场僵尸，并移除其自身的减速和冰冻效果。
5367F0	Zombie::BossSetupReanim(eax = Zombie* this)	eax, edx		初始化设定僵王博士动画，包括设定动画各轨道的渲染分组和创建并绑定埃德加本体动画。
536940	Zombie::DrawBossPart(BossPart theBossPart, ebx = Graphics* g, edi = Zombie* this)	eax, ecx, edx		绘制僵王博士身体部件。
5369E0	Zombie::PreloadZombieResources(eax = ZombieType theZombieType)	eax, ecx, edx		预加载 theZombieType 僵尸相关的所有动画的定义数据。进入关卡时会对出怪列表中每一只僵尸调用此预加载。
536B00	Zombie::ApplyBossSmokeParticles(bool theEnable, eax = Zombie* this)	eax, ecx, edx		先清除僵王博士动画头部轨道上所有附属的冒烟特效，然后当 theEnable 为 1 时，;创建 2 个（血量低于 1/10 时改为 3 个）冒烟的粒子特效并绑定至头部轨道附件的适当位置。
536C90	Zombie::EnableMustache(bool theEnableMustache, eax = Zombie* this)	eax, ecx, edx		设置僵尸胡子的显示与否。用于设定 [MUSTACHE] 指令对僵尸形象的影响。
536D90	Zombie::EnableFuture(bool theEnableFuture, esi = Zombie* this)	eax, ecx, edx		设置僵尸墨镜的显示与否。用于设定 [FUTURE] 指令对僵尸形象的影响。
536EA0	Zombie::SetupWaterTrack(const char* theTrackName, eax = Zombie* this)	eax, ecx, edx		将僵尸动画轨道设定为独立于动画渲染，包括：无视裁剪矩形、使用固有着色（禁用叠色）、禁用高亮叠色。
536EF0	Sexy::AutoModalFlags::~AutoModalFlags(eax = AutoModalFlags* this)	eax = *this; ecx, edx		销毁自动模态标志，恢复原模态标志的值。
536F00	Sexy::WidgetContainer::WidgetContainer(esi = WidgetContainer* this)	eax = *this; ecx, edx		初始化创建控件容器，并初始化其子控件链表及更新迭代器。需要一个大小为 0x54 的内存区域用于构造 this。
536F60	Sexy::WidgetContainer::`scalar deleting destructor'(unsigned int flags, WidgetContainer* this)	eax = *this; ecx, edx		删除控件容器，当 flags 的第 0 位置 1 时会额外释放控件容器本身占用的内存空间。		【虚函数】[[[(WidgetContainer*)]+0]+0]
536F80	Sexy::WidgetContainer::~WidgetContainer(ecx = WidgetContainer* this)	eax, ecx, edx		销毁控件容器，释放其子控件链表中的所有控件及链表本身占用的内存空间。
536FB0	Sexy::WidgetContainer::RemoveAllWidgets(bool recursive, bool doDelete, ecx = WidgetContainer* this)	eax, ecx, edx		移除控件容器的所有子控件。当指定 doDelete 时，额外将被移除的子控件直接删除;当指定 recursive 时，额外递归地令被移除的子控件也按照与调用此函数的相同的参数移除其自身所有子控件。		【虚函数】[[[(WidgetContainer*)]+0]+1C]
537010	Sexy::WidgetContainer::GetRect(_Out_ Rect&& aRect, ecx = WidgetContainer* this)	eax = Rect&& aRect; ecx, edx		取得控件容器自身位置及范围的矩形。		【虚函数】[[[(WidgetContainer*)]+0]+4]
537030	Sexy::WidgetContainer::Intersects(WidgetContainer* theWidget, ecx = WidgetContainer* this)	eax = bool intersects; ecx, edx		取得控件容器是否与另一个控件容器 theWidget 有重叠。		【虚函数】[[[(WidgetContainer*)]+0]+8]
5370A0	Sexy::WidgetContainer::AddWidget(Widget* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		将 theWidget 控件设定为控件容器自身的子控件，触发 theWidget 控件的 AddedToManager，;并以图层由下至上的顺序将 theWidget 插入至自身的子控件链表的适当位置，然后将自身标记为已变更。		【虚函数】[[[(WidgetContainer*)]+0]+C]
537160	Sexy::WidgetContainer::HasWidget(Widget* theWidget, ecx = WidgetContainer* this)	eax = bool hasWidget; ecx, edx		判断 theWidget 控件是否位于自身的子控件链表中，即判断 theWidget 是否为自身的子控件。		【虚函数】[[[(WidgetContainer*)]+0]+14]
5371C0	Sexy::WidgetContainer::RemoveWidget(Widget* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		将 theWidget 控件移除控件容器自身的子控件链表。		【虚函数】[[[(WidgetContainer*)]+0]+10]
537290	Sexy::WidgetContainer::GetWidgetAtHelper(int* theWidgetY = 0, int* theWidgetX = 0, bool* found, ;                                         int theFlags, int y, int x, ecx = WidgetContainer* this)	eax = Widget*? aWidget; ecx, edx		取得在控件容器内 (x, y) 相对坐标处最优先的控件（要求该控件允许鼠标且指定点在其判定范围内）。;会递归查找所有子控件以取得最优先的一个，将是否找到最优先的控件的逻辑值写入 [found] 地址中。;只要找到允许鼠标且包含指定点的控件就会将 *found 赋值为 1，但只会返回其中能判定到指定点的最优先的一个。;若 theWidgetX(/theWidgetY) 不为 0，则将 aWidget 在其父控件中的相对横(/纵)坐标写入其指向的地址中。
537470	Sexy::WidgetContainer::IsBelowHelper;(bool* found, Widget* theWidget2, Widget* theWidget1, WidgetContainer* this)	eax = bool isBelow; ecx, edx		判断控件 theWidget1 是否位于 theWidget2 的下方。会在控件容器的所有子控件中递归查找此二控件，;若发现了其中任一控件，则将 *found 赋值为 1。若均未发现，则不会赋值 *found 且返回 false。
5374F0	Sexy::WidgetContainer::IsBelow(Widget* theWidget2, Widget* theWidget1, WidgetContainer* this)	eax = bool isBelow; ecx, edx		判断控件 theWidget1 是否位于 theWidget2 的下方。		【虚函数】[[[(WidgetContainer*)]+0]+24]
537510	Sexy::WidgetContainer::MarkAllDirty(ecx = WidgetContainer* this)	eax, ecx, edx		将控件容器内的所有子控件标记为已变更位置，需要重新绘制。		【虚函数】[[[(WidgetContainer*)]+0]+28]
537580	Sexy::WidgetContainer::InsertWidgetHelper;(Widget* theWidget, eax = const std::list<Widget*>::iterator& where, ecx = WidgetContainer* this)	eax, ecx, edx		以图层由下至上的顺序尝试将 theWidget 插入至自身的子控件链表的适当位置。;优先尝试将 theWidget 插入在 where 之后的位置，若之后没有合适的位置则向前查找，至少插入在链表开头。
5376B0	Sexy::WidgetContainer::BringToFront(Widget* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		将控件的一个子控件 theWidget 尽可能地移动至较顶层显示（依据其 Z 坐标）。		【虚函数】[[[(WidgetContainer*)]+0]+2C]
537780	Sexy::WidgetContainer::BringToBack(Widget* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		将控件的一个子控件 theWidget 尽可能地移动至较底层显示（依据其 Z 坐标）。		【虚函数】[[[(WidgetContainer*)]+0]+30]
537850	Sexy::WidgetContainer::PutBehind(Widget* theRefWidget, Widget* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		将 theWidget 移动至 theRefWidget 下方显示，要求二者均为控件容器自身的子控件且 Z 坐标相同。		【虚函数】[[[(WidgetContainer*)]+0]+34]
537960	Sexy::WidgetContainer::PutInfront(Widget* theRefWidget, Widget* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		将 theWidget 移动至 theRefWidget 上方显示，要求二者均为控件容器自身的子控件且 Z 坐标相同。		【虚函数】[[[(WidgetContainer*)]+0]+38]
537A90	Sexy::WidgetContainer::GetAbsPos(_Out_ Point&& aAbsPos, ecx = WidgetContainer* this)	eax = Point&& aAbsPoint; ecx, edx		取得自身位于屏幕上的绝对坐标。		【虚函数】[[[(WidgetContainer*)]+0]+3C]
537AF0	Sexy::WidgetContainer::AddedToManager(WidgetManager* theWidgetManager, ecx = WidgetContainer* this)	eax, ecx, edx		控件容器将所有子控件加入控件管理器，设置其管理器为 theWidgetManager 并将其标记为已变更。		【虚函数】[[[(WidgetContainer*)]+0]+50]
537B60	Sexy::WidgetContainer::RemovedFromManager(WidgetManager* theWidgetManager, ecx = WidgetContainer* this)	eax, ecx, edx		控件容器将所有子控件移出控件管理器，并由 theWidgetManager 令子控件失去焦点。		【虚函数】[[[(WidgetContainer*)]+0]+54]
537BE0	Sexy::WidgetContainer::MarkDirty(ecx = WidgetContainer* this)	eax, ecx, edx		将控件容器自身标记为已变更，若控件容器存在父控件，则利用父控件将所有上层控件标记为已变更。		【虚函数】[[[(WidgetContainer*)]+0]+44]
537C00	Sexy::WidgetContainer::MarkDirtyFull(ecx = WidgetContainer* this)	eax, ecx, edx		将控件容器自身标记为已变更，若控件容器存在父控件，则利用父控件将所有相关控件标记为已变更。		【虚函数】[[[(WidgetContainer*)]+0]+4C]
537C20	Sexy::WidgetContainer::MarkDirtyFull(WidgetContainer* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		控件容器将自身的 theWidget 子控件及其自身标记为已变更。若 theWidget 已被标记则直接返回。;如果自身不存在父控件，则将所有与 theWidget 有重叠的子控件标记为已变更。		【虚函数】[[[(WidgetContainer*)]+0]+48]
537E90	Sexy::WidgetContainer::MarkDirty(WidgetContainer* theWidget, ecx = WidgetContainer* this)	eax, ecx, edx		控件容器将自身的 theWidget 子控件及其自身标记为已变更。若 theWidget 已被标记则直接返回。;如果自身不存在父控件，则将所有与 theWidget 有重叠且图层位于 theWidget 上方的子控件标记为已变更。		【虚函数】[[[(WidgetContainer*)]+0]+40]
537F50	Sexy::WidgetContainer::Update(ecx = WidgetContainer* this)	此函数不改变任何寄存器		令控件容器的更新计数增加 1。		【虚函数】[[[(WidgetContainer*)]+0]+58]
537F60	Sexy::WidgetContainer::UpdateAll(ecx = WidgetContainer* this)	eax, ecx, edx		更新控件容器自身及其所有子控件。		【虚函数】[[[(WidgetContainer*)]+0]+5C]
5380F0	Sexy::WidgetContainer::UpdateFAll(float theFrac, ecx = WidgetContainer* this)	eax, ecx, edx		浮点时间更新控件容器自身及其所有子控件，其中 theFrac 为当前位于前后一个整数时间之间的比例。		【虚函数】[[[(WidgetContainer*)]+0]+64]
538240	Sexy::WidgetContainer::DrawAll(Graphics* g, ModalFlags* theFlags, WidgetContainer* this)	eax, ecx, edx		以 theFlags 标志判断并绘制控件容器自身及其中的所有子控件。		【虚函数】[[[(WidgetContainer*)]+0]+6C]
538430	Sexy::WidgetContainer::SysColorChangedAll(ecx = WidgetContainer* this)	eax, ecx, edx		当系统颜色设置改变时，触发控件容器自身及其中的所有子控件的 SysColorChanged。		【虚函数】[[[(WidgetContainer*)]+0]+70]
5384A0	Sexy::WidgetManager::WidgetManager(SexyAppBase* theApp, WidgetManager* this)	eax = *this; ecx, edx		初始化创建控件管理器。需要一个大小为 0x1FC 的内存区域用于构造 this。
5385F0	Sexy::WidgetManager::`scalar deleting destructor'(unsigned int flags, ecx = WidgetManager* this)	eax = *this; ecx, edx		删除控件管理器，当 flags 的第 0 位置 1 时会额外释放控件管理器本身占用的内存空间。		【虚函数】[[[(WidgetManager*)]+0]+0]
538610	Sexy::WidgetManager::~WidgetManager(WidgetManager* this)	eax, ecx, edx		销毁控件管理器。
538660	Sexy::WidgetManager::DisableWidget(Widget* theWidget, ecx = WidgetManager* this)	eax, ecx, edx		控件管理器禁用控件并进行相关的事件处理。		【虚函数】[[[(WidgetManager*)]+0]+18]
5386E0	Sexy::WidgetManager::GetWidgetFlags(ecx = WidgetManager* this)	eax = int aWidgetFlags; ecx, edx		根据当前程序窗口的焦点与否获取相应的控件标志。
538700	Sexy::WidgetManager::GetAnyWidgetAt;(eax = int* theWidgetY, ecx = int* theWidgetX, int y, int x, edx = WidgetManager* this)	eax = Widget*? aWidget; ecx, edx		取得在控件管理器内 (x, y) 相对坐标处最优先的控件（要求该控件允许鼠标且指定点在其判定范围内）。;若 theWidgetX(/theWidgetY) 不为 0，则将 aWidget 在其父控件中的相对横(/纵)坐标写入其指向的地址中。
538730	Sexy::WidgetManager::GetWidgetAt;(int* theWidgetY, int* theWidgetX, eax = int y, ecx = int x, edx = WidgetManager* this)	eax = Widget*? aWidget; ecx, edx		在 WidgetManager::GetAnyWidgetAt 的基础上，额外要求取得的控件为可用状态。
538750	Sexy::WidgetManager::DoMouseUps(edi = WidgetManager* this)	eax, ecx, edx		控件管理器鼠标松开。当存在鼠标按住的控件时，进行鼠标松开的处理并清除鼠标按下的相关记录。
538790	Sexy::WidgetManager::FlushDeferredOverlayWidgets(int theMaxPriority, WidgetManager* this)	eax, ecx, edx		刷新延迟覆盖的控件，依次触发最低延迟优先级的控件的 DrawOverlay 直至最低优先级不低于 theMaxPriority。
538990	Sexy::WidgetManager::DoMouseUps;(ebx = unsigned long theDownCode, esi = Widget* theWidget, WidgetManager* this)	eax, ecx, edx		控件管理器处理鼠标松开。根据鼠标按下时的状态 theDownCode，以相应的参数触发 theWidget 的 MouseUp。
538A00	Sexy::WidgetManager::RemapMouse(ebx = int& theY, int& theX, ecx = WidgetManager* this)	eax, ecx, edx		鼠标位置改变时，重新将鼠标在窗口内的坐标映射到画面的对应位置。;参数 theX 和 theY 作为入参时表示窗口内的坐标，作为出参时表示映射后的坐标。
538A60	Sexy::WidgetManager::MouseEnter(esi = Widget* theWidget)	eax, ecx, edx		鼠标进入 theWidget，触发其 MouseEnter，同时若该控件需要鼠标手型，则令鼠标显示手型。
538A90	Sexy::WidgetManager::MouseLeave(esi = Widget* theWidget)	eax, ecx, edx		鼠标离开 theWidget，触发其 MouseLeave，同时若该控件需要鼠标手型，则令鼠标取消显示手型。
538AC0	Sexy::WidgetManager::SetBaseModal;(eax = const FlagsMod& theBelowFlagsMod, ecx = Widget* theWidget, edi = WidgetManager* this)	eax, ecx, edx		设置控件管理器的基础模态控件和下层控件标志，然后据此分别判断并对当前的悬浮、按下、焦点控件进行处理。
538BA0	Sexy::WidgetManager::AddBaseModal;(const FlagsMod& theBelowFlagsMod, Widget* theWidget, eax = WidgetManager* this)	eax, ecx, edx		添加对当前的模态数据的记录，然后重新设置控件管理器的基础模态控件和下层控件标志。
538C20	Sexy::WidgetManager::AddBaseModal(edx = Widget* theWidget, eax = WidgetManager* this)	eax, ecx, edx		以控件管理器默认的下层控件标志设置模态数据。
538C30	Sexy::WidgetManager::RemoveBaseModal(Widget* theWidget, eax = WidgetManager* this)	eax, ecx, edx		移除基础模态控件，令控件管理器的模态数据回退到上一次的记录值，并对相关的事件进行处理。
538D20	Sexy::WidgetManager::Resize;(edx = const Rect& theMouseSourceRect, ecx = const Rect& theMouseDestRect, eax = WidgetManager* this)	eax, ecx, edx		设置控件管理器的鼠标源区域矩形和鼠标目标区域矩形，并依此计算并设置控件管理器自身的宽度和高度。
538D90	Sexy::WidgetManager::SetFocus(Widget* theWidget, ecx = WidgetManager* this)	eax, ecx, edx		控件管理器将 theWidget 设为当前游戏中获得焦点的控件，通常用于令对话或界面获得焦点。		【虚函数】[[[(WidgetManager*)]+0]+20]
538DF0	Sexy::WidgetManager::GotFocus(eax = WidgetManager* this)	eax, ecx, edx		控件管理器取得焦点，触发当前焦点控件的 GotFocus。
538E20	Sexy::WidgetManager::LostFocus(edi = WidgetManager* this)	eax, ecx, edx		控件管理器失去焦点，视为松开所有已按下的按键，并触发当前焦点控件的 LostFocus。
538E80	Sexy::WidgetManager::InitModalFlags(esi = ModalFlags* theModalFlags, edx = WidgetManager* this)	eax, ecx, edx		根据当前控件状态和控件标志初始化模态标志 theModalFlags。
538EB0	Sexy::WidgetManager::DrawScreen(ecx = WidgetManager* this)	al = bool drewStuff; ecx, edx		绘制屏幕。创建屏幕画面的 Graphics，递归地绘制控件管理器中所有需要绘制的控件。
539140	Sexy::WidgetManager::UpdateFrame(edi = WidgetManager* this)	eax = bool dirty; ecx, edx		控件管理器在一次更新中递归地更新其中所有的控件，返回表示是否需要重绘的逻辑值。
539170	Sexy::WidgetManager::UpdateFrameF(float theFrac, edi = WidgetManager* this)	eax = bool dirty; ecx, edx		控件管理器在一次浮点时间更新中递归地更新其中所有的控件，返回表示是否需要重绘的逻辑值。;其中，theFrac 为当前位于前后一个整数时间之间的比例。
5391A0	Sexy::WidgetManager::RemovePopupCommandWidget(ecx = WidgetManager* this)	eax, ecx, edx		移除弹出命令控件。
5391C0	Sexy::WidgetManager::MousePosition(int y, int x, edi = WidgetManager* this)	eax, ecx, edx		记录上一次的光标坐标为 (x, y)，然后根据移动前后的鼠标位置触发相关控件的鼠标进入/离开/移动事件。
539270	Sexy::WidgetManager::RehupMouse(eax = WidgetManager* this)	eax, ecx, edx		当存在上次点击的控件时，对当前鼠标悬浮的控件进行鼠标离开的判断否则，进行鼠标位置的更新和处理。
5392E0	Sexy::WidgetManager::MouseUp(int theClickCount, ebx = int y, int x, eax = WidgetManager* this)	al = 1; ecx, edx		控件管理器鼠标松开，令原先鼠标按住的控件触发 MouseUp，然后自身触发 MousePosition。
539390	Sexy::WidgetManager::MouseDown(ebx = int theClickCount, eax = int y, int x, ecx = WidgetManager* this)	al = 1; ecx, edx		控件管理器鼠标按下，自身触发 MousePosition，然后记录鼠标按下的情况，并令按下的控件触发 MouseDown。
5394A0	Sexy::WidgetManager::MouseMove(ecx = int y, eax = int x, edx = WidgetManager* this)	al = 1; ecx, edx		控件管理器鼠标移动，若当前鼠标处于按下状态，则自身触发 MouseDrag，否则自身触发 MousePosition。
5394E0	Sexy::WidgetManager::MouseDrag(ebx = int y, int x, edi = WidgetManager* this)	al = 1; ecx, edx		控件管理器鼠标拖动，触发相关控件的鼠标进入/离开/拖动事件。
5395C0	Sexy::WidgetManager::MouseExit(edi = WidgetManager* this)	al = 1; ecx, edx		控件管理器鼠标移出，自身对当前鼠标悬浮的控件触发 MouseLeave 并取消当前鼠标悬浮的控件。
5395F0	Sexy::WidgetManager::MouseWheel(int theDelta, eax = WidgetManager* this)	eax, ecx, edx		控件管理器鼠标滚动，令当前焦点的控件触发 MouseWheel。
539610	Sexy::WidgetManager::KeyChar(cl = char theChar, eax = WidgetManager* this)	al = 1; ecx, edx		控件管理器输入 theChar 字符，如果输入的是 TAB 且 Ctrl 键已按下，则令默认选项的控件触发 KeyChar;否则，令当前焦点的控件触发 KeyChar。
539660	Sexy::WidgetManager::KeyDown(ecx = KeyCode key, eax = WidgetManager* this)	al = 1; ecx, edx		控件管理器键盘按下，记录当前按住的按键，并令当前焦点的控件触发 KeyDown。
5396A0	Sexy::WidgetManager::KeyUp(ecx = KeyCode key, eax = WidgetManager* this)	al = 1; ecx, edx		控件管理器按键松开，更新对当前按住的按键的记录，;然后除非按下的是 TAB 且 Ctrl 键已按下，否则令令当前焦点的控件触发 KeyUp。
5396F0	Sexy::Widget::Widget(Widget* this)	eax = *this; ecx, edx		初始化创建控件。需要一个大小为 0x88 的内存区域用于构造 this。
539780	Sexy::Widget::`scalar deleting destructor'(unsigned int flags, Widget* this)	eax = *this; ecx, edx		删除控件，当 flags 的第 0 位置 1 时会额外释放控件本身占用的内存空间。		【虚函数】[[[(Widget*)]+0]+0]
5397A0	Sexy::Widget::~Widget(ecx = Widget* this)	eax, ecx, edx		销毁控件，释放其颜色的向量容器和子控件指针的链表容器占用的内存空间。
5397E0	Sexy::Widget::WidgetRemovedHelper(ecx = Widget* this)	eax, ecx, edx		控件被移出父控件时，移出并禁用自身的所有子控件，触发 RemovedFromManager 并将自身标记为已变更。
5398C0	Sexy::Widget::IsPointVisible(int y, int x, ecx = Widget* this)	al = 1		判断控件内 (x, y) 位置处的一点是否属于控件的判定范围内。默认情况下，该函数总是返回“是”。		【虚函数】[[[(Widget*)]+0]+F0]
5398D0	Sexy::Widget::SetVisible(bool isVisible, ecx = Widget* this)	eax, ecx, edx		设置控件的可见与否，将控件标记为已变更，并由控件管理器进行鼠标的刷新。		【虚函数】[[[(Widget*)]+0]+7C]
539900	Sexy::Widget::DrawOverlay(int thePriority, Graphics* g, ecx = Widget* this)	eax, ecx, edx		绘制控件的 thePriority 优先级的悬浮内容。此函数仅默认调用了 [[[(Widget*)]+0]+B0] 的 DrawOverlay。		【虚函数】[[[(Widget*)]+0]+AC]
539920	Sexy::Widget::SetColors(int theNumColors, int theColors[][3], ecx = Widget* this)	eax, ecx, edx		设置控件的颜色向量的前 theNumColors 项的颜色（不透明度为 255），当项数不足时会相应调整容器的大小。		【虚函数】[[[(Widget*)]+0]+84]
5399C0	Sexy::Widget::SetColors(int theNumColors, int theColors[][4], ecx = Widget* this)	eax, ecx, edx		设置控件的颜色向量的前 theNumColors 项的颜色，当项数不足时会相应调整容器的大小。		【虚函数】[[[(Widget*)]+0]+80]
539A60	Sexy::Widget::SetColor(const Color& theColor, int theIdx, ecx = Widget* this)	eax, ecx, edx		设置控件的颜色向量的第 theIdx 项的颜色，当项数不足时会调整容器的大小为 theIdx + 1。		【虚函数】[[[(Widget*)]+0]+88]
539AE0	Sexy::Widget::GetColor(int theIdx, ecx = Widget* this)	eax = const Color& aColor; ecx, edx		取得控件的颜色向量的第 theIdx 项的引用，当项数越界时返回一个静态颜色（0x75C8E0）的引用。		【虚函数】[[[(Widget*)]+0]+90]
539B50	Sexy::Widget::GetColor;(const Color& theDefaultColor, int theIdx, _Out_ Color&& aColor, ecx = Widget* this)	eax = Color&& aColor; ecx, edx		取得控件的颜色向量的第 theIdx 项的颜色，当项数越界时返回 theDefaultColor。		【虚函数】[[[(Widget*)]+0]+8C]
539BD0	Sexy::Widget::Resize(int theHeight, int theWidth, int theY, int theX, ecx = Widget* this)	eax, ecx, edx		设置控件的位置及尺寸，将相关受影响的控件标记为已变更，并由控件管理器刷新鼠标。		【虚函数】[[[(Widget*)]+0]+A0]
539C30	Sexy::Widget::Resize(const Rect& theRect, ecx = Widget* this)	eax, ecx, edx		设置控件的位置矩形。此函数的实质即为539BD0的函数。		【虚函数】[[[(Widget*)]+0]+9C]
539C60	Sexy::Widget::Move(int theNewY, int theNewX, ecx = Widget* this)	eax, ecx, edx		移动控件的位置，不改变其尺寸大小。		【虚函数】[[[(Widget*)]+0]+A4]
539C80	Sexy::Widget::WantsFocus(ecx = Widget* this)	al = 0(否) | 1(是)		判断控件是否需要焦点（返回 mWantsFocus 的值）。		【虚函数】[[[(Widget*)]+0]+A8]
539C90	Sexy::Widget::SetDisabled(bool isDisabled, ecx = Widget* this)	eax, ecx, edx		设置控件的禁用与否，并依此设置部分控件的获得焦点情况。		【虚函数】[[[(Widget*)]+0]+94]
539D10	Sexy::Widget::GotFocus(ecx = Widget* this)	eax, ecx, edx		控件获得焦点。		【虚函数】[[[(Widget*)]+0]+B4]
539D20	Sexy::Widget::LostFocus(ecx = Widget* this)	eax, ecx, edx		控件失去焦点。		【虚函数】[[[(Widget*)]+0]+B8]
539D30	Sexy::Widget::Update(ecx = Widget* this)	此函数不改变任何寄存器		控件更新。此函数内部直接跳转至537F50的函数。		【虚函数】[[[(Widget*)]+0]+58]
539D40	Sexy::Widget::KeyDown(KeyCode theKey, ecx = Widget* this)	eax, ecx, edx		控件中键盘按键按下。		【虚函数】[[[(Widget*)]+0]+C0]
539D90	Sexy::Widget::KeyUp(KeyCode theKey, ecx = Widget* this)	eax, ecx, edx		控件中键盘按下的按键松开。		【虚函数】[[[(Widget*)]+0]+C4]
539DA0	Sexy::Widget::ShowFinger(bool on, ecx = Widget* this)	eax, ecx, edx		控件中设置鼠标是否显示手型。		【虚函数】[[[(Widget*)]+0]+98]
539DD0	Sexy::Widget::MouseDown(int theClickCount, int y, int x, ecx = Widget* this)	eax, ecx, edx		鼠标在控件内 (x, y) 位置处按下，其坐标使用以控件本身位置为参考的相对坐标。;其中，theClickCount 大于 0 时表示左击的次数，小于 0 时表示右击的次数的相反数，为 3 时表示中键点击。		【虚函数】[[[(Widget*)]+0]+D8]
539E30	Sexy::Widget::MouseDown(int theClickCount, int theBtnNum, int y, int x, ecx = Widget* this)	eax, ecx, edx		鼠标在控件内 (x, y) 位置处按下，其坐标使用以控件本身位置为参考的相对坐标。;其中，theBtnName 为按下的按键（0：左键1：右键2：中键），theClickCount 为点击的次数。		【虚函数】[[[(Widget*)]+0]+D4]
539E40	Sexy::Widget::MouseUp(int y, int x, ecx = Widget* this)	eax, ecx, edx		按下的鼠标在控件内 (x, y) 位置处松开，其坐标使用以控件本身位置为参考的相对坐标。		【虚函数】[[[(Widget*)]+0]+E4]
539E50	Sexy::Widget::MouseUp(int theClickCount, int y, int x, ecx = Widget* this)	eax, ecx, edx		按下的鼠标在控件内 (x, y) 位置处松开，其坐标使用以控件本身位置为参考的相对坐标。		【虚函数】[[[(Widget*)]+0]+E0]
539EC0	Sexy::Widget::WriteCenteredLine;(const std::string& theLine, int anOffset, Graphics* g, _Out_ Rect&& aRect, ecx = Widget* this)	eax = Rect&& aRect; ecx, edx		在控件内高度为 theOffset 的位置居中绘制 theLines 文本，返回实际绘制区域的矩形。		【虚函数】[[[(Widget*)]+0]+F8]
539F40	Sexy::Widget::WriteCenteredLine;(const Point& theShadowOffset, Color theColor2, Color theColor1, const std::string& theLine, ; int anOffset, Graphics* g, _Out_ Rect&& aRect, ecx = Widget* this)	eax = Rect&& aRect; ecx, edx		在控件内高度为 theOffset 的位置居中绘制 theLines 文本，返回实际绘制区域的矩形。;其中 theShadowOffset 为文本阴影的偏移，theColor1 和 theColor2 分别为文本颜色和阴影颜色。		【虚函数】[[[(Widget*)]+0]+F4]
53A050	Sexy::Widget::WriteString;(int theLength, int theOffset, bool drawString, int theJustification, int theWidth, ; int theY, int theX, const std::string& theString, Graphics* g, ecx = Widget* this)	eax = int aOffsetX; ecx, edx		计算以字符串从 theOffset 位置开始 theLength 长度的部分时的实际绘制区域宽度，;当 theLength = -1 时，绘制部分改为从 theOffset 位置开始至字符串结束。;当 drawString = 1 时，会同时直接在 (theX, theY) 位置处以 theWidth 为参考宽度绘制字符串。		【虚函数】[[[(Widget*)]+0]+FC]
53A0A0	Sexy::Widget::WriteWordWrapped(int theJustification, int theLineSpacing, const std::string& theLine, ;                               const Rect& theRect, Graphics* g, ecx = Widget* this)	eax = int aHeight; ecx, edx		在 theRect 矩形区域内自动换行地绘制字符串，返回实际绘制的区域的高度。		【虚函数】[[[(Widget*)]+0]+100]
53A0E0	Sexy::Widget::GetWordWrappedHeight;(int aLineSpacing, const std::string& theLine, int theWidth, Graphics* g, ecx = Widget* this)	eax = int aHeight; ecx, edx		取得字符串 theLines 在 theWidth 宽度内自动换行地绘制时，实际绘制区域所占用的高度。		【虚函数】[[[(Widget*)]+0]+104]
53A100	Sexy::Widget::GetNumDigits(int theNumber, ecx = Widget* this)	eax = int aNumDigits; ecx, edx		取得一个正整数 theNumber 在十进制下的数位数量。对于小于等于 0 的数，返回 1。		【虚函数】[[[(Widget*)]+0]+108]
53A120	Sexy::Widget::WriteNumberFromStrip;(int aSpacing, Image* theNumberStrip, int theY, int theX, int theNumber, Graphics* g, ecx = Widget* this)	eax, ecx, edx		使用指定的数字图像条贴图绘制数字 theNumber，其中 aSpacing 为每两位数字之间的间距。		【虚函数】[[[(Widget*)]+0]+10C]
53A230	Sexy::Widget::Contains(int theY, int theX, ecx = Widget* this)	al = 0(否) | 1(是); ecx, edx		判断点 (theX, theY) 是否位于控件控件内。		【虚函数】[[[(Widget*)]+0]+110]
53A270	Sexy::Widget::GetInsetRect(_Out_ Rect&& aRect, ecx = Widget* this)	eax = Rect&& aRect; ecx, edx		取得控件在计入嵌入边距后的实际内容区域的矩形，矩形坐标使用绝对坐标。		【虚函数】[[[(Widget*)]+0]+114]
53A2B0	Sexy::Widget::Layout(eax = Widget* theRelativeWidget, Widget* this)	eax, ecx, edx		将控件自身调整为与 theRelativeWidget 相同大小，并将自身排版于 theRelativeWidget 的上方。
53A510	Sexy::Slider::Slider(SliderListener* theListener, int theId, esi = Slider* this)	eax = *this; ecx, edx		初始化创建 Slider 滑动条控件。需要一个大小为 0xB8 的内存区域用于构造 this。;其中，[[*theListener+0]+0] 为滑动条的滑块位置变更事件的函数（参数为双浮点型滑块值和滑动条控件ID）。;默认无滑动事件的 SliderListener 的虚函数表地址为 0x6686B0，其滑动事件的函数地址为 483370。
53A580	Sexy::Slider::SetValue(double theValue, ecx = Slider* this)	eax, ecx, edx		设置滑动条当前滑块的值，实际设置的值会被强制限定在 [0, 1] 内。同时将滑动条控件标记为已变更。		【虚函数】[[[(Slider*)]+0]+118]
53A5D0	Sexy::Slider::Draw(Graphics* g, ecx = Slider* this)	eax, ecx, edx		绘制滑动条控件。		【虚函数】[[[(Slider*)]+0]+68]
53A940	Sexy::Slider::MouseDown(int theClickCount, int y, int x, ecx = Slider* this)	eax, ecx, edx		鼠标在滑动条控件上按下时，根据鼠标按下的位置和滑动条方向相应地设置滑块的值。		【虚函数】[[[(Slider*)]+0]+D8]
53AA50	Sexy::Slider::MouseMove(int y, int x, ecx = Slider* this)	eax, ecx, edx		鼠标在滑动条控件中移动时，根据鼠标是否位于滑块上，相应地设置鼠标光标样式。		【虚函数】[[[(Slider*)]+0]+D0]
53AB20	Sexy::Slider::MouseDrag(int y, int x, ecx = Slider* this)	eax, ecx, edx		鼠标在滑动条控件中拖动时，相应修改滑块的值。若滑块的值发生变动，则由监听器处理相关事件。		【虚函数】[[[(Slider*)]+0]+E8]
53AC10	Sexy::Slider::MouseUp(int y, int x, ecx = Slider* this)	eax, ecx, edx		滑动条控件中按住的鼠标松开时，将光标设置为箭头样式，并由监听器处理滑块位置变更的事件。		【虚函数】[[[(Slider*)]+0]+E4]
53AC50	Sexy::Slider::MouseLeave(ecx = Slider* this)	eax, ecx, edx		鼠标移出滑动条控件区域时，除非正在拖动滑块，否则将光标设置为箭头样式。		【虚函数】[[[(Slider*)]+0]+CC]
53AC70	Sexy::ListWidget::ListWidget(ListListener* theListener, ListWidget* this)	eax = *this; ecx, edx		初始化创建 List 列表控件。需要一个大小为 0xF8 的内存区域用于构造 this。;其中，[[*theListener+0]+0~8] 分别为列表的点击、关闭、鼠标悬浮项变更事件的函数。;默认 listListener 的虚函数表地址为 0x66E4E8，其各事件的函数地址依次为 483370、42FB50、483370。;自定义点击事件时，要求其函数参数分别为：点击类型、点击的项Index、列表控件ID（以上依次push入栈）;ecx = ListListener* this 指针。函数结束时，使用 ret 0C 返回。
53AD90	Sexy::ListWidget::`scalar deleting destructor'(unsigned int flags, ecx = ListWidget* this)	eax = *this; ecx, edx		删除列表控件，当 flags 的第 0 位置 1 时会额外释放列表控件本身占用的内存空间。		【虚函数】[[[(ListWidget*)]+0]+0]
53ADB0	Sexy::ListWidget::~ListWidget(ecx = ListWidget* this)	eax, ecx, edx		销毁列表控件，删除每项颜色和文本的向量容器，并释放文本容器中的字符串。
53AE40	Sexy::ListWidget::RemovedFromManager(WidgetManager* theWidgetManager, ecx = ListWidget* this)	eax, ecx, edx		列表控件移出控件管理器，触发列表监听器的列表关闭事件。		【虚函数】[[[(ListWidget*)]+0]+54]
53AE80	Sexy::ListWidget::GetSortKey(int theIdx, _Out_ std::string&& aKeyString, ecx = ListWidget* this)	eax = std::string&& aKeyString; ecx, edx		取得列表控件中第 theIdx 行在进行排序时的键字符串，其值为该项自身的键与子列表对应项的键的结合。		【虚函数】[[[(ListWidget*)]+0]+118]
53B0C0	Sexy::ListWidget::Sort(bool ascending, ecx = ListWidget* this)	eax, ecx, edx		将列表控件中的所有项进行排序，其中 ascending 指定采用升序或降序。		【虚函数】[[[(ListWidget*)]+0]+11C]
53B570	Sexy::ListWidget::GetStringAt(int theIdx, _Out_ std::string&& aLine, ecx = ListWidget* this)	eax = std::string&& aLine; ecx, edx		取得列表控件中第 theIdx 行的文本字符串。		【虚函数】[[[(ListWidget*)]+0]+120]
53B5F0	Sexy::ListWidget::Resize(int theHeight, int theWidth, int theY, int theX, ecx = ListWidget* this)	eax, ecx, edx		设置列表控件的位置及尺寸，并重新计算列表每一页的大小。		【虚函数】[[[(ListWidget*)]+0]+A0]
53B690	Sexy::ListWidget::AddLine(bool alphabetical, const std::string& theLine, ecx = ListWidget* this)	eax = int aNewLineIdx; ecx, edx		在列表控件尾部添加一行文本。若指定了 alphabetical，则改为按照字符顺序在合适的位置插入。		【虚函数】[[[(ListWidget*)]+0]+124]
53BAF0	Sexy::ListWidget::SetLine(const std::string& theLine, int theIdx, ecx = ListWidget* this)	eax, ecx, edx		将列表控件中第 theIdx 行的文本设置为 theLine。指定的 theIdx 应小于列表中当前最大行数。		【虚函数】[[[(ListWidget*)]+0]+128]
53BB60	Sexy::ListWidget::GetLineCount(ecx = ListWidget* this)	eax = int aLineCount; ecx, edx		取得列表控件的行数。		【虚函数】[[[(ListWidget*)]+0]+12C]
53BB90	Sexy::ListWidget::GetLineIdx(const std::string& theLine, ecx = ListWidget* this)	eax = int anIdx; ecx, edx		取得字符串 theLine 首次出现在列表控件中的行数，若列表中不存在 theLine 字符串则返回 -1。		【虚函数】[[[(ListWidget*)]+0]+130]
53BC70	Sexy::ListWidget::SetColor(const Color& theColor, const std::string& theLine, ecx = ListWidget* this)	eax, ecx, edx		设置列表控件中首个文本为 theLine 的行的文本颜色（若存在）。		【虚函数】[[[(ListWidget*)]+0]+134]
53BCA0	Sexy::ListWidget::SetColor(const Color& theColor, int theIdx, ecx = ListWidget* this)	eax, ecx, edx		设置列表控件颜色向量中第 theIdx 项的颜色。此函数内部直接跳转至539A60的函数。		【虚函数】[[[(ListWidget*)]+0]+88]
53BCB0	Sexy::ListWidget::SetLineColor(const Color& theColor, int theIdx, ecx = ListWidget* this)	eax, ecx, edx		设置列表控件及其所有父列表和子列表中第 theIdx 行的文本颜色（若存在）。		【虚函数】[[[(ListWidget*)]+0]+138]
53BD70	Sexy::ListWidget::RemoveLine(int theIdx, ecx = ListWidget* this)	eax, ecx, edx		移除列表控件中第 theIdx 行的文本。		【虚函数】[[[(ListWidget*)]+0]+13C]
53BF40	Sexy::ListWidget::RemoveAll(ecx = ListWidget* this)	eax, ecx, edx		移除列表控件中的所有文本。		【虚函数】[[[(ListWidget*)]+0]+140]
53C100	Sexy::ListWidget::GetOptimalWidth(ecx = ListWidget* this)	eax = int aWidth; ecx, edx		综合考虑列表中每行的文本宽度，计算列表控件最适合的宽度（即：最宽一行的文本宽度 + 16）。		【虚函数】[[[(ListWidget*)]+0]+144]
53C1F0	Sexy::ListWidget::GetOptimalHeight(ecx = ListWidget* this)	eax = int aHeight; ecx, edx		计算列表控件最适合的高度（即：每行文本高度 * 行数 + 8）。		【虚函数】[[[(ListWidget*)]+0]+144]
53C250	Sexy::ListWidget::OrderInManagerChanged(ecx = ListWidget* this)	eax, ecx, edx		当列表控件在控件管理器中所处的图层发生变化时，重新将子列表和滚动条置于自身上层（若存在）。		【虚函数】[[[(ListWidget*)]+0]+78]
53C2A0	Sexy::ListWidget::Draw(Graphics* g, ecx = ListWidget* this)	eax, ecx, edx		绘制列表控件。		【虚函数】[[[(ListWidget*)]+0]+68]
53C730	Sexy::ListWidget::ScrollPosition(double thePosition, int theId, ecx = ScrollListener* this)	eax, ecx, edx		当列表控件的滚动条滚动至 thePosition 位置时，记录位置，并将子列表（若存在）也滚动至相同位置。		【虚函数】[[[(ScrollListener*)]+0]+0]/[[[(ListWidget*)]+88]+0]
53C780	Sexy::ListWidget::SetHilite(edx = int theHiliteIdx, eax = ListWidget* this)	eax, ecx, edx		将列表控件中第 theHiliteIdx 行的文本设置为鼠标悬浮时的高亮显示，指定 -1 行时表示清除高亮效果。;若给定的高亮行与当前高亮行不同，且列表存在监听器，则交由监听器处理高亮行发生变动的事件。
53C7B0	Sexy::ListWidget::MouseMove(int y, int x, ecx = ListWidget* this)	eax, ecx, edx		鼠标在列表控件中移动时，根据鼠标是否位于文本行上，相应地设置高亮的行及鼠标光标样式。		【虚函数】[[[(ListWidget*)]+0]+D0]
53C8A0	Sexy::ListWidget::MouseDown(int theClickCount, int theBtnNum, int y, int x, ecx = ListWidget* this)	eax, ecx, edx		鼠标在列表控件中按下时，若按下位置位于文本行上且列表存在监听器，则交由监听器处理列表点击事件。		【虚函数】[[[(ListWidget*)]+0]+D4]
53C8E0	Sexy::ListWidget::MouseLeave(ecx = ListWidget* this)	eax, ecx, edx		鼠标移出列表控件区域时，清除文本行的高亮效果，并将光标设置为箭头样式。		【虚函数】[[[(ListWidget*)]+0]+CC]
53C930	Sexy::ListWidget::SetSelect(int theSelectIdx, ecx = ListWidget* this)	eax, ecx, edx		设置列表控件当前选中第 theSelectIdx 行。		【虚函数】[[[(ListWidget*)]+0]+14C]
53C970	Sexy::ListWidget::MouseWheel(int theDelta, ecx = ListWidget* this)	eax, ecx, edx		当鼠标在列表控件内滚动 theDelta 高度时，相应地调整滚动条（若存在）的滚动位置。		【虚函数】[[[(ListWidget*)]+0]+EC]
53C9D0	Sexy::Insets::Insets(eax = Insets* this)	eax = *this; ecx		初始化嵌入边距结构为 (0, 0, 0, 0)。需要一个大小为 0x10 的内存区域用于构造 this。
53C9E0	Sexy::HyperlinkWidget::HyperlinkWidget(eax = ButtonListener* theListener, esi = HyperlinkWidget* this)	eax = *this; ecx, edx		初始化创建 HyperlinkWidget 超链接控件。需要一个大小为 0x148 的内存区域用于构造 this。
53CA40	Sexy::ButtonWidget::`scalar deleting destructor'(unsigned int flags, ecx = ButtonWidget* this);Sexy::HyperlinkWidget::`scalar deleting destructor'(unsigned int flags, ecx = HyperlinkWidget* this)	eax = *this; ecx, edx		删除按钮控件(/超链接控件)，当 flags 的第 0 位置 1 时会额外释放控件本身占用的内存空间。		【虚函数】[[[(ButtonWidget*)]+0]+0] | [[[(HyperlinkWidget*)]+0]+0]
53CA60	Sexy::HyperlinkWidget::Draw(Graphics* g, ecx = HyperlinkWidget* this)	eax, ecx, edx		绘制超链接控件。		【虚函数】[[[(HyperlinkWidget*)]+0]+68]
53CC00	Sexy::HyperlinkWidget::MouseEnter(ecx = HyperlinkWidget* this)	eax, ecx, edx		鼠标进入超链接控件区域时，将自身标记为已变更。		【虚函数】[[[(HyperlinkWidget*)]+0]+C8]
53CC20	Sexy::HyperlinkWidget::MouseLeave(ecx = HyperlinkWidget* this)	eax, ecx, edx		鼠标移出超链接控件区域时，将自身标记为已变更。		【虚函数】[[[(HyperlinkWidget*)]+0]+CC]
53CC40	Sexy::EditWidget::EditWidget(EditListener* theEditListener, EditWidget* this)	eax = *this; ecx, edx		初始化创建 Edit 输入框控件。需要一个大小为 0x12C 的内存区域用于构造 this。;其中，[[*theEditListener+0]+0~C] 分别为输入框的点击、AllowKey、AllowChar、AllowText 的函数。;默认无点击事件的 theEditListener 的虚函数表地址为 0x657BDC，;其各事件的函数地址依次为：4566F0、42FBC0、42FBC0、42FBC0。
53CD70	Sexy::EditWidget::`scalar deleting destructor'(unsigned int flags, ecx = EditWidget* this)	eax = *this; ecx, edx		删除输入框控件，当 flags 的第 0 位置 1 时会额外释放控件本身占用的内存空间。		【虚函数】[[[(EditWidget*)]+0]+0]
53CD90	Sexy::EditWidget::~EditWidget(ecx = EditWidget* this)	eax, ecx, edx		销毁输入框控件，删除文本字体和所有宽度检查字体。
53CEB0	Sexy::EditWidget::ClearWidthCheckFonts(eax = EditWidget* this)	eax, ecx, edx		删除输入框控件的所有宽度检查字体，并清空其宽度检查列表。
53CF40	Sexy::EditWidget::AddWidthCheckFont(int theMaxPixels, Font* theFont, ecx = EditWidget* this)	eax, ecx, edx		输入框控件增加一种宽度检查。宽度检查：要求输入框中的文本字符串在特定字体下的宽度不超过给定值。;当文本字符串不满足任一宽度检查时，将舍弃字符串结尾的若干字符直至其满足所有已添加的宽度检查的要求。;若指定 theMaxPixels 为 -1，则表示该宽度检查的宽度要求与输入框控件自身的最大宽度限制相同。
53CFC0	Sexy::EditWidget::SetText(bool leftPosToZero, const std::string& theText, ecx = EditWidget* this)	eax, ecx, edx		设置输入框中的文本内容并适当调整当前文本横向滚动位置。若指定了 leftPosToZero，则直接将滚动位置归零。		【虚函数】[[[(EditWidget*)]+0]+124]
53D030	Sexy::EditWidget::GetDisplayString(esi = EditWidget* this)	eax = std::string& aDisplayString; ecx, edx		根据需要决定输入框当前显示的字符串是文本字符串或是密码字符串，返回对所使用字符串的引用。
53D100	Sexy::EditWidget::Resize(int theHeight, int theWidth, int theY, int theX, ecx = EditWidget* this)	eax, ecx, edx		设置输入框控件的位置及尺寸，并重新调整当前文本横向滚动位置令光标保持在当前显示的文本范围内。		【虚函数】[[[(EditWidget*)]+0]+A0]
53D130	Sexy::EditWidget::SetFont(Font* theWidthCheckFont = 0, Font* theFont, ecx = EditWidget* this)	eax, ecx, edx		删除旧有字体并重新设定输入框的文本字体，若 theWidthCheckFont 不为 0，则额外增加一种宽度检查字体。		【虚函数】[[[(EditWidget*)]+0]+120]
53D180	Sexy::EditWidget::Draw(Graphics* g, ecx = EditWidget* this)	eax, ecx, edx		绘制输入框控件。		【虚函数】[[[(EditWidget*)]+0]+68]
53D6B0	Sexy::EditWidget::UpdateCaretPos(ecx = EditWidget* this)	eax, ecx, edx		更新插入符号的位置，确保其位置在游戏画面内。原版仅当玩家使用的是平板电脑时会有调用。
53D730	Sexy::EditWidget::GotFocus(ecx = EditWidget* this)	eax, ecx, edx		输入框控件获得焦点，显示光标，平板电脑额外更新并显示插入符号。		【虚函数】[[[(EditWidget*)]+0]+B4]
53D790	Sexy::EditWidget::LostFocus(ecx = EditWidget* this)	eax, ecx, edx		输入框控件失去焦点，隐藏光标，平板电脑额外隐藏插入符号。		【虚函数】[[[(EditWidget*)]+0]+B8]
53D7D0	Sexy::EditWidget::Update(ecx = EditWidget* this)	eax, ecx, edx		输入框控件更新。当获得焦点时，更新光标的闪烁，平板电脑额外更新插入符号位置。		【虚函数】[[[(EditWidget*)]+0]+58]
53D830	Sexy::EditWidget::EnforceMaxPixels(ebx = EditWidget* this)	eax, ecx, edx		根据宽度检查和输入框自身的宽度限制，将文本字符串超出最大允许宽度的部分舍去。
53DA10	Sexy::EditWidget::IsPartOfWord(char theChar)	eax = 0(否) | 1(是)		判断给定字符是否可能为某单词的一部分。
53DA50	Sexy::EditWidget::ProcessKey(char theChar, KeyCode theKey, ecx = EditWidget* this)	eax, ecx, edx		处理在输入框中输入的特殊按键或特殊字符，例如退格、撤销、粘贴等。;对于合法的非特殊字符，则将其添加到当前输入内容的字符串中，并进行相应的处理。		【虚函数】[[[(EditWidget*)]+0]+118]
53E900	Sexy::EditWidget::KeyDown(KeyCode theKey, ecx = EditWidget* this)	eax, ecx, edx		输入框控件中键盘按键按下，处理可能的特殊按键。		【虚函数】[[[(EditWidget*)]+0]+C0]
53E950	Sexy::EditWidget::KeyChar(char theChar, ecx = EditWidget* this)	eax, ecx, edx		输入框控件中输入 theChar 字符，处理可能的特殊字符。		【虚函数】[[[(EditWidget*)]+0]+BC]
53E970	Sexy::EditWidget::GetCharAt(int y, int x, ecx = EditWidget* this)	eax = int aPos; ecx, edx		取得输入框控件中 (x, y) 位置处的字符在文本字符串中的索引位置。		【虚函数】[[[(EditWidget*)]+0]+12C]
53EAC0	Sexy::EditWidget::FocusCursor(bool bigJump, ecx = EditWidget* this)	eax, ecx, edx		不断尝试回退或推进输入框内文本的横向滚动直到文本内的光标位置处于输入框当前显示的文本范围之内。;当指定 bigJump 时，每次尝试回退或推进 10 个字符否则，每次尝试回退或推进 1 个字符。
53ECC0	Sexy::EditWidget::MouseDown(int theClickCount, int theBtnNum, int y, int x, ecx = EditWidget* this)	eax, ecx, edx		鼠标在输入框控件中按下时，进行光标位置及选中文字相关的更新。		【虚函数】[[[(EditWidget*)]+0]+D4]
53ED30	Sexy::EditWidget::MouseUp(int theClickCount, int theBtnNum, int y, int x, ecx = EditWidget* this)	eax, ecx, edx		鼠标在输入框控件中松开时，进行光标位置及选中文字相关的更新。		【虚函数】[[[(EditWidget*)]+0]+DC]
53EDA0	Sexy::EditWidget::HiliteWord(ecx = EditWidget* this)	eax, ecx, edx		将当前光标所在的一个单词高亮。判定的依据是前后一个空格之间的部分。		【虚函数】[[[(EditWidget*)]+0]+11C]
53EE90	Sexy::EditWidget::MouseDrag(int y, int x, ecx = EditWidget* this)	eax, ecx, edx		鼠标在输入框控件中拖动时，相应更新光标位置和选中的部分。		【虚函数】[[[(EditWidget*)]+0]+E8]
53EEE0	Sexy::EditWidget::MouseEnter(ecx = EditWidget* this)	eax, ecx, edx		鼠标进入输入框控件区域时，设置光标为文本型。		【虚函数】[[[(EditWidget*)]+0]+C8]
53EEF0	Sexy::EditWidget::MouseLeave(ecx = EditWidget* this)	eax, ecx, edx		鼠标移出输入框控件区域时，设置光标为指针型。		【虚函数】[[[(EditWidget*)]+0]+CC]
53EF00	Sexy::EditWidget::MarkDirty(ecx = EditWidget* this)	eax, ecx, edx		将输入框控件标记为已变更。		【虚函数】[[[(EditWidget*)]+0]+44]
53EF40	Sexy::Checkbox::MouseDown(int theClickCount, int y, int x, ecx = Checkbox* this)	eax, ecx, edx		勾选框内鼠标按下，此函数内部直接跳转至539DD0的函数。		【虚函数】[[[(Checkbox*)]+0]+D8]
53EF50	Sexy::Checkbox::Checkbox(CheckboxListener* theCheckboxListener, int theId, esi = Checkbox* this)	eax = *this; ecx, edx		初始化创建 Checkbox 勾选框控件。需要一个大小为 0xEC 的内存区域用于构造 this。;其中，[[*theCheckboxListener+0]+0] 为勾选框的勾选事件的函数。;默认无勾选事件的 CheckboxListener 的虚函数表地址为 0x6686B4，其勾选事件的函数地址为 4566F0。;自定义勾选事件时，要求其函数参数分别为：是否勾选、勾选框控件ID（以上依次push入栈）;ecx = CheckboxListener* this 指针。函数结束时，使用 ret 08 返回。
53F030	Sexy::Checkbox::SetChecked(bool tellListener, bool checked, ecx = Checkbox* this)	eax, ecx, edx		设置勾选框的勾选与否。若指定了 tellListener，则由勾选框监听器处理勾选事件。		【虚函数】[[[(Checkbox*)]+0]+118]
53F070	Sexy::Checkbox::IsChecked(ecx = Checkbox* this)	al = bool checked		取得勾选框是否被勾选。		【虚函数】[[[(Checkbox*)]+0]+11C]
53F080	Sexy::Checkbox::Draw(Graphics* g, ecx = Checkbox* this)	eax, ecx, edx		绘制勾选框控件。		【虚函数】[[[(Checkbox*)]+0]+68]
53F1C0	Sexy::Checkbox::MouseDown(int theClickCount, int theBtnNum, int y, int x, ecx = Checkbox* this)	eax, ecx, edx		勾选框内鼠标按下，设置勾选状态，并由勾选框监听器处理勾选事件。		【虚函数】[[[(Checkbox*)]+0]+D4]
53F200	Sexy::ButtonWidget::ButtonWidget(ButtonListener* theButtonListener, int theId, ButtonWidget* this)	eax = *this; ecx, edx		初始化创建 ButtonWidget 按钮控件。需要一个大小为 0x120 的内存区域用于构造 this。
53F340	Sexy::ButtonWidget::~ButtonWidget(ButtonWidget* this)	eax, ecx, edx		销毁按钮。
53F3E0	Sexy::ButtonWidget::SetFont(Font* theFont, ecx = ButtonWidget* this)	eax, ecx, edx		删除旧有文本字体，并复制 theFont 字体作为按钮的文本字体。		【虚函数】[[[(ButtonWidget*)]+0]+11C]
53F410	Sexy::ButtonWidget::IsButtonDown(ecx = ButtonWidget* this)	al = bool isButtonDown		判断按钮是否按下。当且仅当鼠标按下且鼠标位于按钮上且按钮可用时，返回“是”。		【虚函数】[[[(ButtonWidget*)]+0]+120]
53F430	Sexy::ButtonWidget::HaveButtonImage(eax = const Rect& theRect, Image* theImage)	eax = 0(否) | 1(是)		判断按钮是否存在某一状态时的贴图。参数使用按钮对应状态的贴图的指针及对应状态下的矩形的引用。;当且仅当贴图的指针不为空指针，或矩形的宽度不为 0 时，返回“是”。
53F450	Sexy::ButtonWidget::DrawButtonImage(int x, edi = int y, eax = const Rect& theRect, ;                                    Image* theImage, ecx = Graphics* g, ecx = ButtonWidget* this)	eax, ecx, edx		若给定的 theRect 矩形的宽度不为零，则绘制游戏按钮贴图的 theRect 区域，否则绘制 theImage 贴图。		【虚函数】[[[(ButtonWidget*)]+0]+118]
53F4A0	Sexy::ButtonWidget::Draw(Graphics* g, ecx = ButtonWidget* this)	eax, ecx, edx		绘制按钮控件。		【虚函数】[[[(ButtonWidget*)]+0]+68]
53FB00	Sexy::ButtonWidget::SetDisabled(bool isDisabled, ecx = ButtonWidget* this)	eax, ecx, edx		设置按钮禁用与否。若按钮存在禁用状态的贴图，则将按钮标记为已变更。		【虚函数】[[[(ButtonWidget*)]+0]+94]
53FB30	Sexy::ButtonWidget::MouseEnter(ecx = EditWidget* this)	eax, ecx, edx		鼠标进入按钮区域时，进行按钮图像相关处理，并由按钮监听器处理鼠标进入事件。		【虚函数】[[[(ButtonWidget*)]+0]+C8]
53FBE0	Sexy::ButtonWidget::MouseLeave(ecx = EditWidget* this)	eax, ecx, edx		鼠标进入按钮区域时，进行按钮图像相关处理，并由按钮监听器处理鼠标移出事件。		【虚函数】[[[(ButtonWidget*)]+0]+CC]
53FCC0	Sexy::ButtonWidget::MouseMove(int y, int x, ecx = ButtonWidget* this)	eax, ecx, edx		鼠标在按钮中移动时，由按钮监听器处理鼠标移动事件。		【虚函数】[[[(ButtonWidget*)]+0]+D0]
53FCF0	Sexy::ButtonWidget::MouseDown(int theClickCount, int theBtnNum, int y, int x, ecx = ButtonWidget* this)	eax, ecx, edx		鼠标在按钮中按下时，由按钮监听器处理按钮按下事件。		【虚函数】[[[(ButtonWidget*)]+0]+D4]
53FD20	Sexy::ButtonWidget::MouseUp(int theClickCount, int theBtnNum, int y, int x, ecx = ButtonWidget* this)	eax, ecx, edx		鼠标在按钮中松开时，由按钮监听器处理按钮松开事件。		【虚函数】[[[(ButtonWidget*)]+0]+DC]
53FD60	Sexy::ButtonWidget::Update(ecx = ButtonWidget* this)	eax, ecx, edx		按钮更新。当按钮按下时，由按钮监听器处理按钮按住事件。同时更新按钮悬浮相关的不透明度。		【虚函数】[[[(ButtonWidget*)]+0]+58]
53FE40	Sexy::Dialog::Dialog(int theButtonMode, const std::string& theDialogFooter, const std::string& theDialogLines, ;                     const std::string& theDialogHeader, bool isModal, int theId, Dialog* this)	eax = *this; ecx, edx		初始化创建对话。需要一个大小至少为 0x150 的内存区域用于构造 this。;会根据 theButtonMode 在对话窗口下方创建 0～2 个按钮，存储在 [*this+94] 和 [*this+98] 中。
540360	Sexy::Dialog::`scalar deleting destructor'(unsigned int flags, ecx = Dialog* this)	eax = *this; ecx, edx		删除 Dialog 对话，当 flags 的第 0 位置 1 时会额外释放对话本身占用的内存空间。		【虚函数】[[[(Dialog*)]+0]+0]
540380	Sexy::Dialog::~Dialog(ecx = Dialog* this)	eax, ecx, edx		销毁 Dialog 对话，删除“是”“否”按钮和标题、正文字体以及标题、正文、页脚文本的字符串。
5404B0	Sexy::Dialog::SetColor(const Color& theColor, int theIdx, ecx = Dialog* this)	eax, ecx, edx		设置对话的颜色向量的第 theIdx 项的颜色，当项数不足时会调整容器的大小为 theIdx + 1。;若指定项(theIdx)为按钮文本颜色(3)或按钮文本高亮颜色(4)，则额外设置对话按钮(若有)颜色向量的相应项。		【虚函数】[[[(Dialog*)]+0]+88]
540540	Sexy::Dialog::SetButtonFont(Font* theFont, ecx = Dialog* this)	eax, ecx, edx		设置对话中“是”和“否”按钮（若有）的字体。		【虚函数】[[[(Dialog*)]+0]+11C]
540590	Sexy::Dialog::SetHeaderFont(Font* theFont, ecx = Dialog* this)	eax, ecx, edx		删除旧有标题字体，并复制 theFont 字体作为对话的标题字体。		【虚函数】[[[(Dialog*)]+0]+11C]
5405C0	Sexy::Dialog::SetLinesFont(Font* theFont, ecx = Dialog* this)	eax, ecx, edx		删除旧有正文字体，并复制 theFont 字体作为对话的正文字体。		【虚函数】[[[(Dialog*)]+0]+120]
5405F0	Sexy::Dialog::EnsureFonts(Dialog* this)	eax, ecx, edx		确保对话存在标题字体和正文字体。若不存在，则创建 Arial Unicode MS 系统字体。
540750	Sexy::Dialog::GetPreferredHeight(int theWidth, ecx = Dialog* this)	eax = int aHeight; ecx, edx		当指定对话的宽度时，根据对话内的文本和按钮等，计算对话的首选高度值。		【虚函数】[[[(Dialog*)]+0]+124]
5408F0	Sexy::Dialog::Draw(Graphics* g, ecx = Dialog* this)	eax, ecx, edx		绘制对话。		【虚函数】[[[(Dialog*)]+0]+68]
540C00	Sexy::Dialog::AddedToManager(WidgetManager* theWidgetManager, ecx = Dialog* this)	eax, ecx, edx		将对话自身加入控件管理器，并将对话框上的“是”“否”按钮（若有）加入自身的子控件链表中。		【虚函数】[[[(Dialog*)]+0]+50]
540C40	Sexy::Dialog::RemovedFromManager(WidgetManager* theWidgetManager, ecx = Dialog* this)	eax, ecx, edx		将对话自身移出控件管理器，并将对话框上的“是”“否”按钮（若有）移出自身的子控件链表。		【虚函数】[[[(Dialog*)]+0]+50]
540C80	Sexy::Dialog::OrderInManagerChanged(ecx = Dialog* this)	eax, ecx, edx		当对话在控件管理器中所处的图层发生变化时，重新将“是”“否”按钮（若有）置于自身上层。		【虚函数】[[[(Dialog*)]+0]+78]
540CC0	Sexy::Dialog::Resize(int theHeight, int theWidth, int theY, int theX, ecx = Dialog* this)	eax, ecx, edx		设置对话内部各控件及其本身的位置和大小。		【虚函数】[[[(Dialog*)]+0]+A0]
540E10	Sexy::Dialog::MouseDown(int theClickCount, int theBtnNum, int y, int x, ecx = Dialog* this)	eax, ecx, edx		鼠标在对话中按下时，若为左键按下，则开始进入拖动状态。		【虚函数】[[[(Dialog*)]+0]+D4]
540E50	Sexy::Dialog::MouseDrag(int y, int x, ecx = Dialog* this)	eax, ecx, edx		鼠标在对话中拖动时，若当前处于拖动状态，则计算并更新对话被拖动后的新位置。		【虚函数】[[[(Dialog*)]+0]+E8]
540F60	Sexy::Dialog::MouseUp(int theClickCount, int theBtnNum, int y, int x, ecx = Dialog* this)	eax, ecx, edx		鼠标在对话中松开时，若当前处于拖动状态，则退出拖动状态。		【虚函数】[[[(Dialog*)]+0]+DC]
540F90	Sexy::Dialog::Update(ecx = Dialog* this)	此函数不改变任何寄存器		对话更新。此函数内部直接跳转至539D30的函数。		【虚函数】[[[(Dialog*)]+0]+58]
540FA0	Sexy::Dialog::IsModal(ecx = Dialog* this)	al = bool isModal		判断对话是否为模态对话（返回 mIsModal 的值）。		【虚函数】[[[(Dialog*)]+0]+128]
540FB0	Sexy::Dialog::WaitForResult(bool autoKill, ecx = Dialog* this)	eax = int aDepressedButtonId; ecx, edx		对话中临时执行更新程序直到得出对话结果，若 isAutoKill 为真则在取得返回值后自动销毁对话。;返回值表示被按下的按钮的编号，默认情况下，“是”按钮的编号为 0x3E8，“否”按钮的编号为 0x3E9。		【虚函数】[[[(Dialog*)]+0]+12C]
541010	Sexy::Dialog::ButtonPress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		对话中按钮按下时，若按下的为“是”或“否”按钮，则转交由对话监听器处理对话按钮按下事件。		【虚函数】[[[(ButtonListener*)]+0]+4]/[[[(Dialog*)]+88]+4]
541040	Sexy::Dialog::ButtonDepress(int theId, ecx = ButtonListener* this)	eax, ecx, edx		对话中按钮松开时，若按下的为“是”或“否”按钮，则记录对话结果并转交由对话监听器处理对话按钮松开事件。		【虚函数】[[[(ButtonListener*)]+0]+8]/[[[(Dialog*)]+88]+8]
541080	Sexy::DialogButton::DialogButton(ButtonListener* theButtonListener, ecx = int theId, DialogButton* this)	eax = *this; ecx, edx		初始化创建 DialogButton 对话按钮。需要一个大小为 0x138 的内存区域用于构造 this。
541110	Sexy::DialogButton::Draw(Graphics* g, ecx = DialogButton* this)	eax, ecx, edx		绘制对话按钮。		【虚函数】[[[(DialogButton*)]+0]+68]
5417F0	std::vector<std::string>::push_back(ebx = const std::string& _Val, esi = std::vector<std::string>* this)	eax, ecx, edx		在字符串的向量容器的尾部添加一个字符串元素。
541870	std::vector<Color>::insert(std::vector<Color>::iterator _Where, const std::string& _Val, ;                          _Out_ std::vector<Color>::iterator&& _Ret, eax = std::vector<Color>* this)	eax = &&_Ret; ecx, edx		在颜色的向量容器的 _Where 位置插入一个颜色元素 _Val，并返回指示该元素所在位置的迭代器。
541900	std::vector<Color>::clear(edi = std::vector<Color>* this)	eax, ecx, edx		清除颜色的向量容器中的所有元素，但不改变其容量。
541D20	std::pair<std::string, std::string>::pair<std::string, std::string>;(const std::string& _Val2, const std::string& _Val1, std::pair<std::string, std::string>* this)	eax = *this; ecx, edx		从给定的两个字符串创建一个对组。需要一个大小为 0x38 的内存区域用于构造 this。
541DA0	std::list<Widget*>::_Buynode()	eax = _Node* _Pnode; ecx, edx		创建一个控件指针的链表容器的节点，并初始化该节点的前、后节点指针指向其自身。;对于其他整数或相当于整数的类型的链表同样适用。
5422C0	std::list<Widget*>::clear(esi = std::list<Widget*>* this)	eax, ecx, edx		释放控件指针的链表中的所有节点并释放这些节点占用的内存空间。;对于其他整数或相当于整数的类型的链表同样适用。
542A40	std::_Allocate<std::_List_nod<Widget*>::_Node>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个控件指针的链表容器的节点所需要的内存空间，单个节点占用的内存大小为 0xC。;当 _Count 个节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。;对于其他整数或相当于整数的类型的链表节点同样适用。
542B10	std::pair<std::string, std::string>::pair<std::string, std::string>;(edi = const std::pair<std::string, std::string>& __that, std::pair<std::string, std::string>* this)	eax = *this; ecx, edx		复制两个字符串的对组 __that 以创建新对组。
5438C0	MTAutoDisallowRand::~MTAutoDisallowRand()	ecx		利用临时变量析构函数的自动调用，在自动禁用随机析构时，自动取消禁止随机的设定。
543900	GetPakPtr_SexyAppBase()	eax = PakInterfaceBase*? aPak; ecx, edx		从 SexyAppBase 的资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
5439A0	p_fopen_SexyAppBase(eax = const char* theFileName)	eax = PFILE*? pFile; ecx, edx		以二进制只读模式读取指定文件，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，失败则返回 0。;优先尝试通过资源包文件接口在 pak 资源包内读取文件，当无法获取接口时尝试直接读取文件。
543A00	p_fclose_SexyAppBase(esi = PFILE* theFile)	eax = 0(成功) | -1(失败); ecx, edx		尝试通过资源包文件接口关闭文件，当无法获取接口时直接关闭文件流。同时释放 pFile 占用的内存空间。
543A40	p_fseek_SexyAppBase(esi = int theOrigin, edi = PFILE* theFile)	eax = 0(成功) | 非零(失败); ecx, edx		设置资源包数据文件当前读取指针指向的位置。其中 theOrigin 的取值可参考 61D72B 的函数的说明。;优先尝试通过资源包文件接口操作读取指针，当无法获取接口时尝试直接操作文件流的读取指针。
543A70	p_ftell_SexyAppBase(esi = PFILE* theFile)	eax = int aOffset; ecx, edx		取得资源包数据文件当前读取指针指向的位置距离文件头的偏移量。;优先尝试通过资源包文件接口获取偏移量，当无法获取接口时尝试直接在文件流中获取偏移量。
543AA0	p_fread_SexyAppBase(esi = PFILE* theFile, edi = int theCount, ebx = void* thePtr)	eax = int 实际完整读取的项数; ecx, edx		读取资源包数据文件中 theCount 字节的数据并解密，然后将解密后的数据写入 thePtr 指向的地址;优先尝试通过资源包文件接口读取数据，当无法获取接口时尝试直接从文件流中读取数据。
543AD0	GetSHGetFolderPath(ebx = HMODULE* theMod, eax = const char* theDLL)	eax = void* aFunc; ecx, edx		加载 theDLL 并从中获取 SHGetFolderPathA 函数地址，若获取失败则返回 0 并将 0 写入 [theMod] 地址中。;当获取成功时，额外将加载的动态链接库的模块句柄写入 [theMod] 地址中，后续将用于动态链接库的释放。
543B10	Sexy::SexyAppBase::SexyAppBase(SexyAppBase* this)	eax = *this; ecx, edx		初始化创建基础程序。需要一个大小为 0x640 的内存区域用于构造 this。
544940	Sexy::SexyAppBase::`scalar deleting destructor'(unsigned int flags, ecx = SexyAppBase* this)	eax = *this; ecx, edx		删除基础程序，当 flags 的第 0 位置 1 时会额外释放基础程序本身占用的内存空间。		【虚函数】[[[(SexyAppBase*)]+0]+0]
5449D0	Sexy::SexyAppBase::~SexyAppBase(ecx = SexyAppBase* this)	eax, ecx, edx		销毁基础程序，进行一些基础设定的存储和底层系统的释放。
545500	ChangeDisplayWindowEnumProc(LPARAM lParam, HWND hwnd)	eax = 1; ecx, edx		全屏模式下更改分辨率的 EnumWindows 调用时的回调函数，其返回值表示是否需要继续枚举下一个窗口。;当 lParam 为 0 时，记录 hwnd 窗口的矩形当 lParam 为 1 时，将 hwnd 窗口的矩形恢复为记录值。
5456A0	Sexy::SexyAppBase::ClearUpdateBacklog(esi = SexyAppBase* this)	eax, ecx, edx		清除更新积压，即清除需要浮点时间更新的任务。
5456C0	Sexy::SexyAppBase::IsScreenSaver(eax = SexyAppBase* this)	al = bool isScreenSaver		判断程序当前是否处于屏保状态（返回 mIsScreenSaver 的值）。
5456D0	Sexy::SexyAppBase::AppCanRestore(ecx = SexyAppBase* this)	al = bool canRestore		当窗口大小即将恢复时，判断程序当前能否恢复窗口（返回 !mDisabled）。		【虚函数】[[[(SexyAppBase*)]+0]+184]
5456E0	Sexy::SexyAppBase::ReadDemoBuffer(ebx = std::string& theError, ecx = SexyAppBase* this)	al = bool succeed; ecx, edx		从示例文件中读取数据到示例缓冲区，若读取失败则将错误字符串赋值给 theError。
545C00	`Sexy::SexyAppBase::ReadDemoBuffer'::`5'::AutoFile::AutoFile(ecx = FILE* file, eax = AutoFile* this)	eax = *this		创建自动文件，其中 file 为需要进行自动操作的文件。需要一个大小为 0x4 的内存区域用于构造 this。
545C10	`Sexy::SexyAppBase::ReadDemoBuffer'::`5'::AutoFile::~AutoFile(eax = AutoFile* this)	eax, edx		利用临时变量析构函数的自动调用，在自动文件析构时，自动关闭操作的文件。
545C20	Sexy::SexyAppBase::WriteDemoBuffer(ecx = SexyAppBase* this)	eax, ecx, edx		将示例缓冲区的数据写入到示例文件。
545E40	Sexy::SexyAppBase::DemoSyncBuffer(ecx = Buffer* theBuffer, ecx = SexyAppBase* this)	eax, ecx, edx		进行示例缓冲区与 theBuffer 缓冲区之间的数据同步。
545EF0	Sexy::SexyAppBase::DemoSyncString(ecx = std::string* theString, SexyAppBase* this)	eax, ecx, edx		示例缓冲区同步一个字符串 *theString。
545F90	Sexy::SexyAppBase::DemoSyncBool(bool* theBool, SexyAppBase* this)	eax, ecx, edx		示例缓冲区同步一个 bool 逻辑值 *theBool。
546010	Sexy::SexyAppBase::NewDialog;(int theButtonMode, const std::string& theDialogFooter, const std::string& theDialogLines, ; const std::string& theDialogHeader, bool isModal, int theDialogId, ecx = SexyAppBase* this)	eax = Dialog* aDialog; ecx, edx		创建 Dialog 对话。		【虚函数】[[[(SexyAppBase*)]+0]+64]
5460A0	Sexy::SexyAppBase::DoDialog;(int theButtonMode, const std::string& theDialogFooter, const std::string& theDialogLines, ; const std::string& theDialogHeader, bool isModal, int theDialogId, ecx = SexyAppBase* this)	eax = Dialog* aDialog; ecx, edx		创建 Dialog 对话，创建前会先删除当前 theDialogId 的对话。;当 isModal = 1 时创建模态窗口，此时其他窗口将无法响应点击事件且不可获得焦点。		【虚函数】[[[(SexyAppBase*)]+0]+120]
5460F0	Sexy::SexyAppBase::GetDialog(int theDialogID, ecx = SexyAppBase* this)	eax = Dialog* aDialog; ecx, edx		根据给定的 theDialogID 取得相应的对话。		【虚函数】[[[(SexyAppBase*)]+0]+124]
546160	Sexy::SexyAppBase::KillDialog;(bool deleteWidget, bool removeWidget, int theDialogID, ecx = SexyAppBase* this)	al = bool 是否成功; ecx, edx		结束 theDialogID 的对话，并视 removeWidget 和 deleteWidget 的值额外执行移除或(并)删除对话。		【虚函数】[[[(SexyAppBase*)]+0]+138]
5462D0	Sexy::SexyAppBase::KillDialog(int theDialogID, ecx = SexyAppBase* this)	al = bool 是否成功; ecx, edx		结束 theDialogID 的对话。		【虚函数】[[[(SexyAppBase*)]+0]+134]
5462F0	Sexy::SexyAppBase::KillDialog(Dialog* theDialog, ecx = SexyAppBase* this)	al = bool 是否成功; ecx, edx		结束 theDialog 对话。		【虚函数】[[[(SexyAppBase*)]+0]+130]
546310	Sexy::SexyAppBase::GetDialogCount(ecx = SexyAppBase* this)	eax = int aCount		获取当前游戏中的对话数量。		【虚函数】[[[(SexyAppBase*)]+0]+13C]
546320	Sexy::SexyAppBase::AddDialog(Dialog* theDialog, int theDialogID, ecx = SexyAppBase* this)	eax, ecx, edx		将 theDialogID 与其对应的 theDialog 加入 DialogMap 中。创建对话后调用此函数以让对话能够显示。		【虚函数】[[[(SexyAppBase*)]+0]+12C]
546430	Sexy::SexyAppBase::AddDialog(Dialog* theDialog, ecx = SexyAppBase* this)	eax, ecx, edx		将 theDialog 加入 DialogMap 中。此函数的实质即为[[[(SexyAppBase*)]+0]+12C]的函数。		【虚函数】[[[(SexyAppBase*)]+0]+130]
546450	Sexy::SexyAppBase::DialogButtonPress(int theButtonId, int theDialogID, ecx = DialogListener* this)	eax, ecx, edx		鼠标按下 theDialogID 的对话中 theButtonId 的按钮，根据按下的按钮执行相应的事件。;若按下的为“是”/“否”按钮，则视为在程序中按下编号为 (2000/3000 + theDialogID) 的按钮。		【虚函数】[[[(DialogListener*)]+0]+0]/[[[(SexyAppBase*)]+4]+0]
5464A0	Sexy::SexyAppBase::DialogButtonDepress(int theButtonId, int theDialogID, ecx = DialogListener* this)	eax, ecx, edx		鼠标松开 theDialogID 的对话中 theButtonId 的按钮，根据松开的按钮执行相应的事件。;若松开的为“是”/“否”按钮，则视为在程序中松开编号为 (2000/3000 + dialogID) 的按钮。		【虚函数】[[[(DialogListener*)]+0]+4]/[[[(SexyAppBase*)]+4]+4]
5464F0	Sexy::SexyAppBase::URLOpenFailed(const std::string& theURL, ecx = SexyAppBase* this)	eax, ecx, edx		打开 theURL 网页失败，结束打开网页状态。		【虚函数】[[[(SexyAppBase*)]+0]+8C]
546500	Sexy::SexyAppBase::URLOpenSucceeded(const std::string& theURL, ecx = SexyAppBase* this)	eax, ecx, edx		打开 theURL 网页成功，结束打开网页状态。若调用打开网页时指定了“shutdownOnOpen”，则关闭程序。		【虚函数】[[[(SexyAppBase*)]+0]+90]
546520	Sexy::SexyAppBase::OpenURL(bool shutdownOnOpen, const std::string& theURL, ecx = SexyAppBase* this)	al = bool 是否成功打开指定网页; ecx, edx		尝试在浏览器中打开 theURL 网页，若失败则会弹出失败弹窗并将网址复制到剪贴板。;如果指定了 shutdownOnOpen，则当成功打开指定网页时，立即关闭程序。		【虚函数】[[[(SexyAppBase*)]+0]+94]
5465D0	Sexy::SexyAppBase::GetProductVersion;(const std::string& thePath, _Out_ std::string&& aProductVersion, ecx = SexyAppBase* this)	eax = std::string&& aProductVersion; ;ecx, edx		取得程序的版本信息字符串。		【虚函数】[[[(SexyAppBase*)]+0]+98]
546750	Sexy::SexyAppBase::WaitForLoadingThread(esi = SexyAppBase* this)	eax, ecx, edx		等待加载线程完成。每 20 毫秒检测一次是否加载完成。
546780	Sexy::SexyAppBase::TakeScreenshot(SexyAppBase* this)	eax, ecx, edx		截取屏幕截图并将截图保存在游戏文件夹内的“_screenshots”文件夹，文件名为“image%d.png”。
546C40	Sexy::SexyAppBase::DumpProgramInfo(SexyAppBase* this)	eax, ecx, edx		转储部分程序信息，并导出所有内存图片。
549440	std::fstream::`vbase destructor'(eax = std::fstream* this)	eax, ecx, edx		std::fstream 基类虚析构函数，销毁输入输出文件流并调用基类的析构函数。
549460	std::multimap<int, MemoryImage*, std::greater<int>>::~multimap<int, MemoryImage*, std::greater<int>>;(eax = std::multimap<int, MemoryImage*, std::greater<int>>* this)	eax, ecx, edx		销毁并释放整数向内存贴图指针的多重映射容器。
5494A0	SexyAppBase::GetLoadingThreadProgress(ecx = SexyAppBase* this)	st(0) = aProgress; eax, ecx		取得程序加载线程的加载进度。		【虚函数】[[[(SexyAppBase*)]+0]+100]
5494F0	Sexy::SexyAppBase::RegistryWrite;(unsigned long theLength, const unsigned char* theValue, unsigned long theType, ; ebx = const std::string& theValueName, SexyAppBase* this)	al = bool 是否写入成功; ecx, edx		向注册表系统当前用户下的游戏注册项添加一个名称为 theValueName 的 theType 类型的值（若原先不存在），;并将该值的数据改写为 theValue 指向的数据的前 theLength 个字节的内容。;系统当前用户下的游戏注册项：HKEY_CURRENT_USER\SOFTWARE\PopCap\PlantsVsZombies。
5498C0	Sexy::SexyAppBase::RegistryWriteString;(eax = const std::string& theString, ebx = const std::string& theValueName, SexyAppBase* this)	al = bool 是否写入成功; ecx, edx		设置注册表系统当前用户下的游戏注册项中名为 theValueName 的项的数据为字符串 theString。
549990	Sexy::SexyAppBase::RegistryWriteInteger;(int theValue, ebx = const std::string& theValueName, ecx = SexyAppBase* this)	al = bool 是否写入成功; ecx, edx		设置注册表系统当前用户下的游戏注册项中名为 theValueName 的项的数据为整数 theValue。
549920	Sexy::SexyAppBase::RegistryWriteBoolean;(bool theValue, ebx = const std::string& theValueName, edx = SexyAppBase* this)	al = bool 是否写入成功; ecx, edx		设置注册表系统当前用户下的游戏注册项中名为 theValueName 的项的数据为 theValue 转化的整数。
549940	Sexy::SexyAppBase::WriteToRegistry(ecx = SexyAppBase* this)	eax, ecx, edx		将程序的所有基础设定数据（音量、窗口模式、窗口坐标等）写入注册表。		【虚函数】[[[(SexyAppBase*)]+0]+5C]
549C90	Sexy::SexyAppBase::RegistryEraseKey(const std::string& _theKeyName, ecx = SexyAppBase* this)	al = bool 是否删除成功; ecx, edx		删除注册表系统当前用户下的游戏注册项下的 _theKeyName 键。
549F50	Sexy::SexyAppBase::RegistryRead;(unsigned long* theLength, _Out_ unsigned char* theValue, eax = _Out_ unsigned long* theType, ; ecx = const std::string& theValueName, edx = SexyAppBase* this)	al = bool 是否读取成功; ecx, edx		从系统当前用户下的游戏注册项中读取名为 theValueName 的值，;theLength 指向的值表示 theValue 缓冲区大小。;将读取到的值的类型和数据及实际读取的字节数分别写入 theType、theValue 和 theLength 中。
549F70	Sexy::SexyAppBase::RegistryReadKey;(HKEY theKey, edx = unsigned long* theLength, ecx = _Out_ unsigned char* theValue, ; _Out_ unsigned long* theType, const std::string& theValueName, SexyAppBase* this)	al = bool 是否读取成功; ecx, edx		从指定键下的游戏注册项中读取名为 theValueName 的值，;并将该值的类型和数据分别写入 theType 和 theValue 中。;若无须读取值的类型，则参数 theType 可以为空指针若无须读取值的数据，则参数 theValue 可以为空指针。;theLength 指向的值表示 theValue 缓冲区最多可以接受的数据大小，;读取后将实际读取的字节数写入 theLength 中。
54A360	Sexy::SexyAppBase::RegistryReadString;(esi = std::string* theString, ecx = const std::string& theValueName, edx = SexyAppBase* this)	al = bool 是否读取成功; ecx, edx		以字符串类型读取注册表系统当前用户下的游戏注册项中名为 theValueName 的项的数据，;并以读取的结果赋值 *theString。
54A3F0	Sexy::SexyAppBase::RegistryReadInteger;(int* theValue, const std::string& theValueName, edx = SexyAppBase* this)	al = bool 是否读取成功; ecx, edx		以整数类型读取注册表系统当前用户下的游戏注册项中名为 theValueName 的项的数据并将结果写入 theValue。
54A440	Sexy::SexyAppBase::RegistryReadBoolean;(bool* theValue, ecx = const std::string& theValueName, edx = SexyAppBase* this)	al = bool 是否读取成功; ecx, edx		以整数类型读取注册表系统当前用户下的游戏注册项中名为 theValueName 的项的数据，;然后将读取到的整数转化为布尔值并写入 theValue。
54A470	Sexy::SexyAppBase::ReadFromRegistry(ecx = SexyAppBase* this)	eax, ecx, edx		从注册表中读取程序的所有基础设定数据（音量、窗口模式、窗口坐标等）。		【虚函数】[[[(SexyAppBase*)]+0]+60]
54A9D0	Sexy::SexyAppBase::WriteBytesToFile;(unsigned long theDataLen, const void* theData, ebx = const std::string& theFileName, ecx = SexyAppBase* this)	al = bool 是否写入成功; ecx, edx		按字节向文件写入数据。其中 theFileName 应当包含文件的完整路径及文件名。
54AC60	Sexy::SexyAppBase::WriteBufferToFile;(eax = const Buffer* theBuffer, ebx = const std::string& theFileName, SexyAppBase* this)	al = bool 是否写入成功; ecx, edx		将缓冲区中的数据写入文件。此函数的实质即为54A9D0的函数。
54AC80	Sexy::SexyAppBase::ReadBufferFromFile;(bool dontWriteToDemo, Buffer* theBuffer, const std::string& theFileName, SexyAppBase* this)	al = bool 是否读取成功; ecx, edx		从文件读取二进制数据至缓冲区。其中 theFileName 应当包含文件的完整路径及文件名。
54B1C0	Sexy::SexyAppBase::FileExists(eax = const std::string& theFileName, ecx = SexyAppBase* this)	al = 0(不存在) | 1(存在); ecx, edx		演示运行下，判断缓冲区中是否存在文件正常运行下，判断是否存在 theFileName 文件。
54B260	Sexy::SexyAppBase::EraseFile(eax = const std::string& theFileName, ecx = SexyAppBase* this)	al = bool 是否删除成功; ecx, edx		删除文件名为 theFileName 的文件。其中 theFileName 应当包含被删除文件的完整路径及文件名。
54B2A0	Sexy::SexyAppBase::SEHOccured(ecx = SexyAppBase* this)	eax, ecx, edx		捕获到结构化异常时的接口函数。静音音乐并隐藏主窗口。		【虚函数】[[[(SexyAppBase*)]+0]+9C]
54B2E0	Sexy::SexyAppBase::GetGameSEHInfo(_Out_ std::string&& anInfoString, ecx = SexyAppBase* this)	eax = std::string&& anInfoString; ecx, edx		获取程序结构化异常的基础信息。		【虚函数】[[[(SexyAppBase*)]+0]+A0]
54B810	Sexy::SexyAppBase::ShutDown(ecx = SexyAppBase* this)	eax, ecx, edx		关闭程序，删除程序窗口。		【虚函数】[[[(SexyAppBase*)]+0]+A8]
54B930	Sexy::SexyAppBase::RestoreScreenResolution(edi = SexyAppBase* this)	eax, ecx, edx		如果当前为全屏模式，则恢复屏幕初始的分辨率。
54B970	Sexy::SexyAppBase::DoExit(int theCode, edi = SexyAppBase* this)	eax, ecx, edx		恢复屏幕初始的分辨率，然后以 theCode 代码退出程序。
54B980	Sexy::SexyAppBase::UpdateFrames(ecx = SexyAppBase* this)	eax, ecx, edx		基础程序对游戏内容进行一轮的更新。		【虚函数】[[[(SexyAppBase*)]+0]+20]
54B9C0	Sexy::SexyAppBase::DoUpdateFramesF(float theFrac, ecx = SexyAppBase* this)	eax, ecx, edx		若当前开启垂直同步更新且窗口未最小化，则由控件管理器进行一轮的浮点时间更新。		【虚函数】[[[(SexyAppBase*)]+0]+28]
54B9F0	Sexy::SexyAppBase::DoUpdateFrames(ecx = SexyAppBase* this)	eax, ecx, edx		判断并执行基础程序对游戏内容进行一轮的更新。		【虚函数】[[[(SexyAppBase*)]+0]+24]
54BAE0	Sexy::SexyAppBase::Redraw(Rect* theClipRect = 0, ecx = SexyAppBase* this)	eax, ecx, edx		尝试刷新 *theClipRect 区域的重绘，若 theClipRect 为空指针则表示重绘全屏。;当重绘失败时，根据对当前的各项状态进行适当调整，并重新进行绘制接口和贴图等的初始化。		【虚函数】[[[(SexyAppBase*)]+0]+170]
54BC80	CalculateFPS()	eax, ecx, edx		计算程序的当前 FPS 并据此更新 FPS 贴图。
54C0A0	FPSDrawCoords(int theY, int theX)	eax, ecx, edx	0x8	向 FPS 贴图上绘制鼠标坐标信息。
54C320	CalculateDemoTimeLeft()	eax, ecx, edx		计算并向 FPS 贴图上绘制演示运行的剩余时间信息。
54C650	Sexy::SexyAppBase::DrawDirtyStuff(ecx = SexyAppBase* this)	al = bool 是否成功; ecx, edx		重绘游戏中所有被标记为已变更的对象及 FPS 贴图（若需要），并对游戏绘制相关数据进行更新。		【虚函数】[[[(SexyAppBase*)]+0]+16C]
54C950	Sexy::SexyAppBase::LogScreenSaverError(const std::string& theError, ecx = SexyAppBase* this)	eax, ecx, edx		将屏保错误信息 theError 载入 ScrError.txt 文件。		【虚函数】[[[(SexyAppBase*)]+0]+84]
54CAD0	Sexy::SexyAppBase::BeginPopup(ecx = SexyAppBase* this)	eax, ecx, edx		程序进行弹窗之前，使 GDI 所写向的页面成为主页面。		【虚函数】[[[(SexyAppBase*)]+0]+6C]
54CB00	Sexy::SexyAppBase::EndPopup(ecx = SexyAppBase* this)	eax, ecx, edx		程序结束弹窗之后，清除按键记录，由控件管理器触发鼠标松开，并释放鼠标捕获。		【虚函数】[[[(SexyAppBase*)]+0]+70]
54CB40	Sexy::SexyAppBase::MsgBox;(int theFlags, const std::string& theTitle, const std::string& theText, ecx = SexyAppBase* this)	eax = int aResult; ecx, edx		记录 theText 屏保错误，然后弹出消息弹窗。		【虚函数】[[[(SexyAppBase*)]+0]+78]
54CBC0	Sexy::SexyAppBase::MsgBox;(int theFlags, const std::wstring& theTitle, const std::wstring& theText, ecx = SexyAppBase* this)	eax = int aResult; ecx, edx		记录 theText 屏保错误，然后弹出消息弹窗。		【虚函数】[[[(SexyAppBase*)]+0]+74]
54CCB0	Sexy::SexyAppBase::Popup(const std::string& theString, ecx = SexyAppBase* this)	eax, ecx, edx		记录 theString 屏保错误，然后弹出 FATAL_ERROR 弹窗。		【虚函数】[[[(SexyAppBase*)]+0]+80]
54CE70	Sexy::SexyAppBase::Popup(const std::wstring& theString, ecx = SexyAppBase* this)	eax, ecx, edx		记录 theString 屏保错误，然后弹出 FATAL_ERROR 弹窗。		【虚函数】[[[(SexyAppBase*)]+0]+7C]
54D080	Sexy::SexyAppBase::SafeDeleteWidget(Widget* theWidget, ecx = SexyAppBase* this)	eax, ecx, edx		将控件的删除信息（包含当前程序更新深度及控件的指针）加入安全删除链表，以便后续进行安全删除处理。		【虚函数】[[[(SexyAppBase*)]+0]+88]
54D0E0	MarkerListDialogProc(LPARAM lParam, WPARAM wParam, unsigned int msg, HWND hwnd)	eax = int processed; ecx, edx		演示标志列表对话的处理函数。若已完成了对 msg 消息的处理，则返回 1 表示无须重复进行默认的处理。
54D440	lpdwAlign(unsigned short* lpIn)	eax = unsigned short* ul	0x4	将 lpIn 指针的数值向上对齐至 4 的整数倍。对齐操作的是指针本身而非指针指向的值。
54D450	ListDemoMarkers()	eax = int ret; ecx, edx		列出演示标志列表并显示对话框窗口。
54D580	JumpToTimeDialogProc(LPARAM lParam, WPARAM wParam, UINT msg, HWND hwnd)	eax = int processed; ecx, edx		演示时间跳跃对话的处理函数。若已完成了对 msg 消息的处理，则返回 1 表示无须重复进行默认的处理。
54D880	DemoJumpToTime()	eax = int ret; ecx, edx		显示演示时间跳跃对话窗口。
54DA60	ToggleDemoSoundVolume()	eax, ecx, edx		调整演示运行的音乐和音效音量。
54DB00	ScreenSaverWindowProc;(LRESULT& theResult, ecx = LPARAM lParam, WPARAM wParam, edx = UINT uMsg, HWND hWnd)	al = bool 是否继续窗口处理; ecx, edx	0xC	屏保状态下的窗口处理函数。将窗口处理结果写入 theResult，若返回 false 则后续不再进行主窗口处理。
54DF60	Sexy::SexyAppBase::WindowProc(LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd)	eax = long lResult; ecx, edx		程序窗口处理函数。
54EAE0	Sexy::SexyAppBase::HandleNotifyGameMessage(int theParam, int theType, ecx = SexyAppBase* this)	eax, ecx, edx		当窗口收到消息通知时，若消息类型 theType 为 0，则将程序窗口移动至顶端显示。		【虚函数】[[[(SexyAppBase*)]+0]+B8]
54EB80	Sexy::SexyAppBase::RehupFocus(esi = SexyAppBase* this)	eax, ecx, edx		判断程序窗口当前是否需要获得焦点，并据此执行获得焦点或失去焦点。
54EC20	Sexy::SexyAppBase::ClearKeysDown(ecx = SexyAppBase* this)	eax, ecx, edx		强制清除所有按键的按下记录。
54EC60	Sexy::SexyAppBase::WriteDemoTimingBlock(edi = SexyAppBase* this)	eax, ecx, edx		向示例缓冲区中写入当前演示运行的时间相关信息。
54ECF0	Sexy::SexyAppBase::PrepareDemoCommand(edi = SexyAppBase* this)	al = bool succeed; ecx, edx		预读取演示运行指令的类型与数量等基础数据。
54ED70	Sexy::SexyAppBase::ProcessDemo(SexyAppBase* this)	eax, ecx, edx		演示运行的过程处理。
54F0E0	Sexy::SexyAppBase::ShowMemoryUsage(ecx = SexyAppBase* this)	eax, ecx, edx		计算并弹窗展示程序内存的使用情况。
54FA40	std::_Tree<std::_Tmap_traits<PixelFormat, std::pair<int, int>>>::~_Tree<std::_Tmap_traits<PixelFormat, std::pair<int, int>>>;(eax = std::_Tree<std::_Tmap_traits<PixelFormat, std::pair<int, int>>* this)	eax, ecx, edx		销毁并释放像素格式向格式使用情况对组的映射红黑树。
54FA80	Sexy::SexyAppBase::IsAltKeyUsed(WPARAM wParam, ecx = SexyAppBase* this)	al = bool altKeyUsed; ecx, edx		判断按键消息 wParam 按下的是否为 alt 键。		【虚函数】[[[(SexyAppBase*)]+0]+150]
54FAB0	Sexy::SexyAppBase::DebugKeyDown(int theKey, ecx = SexyAppBase* this)	al = bool done; ecx, edx		判断按下的调试按键并执行相应的调试功能处理。当返回 true 时，后续不再由控件管理器处理按键按下。		【虚函数】[[[(SexyAppBase*)]+0]+154]
54FD60	Sexy::SexyAppBase::DebugKeyDownAsync(bool altDown, bool ctrlDown, int theKey, ecx = SexyAppBase* this)	al = bool done; ecx, edx		按下调试按键时，结合当前 Ctrl 键和 Alt 键的按下情况进行综合处理。函数默认返回 0。		【虚函数】[[[(SexyAppBase*)]+0]+158]
54FD70	Sexy::SexyAppBase::ProcessDeferredMessages(SexyAppBase* this)	al = bool deferring; ecx, edx		处理延迟消息列表中的首个延迟消息，返回表示列表中是否仍然存在延迟消息的逻辑值。
5509A0	Sexy::SexyAppBase::Done3dTesting(ecx = SexyAppBase* this)	此函数不改变任何寄存器		3D 测试完成。默认不进行任何处理。		【虚函数】[[[(SexyAppBase*)]+0]+160]
5509B0	Sexy::SexyAppBase::NotifyCrashHook(_Out_ std::string&& anUploadFile, ecx = SexyAppBase* this)	eax = std::string&& anUploadFile; ecx, edx		捕获程序崩溃时的处理。返回需要上传的文件名，若返回空字符串则表示不上传任何文件。		【虚函数】[[[(SexyAppBase*)]+0]+164]
5509E0	Sexy::SexyAppBase::MakeWindow(ecx = SexyAppBase* this)	eax, ecx, edx		创建程序窗口，并进行相关的初始化。		【虚函数】[[[(SexyAppBase*)]+0]+2C]
551180	Sexy::SexyAppBase::DeleteNativeImageData(ecx = SexyAppBase* this)	eax, ecx, edx		删除所有内存贴图的原生数据（保留像素集）。		【虚函数】[[[(SexyAppBase*)]+0]+38]
551200	Sexy::SexyAppBase::DeleteExtraImageData(ecx = SexyAppBase* this)	eax, ecx, edx		删除所有内存贴图的软件缓冲区和 3D 缓冲区。		【虚函数】[[[(SexyAppBase*)]+0]+3C]
5512D0	Sexy::SexyAppBase::ReInitImages(ecx = SexyAppBase* this)	eax, ecx, edx		重新初始化所有内存贴图。		【虚函数】[[[(SexyAppBase*)]+0]+34]
551350	Sexy::SexyAppBase::LoadingThreadProcStub(void* theArg)	eax, ecx, edx	0x4	加载线程的切入点，进行加载线程的处理并在加载完成后输出加载时间的调试信息。;其中，参数的 theArg 为开始线程时提供的参数，其值实际为 gSexyAppBase 指针。
5513C0	Sexy::SexyAppBase::StartLoadingThread(esi = SexyAppBase* this)	eax, ecx, edx		若未开始加载线程，则调整当前主线程优先级并开始加载线程。
551400	Sexy::SexyAppBase::CursorThreadProc(esi = SexyAppBase* this)	eax, ecx, edx		光标线程的处理。
551520	Sexy::SexyAppBase::CursorThreadProcStub(void* theArg)	eax, ecx, edx	0x4	光标线程的切入点，初始化并进行光标线程的处理。;其中，参数的 theArg 为开始线程时提供的参数，其值实际为 gSexyAppBase 指针。
551540	Sexy::SexyAppBase::StartCursorThread(esi = SexyAppBase* this)	eax, ecx, edx		若未开始光标线程，则调整当前主线程优先级并开始光标线程。
551570	Sexy::SexyAppBase::SwitchScreenMode(bool force, bool is3d, bool wantWindowed, ecx = SexyAppBase* this)	eax, ecx, edx		尝试调整当前程序的窗口化（wantWindowed）和 3D 加速的开启（is3d）状态。		【虚函数】[[[(SexyAppBase*)]+0]+110]
551630	Sexy::SexyAppBase::SwitchScreenMode(bool wantWindowed, ecx = SexyAppBase* this)	eax, ecx, edx		尝试调整当前程序的窗口化与否。		【虚函数】[[[(SexyAppBase*)]+0]+114]
551660	Sexy::SexyAppBase::SwitchScreenMode(ecx = SexyAppBase* this)	eax, ecx, edx		强制调整当前程序的窗口化与否和 3D 加速的开启与否。		【虚函数】[[[(SexyAppBase*)]+0]+118]
551690	Sexy::SexyAppBase::SetAlphaDisabled(bool isDisabled, ecx = SexyAppBase* this)	eax, ecx, edx		设置程序窗口不透明度通道的禁用与否。		【虚函数】[[[(SexyAppBase*)]+0]+11C]
5516E0	Sexy::SexyAppBase::EnforceCursor(ecx = SexyAppBase* this)	eax, ecx, edx		根据当前光标样式的值，加载相应的光标资源并强制修改光标的形状。		【虚函数】[[[(SexyAppBase*)]+0]+30]
5518F0	Sexy::SexyAppBase::ProcessSafeDeleteList(ecx = SexyAppBase* this)	eax, ecx, edx		处理安全删除链表，删除当前已经达成其更新深度的控件。
5519F0	Sexy::SexyAppBase::UpdateFTimeAcc(esi = SexyAppBase* this)	eax, ecx, edx		浮点更新时间的积累。
551A60	Sexy::SexyAppBase::Process(bool allowSleep, ecx = SexyAppBase* this)	al = bool succeed; ecx, edx		程序更新的处理，其中 allowSleep 表示是否允许在处理过程中执行休眠。		【虚函数】[[[(SexyAppBase*)]+0]+1C]
551FE0	Sexy::SexyAppBase::DoMainLoop(ecx = SexyAppBase* this)	eax, ecx, edx		程序执行的主循环。		【虚函数】[[[(SexyAppBase*)]+0]+178]
552020	Sexy::SexyAppBase::UpdateAppStep(bool* updated, ecx = SexyAppBase* this)	al = bool succeed; ecx, edx		基础程序更新的一个步骤。若 updated 不为 0，则将是否全部更新完成的逻辑值写入 [updated] 地址中。		【虚函数】[[[(SexyAppBase*)]+0]+17C]
5521A0	Sexy::SexyAppBase::UpdateApp(ecx = SexyAppBase* this)	al = bool updated; ecx, edx		基础程序的更新。逐步进行程序的更新直至更新完成。		【虚函数】[[[(SexyAppBase*)]+0]+180]
5521F0	Sexy::SexyAppBase::InitDDInterface(esi = SexyAppBase* this)	eax = int aResult; ecx, edx		初始化程序的 DX 接口。
5522C0	Sexy::SexyAppBase::Start(ecx = SexyAppBase* this)	eax, ecx, edx		显示程序窗口并开始程序的主循环，直到程序退出时输出部分调试信息数据并进行部分基础设定的保存。		【虚函数】[[[(SexyAppBase*)]+0]+C0]
5524B0	Sexy::SexyAppBase::CheckSignature;(const std::string& theFileName, const Buffer& theBuffer, ecx = SexyAppBase* this)	al = bool passed; ecx, edx		检测 theFileName 文件的签名，用于判断文件是否被篡改。默认返回 false。		【虚函数】[[[(SexyAppBase*)]+0]+168]
5524C0	Sexy::SexyAppBase::LoadProperties(bool checkSig, ecx = const std::string& theFileName, SexyAppBase* this)	al = bool succeed; ecx, edx		加载 properties 文件。其中 checkSig 指定是否需要检查文件的签名。
5527B0	Sexy::SexyAppBase::ShowResourceError(bool doExit, ecx = SexyAppBase* this)	eax, ecx, edx		获取资源管理器中记录的错误原因并弹出错误弹窗。若 doExit 为 1 则同时退出程序。
552840	Sexy::SexyAppBase::GetBoolean(bool theDefault, ecx = const std::string& theId, eax = SexyAppBase* this)	al = bool aBoolean; ecx, edx		从程序的逻辑值属性容器中寻找 theId 对应的逻辑值，若未找到则返回 theDefault。
5528B0	Sexy::SexyAppBase::GetInteger(int theDefault, ecx = const std::string& theId, eax = SexyAppBase* this)	eax = int aInteger; ecx, edx		从程序的整数属性容器中寻找 theId 对应的整数值，若未找到则返回 theDefault。
552920	Sexy::SexyAppBase::GetString(const std::string& theDefault, ecx = const std::string& theId, ;                             esi = _Out_ std::string&& aString, eax = SexyAppBase* this)	eax = std::string&& aString; ecx, edx		从程序的字符串属性容器中寻找 theId 对应的字符串值，若未找到则返回 theDefault。
5529C0	Sexy::SexyAppBase::SetString(esi = const std::wstring& theValue, const std::string& theId, SexyAppBase* this)	eax, ecx, edx		将标签及其对应的内容的字符串添加至字符串属性容器中，若 theId 已存在则修改其对应的值为 theValue。
552AB0	std::pair<std::string, std::wstring>::~pair<std::string, std::wstring>(esi = std::pair<std::string, std::wstring>* this)	eax, ecx, edx		销毁字符串和宽字符串的对组，销毁字符串和宽字符串。
552B00	Sexy::SexyAppBase::SetBoolean(bool theValue, const std::string& theId, SexyAppBase* this)	eax, ecx, edx		将标签及其对应的内容的逻辑值添加至逻辑值属性容器中，若 theId 已存在则修改其对应的值为 theValue。
552BC0	Sexy::SexyAppBase::SetInteger(int theValue, const std::string& theId, SexyAppBase* this)	eax, ecx, edx		将标签及其对应的内容的整数添加至整数属性容器中，若 theId 已存在则修改其对应的值为 theValue。
552C80	Sexy::SexyAppBase::SetDouble(double theValue, const std::string& theId, SexyAppBase* this)	eax, ecx, edx		将标签及其对应的内容的双浮点数添加至双浮点数属性容器中，若 theId 已存在则修改其对应的值为 theValue。
552D40	std::pair<std::string, int>::~pair<std::string, int>(esi = std::pair<std::string, int>* this)	eax, ecx, edx		销毁字符串和整数的对组，销毁字符串。
552D70	Sexy::SexyAppBase::DoParseCmdLine(ecx = SexyAppBase* this)	eax, ecx, edx		获取命令行字符串并从中提取出包含所有命令行参数的字符串交由自身的 ParseCmdLine 函数处理。		【虚函数】[[[(SexyAppBase*)]+0]+AC]
552E20	Sexy::SexyAppBase::ParseCmdLine(const std::string& theCmdLine, ecx = SexyAppBase* this)	eax, ecx, edx		从 theCmdLine 字符串中依次提取出每一个命令和参数的字符串交由自身的 HandleCmdLineParam 函数处理。		【虚函数】[[[(SexyAppBase*)]+0]+AC]
552FD0	GetMaxDemoFileNum(bool doErase, int theMaxToKeep, const std::string& theDemoPrefix)	eax = int aDemoFileNum; ecx, edx	0xC	取得指定前缀的示例文件的数量。当文件数大于 theMaxToKeep 且指定了 doErase，则删除其中编号最小的一个。
5532B0	std::_Tree<std::_Tset_traits<int>>::~_Tree<std::_Tset_traits<int>>(eax = std::_Tree<std::_Tset_traits<int>>* this)	eax, ecx, edx		销毁并释放整数的集合红黑树。
5532F0	Sexy::SexyAppBase::HandleCmdLineParam;(const std::string& theParamValue, const std::string& theParamName, ecx = SexyAppBase* this)	eax, ecx, edx		根据给定的命令和参数进行相应的判断和处理。		【虚函数】[[[(SexyAppBase*)]+0]+B4]
553970	Sexy::SexyAppBase::ChangeDirHook(const char* theIntendedPath, ecx = SexyAppBase* this)	al = 0		即将改变工作目录时的 hook，返回值表示是否确认执行改变工作目录。函数直接返回“否”。		【虚函数】[[[(SexyAppBase*)]+0]+D0]
553980	Sexy::SexyAppBase::CreateMusicInterface(HWND theWindow, ecx = SexyAppBase* this)	eax = MusicInterface*? aInterface; ecx, edx		根据程序对于音乐及音乐格式的需求，执行创建默认音乐接口或 FMod 音乐接口或 Bass 音乐接口，失败则返回 0。;参数 theWindow 表示音乐接口所处的窗口的句柄，此函数固定使用程序自身的隐藏窗口，故此参数无实用。		【虚函数】[[[(SexyAppBase*)]+0]+48]
553A70	Sexy::SexyAppBase::Init(ecx = SexyAppBase* this)	eax, ecx, edx		程序初始化，包括命令行的处理、窗口的创建、基础设定的调整及程序内各系统的初始化等。		【虚函数】[[[(SexyAppBase*)]+0]+C4]
5546C0	Sexy::SexyAppBase::HandleGameAlreadyRunning(ecx = SexyAppBase* this)	eax, ecx, edx		当程序启动时发现已有相同程序正在运行时触发，若仅允许单个副本运行，则弹出该运行中的程序并结束自身运行。		【虚函数】[[[(SexyAppBase*)]+0]+BC]
5546F0	Sexy::SexyAppBase::CopyToClipboard(esi = const std::string& theString, eax = SexyAppBase* this)	eax, ecx, edx		将字符串的内容复制到剪贴板。
554800	Sexy::SexyAppBase::GetClipboard(esi = _Out_ std::string&& aString, SexyAppBase* this)	eax = std::string&& aString; ecx, edx		取得剪贴板中的内容字符串。
5548C0	Sexy::SexyAppBase::SetCursor(eax = int theCursorNum, ecx = SexyAppBase* this)	eax, ecx, edx		设置鼠标光标样式。
5548D0	Sexy::SexyAppBase::EnableCustomCursors(al = bool enabled, ecx = SexyAppBase* this)	eax, ecx, edx		设置是否启用自定义光标。
5548E0	Sexy::SexyAppBase::GetImage(bool commitBits, const std::string& theFileName, ecx = SexyAppBase* this)	eax = DDImage*? anImage; ecx, edx		加载 theFileName 图片文件以创建相应的 DDImage，若加载失败则返回 0。		【虚函数】[[[(SexyAppBase*)]+0]+104]
554B10	Sexy::SexyAppBase::CopyImage(esi = const Rect& theRect, ecx = Image* theImage, SexyAppBase* this)	eax = DDImage* anImage; ecx, edx		复制贴图 theImage 的 theRect 区域的图像及所有其他数据以创建新 DDImage 贴图。
554BE0	Sexy::SexyAppBase::CopyImage(ecx = Image* theImage, SexyAppBase* this)	eax = DDImage* anImage; ecx, edx		复制贴图的完整图像及所有其他数据以创建新 DDImage 贴图。
554C20	Sexy::SexyAppBase::PlaySample(int theSoundNum, ecx = SexyAppBase* this)	eax, ecx, edx		播放 theSoundNum 上位音效。		【虚函数】[[[(SexyAppBase*)]+0]+D8]
554C50	Sexy::SexyAppBase::PlaySample(int thePan, int theSoundNum, ecx = SexyAppBase* this)	eax, ecx, edx		以指定声像播放上位音效。声像 thePan 的取值为 [-100, 100] （%，即：全左至全右）范围内的整数。		【虚函数】[[[(SexyAppBase*)]+0]+D4]
554CA0	Sexy::SexyAppBase::IsMuted(ecx = SexyAppBase* this)	al = bool muted		判断当前程序是否静音。当静音请求计数大于 0 时，程序静音。		【虚函数】[[[(SexyAppBase*)]+0]+E8]
554CB0	Sexy::SexyAppBase::Mute(bool autoMute, ecx = SexyAppBase* this)	eax, ecx, edx		设置程序静音，增加 1 次静音请求计数。若指定了 autoMute，则额外增加 1 次自动静音请求计数。		【虚函数】[[[(SexyAppBase*)]+0]+F8]
554D00	Sexy::SexyAppBase::Unmute(bool autoMute, ecx = SexyAppBase* this)	eax, ecx, edx		设置程序取消静音，减少 1 次静音请求计数。若指定了 autoMute，则额外减少 1 次自动静音请求计数。		【虚函数】[[[(SexyAppBase*)]+0]+FC]
554D60	Sexy::SexyAppBase::GetMusicVolume(ecx = SexyAppBase* this)	st(0) = aMusicVolume		取得程序的音乐音量（返回 mMusicVolume 的值）。		【虚函数】[[[(SexyAppBase*)]+0]+E0]
554D70	Sexy::SexyAppBase::SetMusicVolume(double theVolume, ecx = SexyAppBase* this)	eax, ecx, edx		设置程序的音乐音量。若程序处于静音状态，则实际设置的音量值为 0。		【虚函数】[[[(SexyAppBase*)]+0]+F0]
554DB0	Sexy::SexyAppBase::GetSfxVolume(ecx = SexyAppBase* this)	st(0) = aSfxVolume		取得程序的音效音量（返回 mSfxVolume 的值）。		【虚函数】[[[(SexyAppBase*)]+0]+E4]
554DC0	Sexy::SexyAppBase::SetSfxVolume(double theVolume, ecx = SexyAppBase* this)	eax, ecx, edx		设置程序的音效音量。若程序处于静音状态，则实际设置的音量值为 0。		【虚函数】[[[(SexyAppBase*)]+0]+F4]
554E00	Sexy::SexyAppBase::GetMasterVolume(ecx = SexyAppBase* this)	st(0) = aMasterVolume		取得程序声音管理器的主音量。		【虚函数】[[[(SexyAppBase*)]+0]+DC]
554E10	Sexy::SexyAppBase::SetMasterVolume(double theMasterVolume, ecx = SexyAppBase* this)	eax, ecx, edx		设置程序声音管理器的主音量。		【虚函数】[[[(SexyAppBase*)]+0]+EC]
554E30	Sexy::SexyAppBase::AddMemoryImage(MemoryImage* theMemoryImage, ecx = SexyAppBase* this)	eax, ecx, edx		将内存贴图 theMemoryImage 加入程序的内存贴图集合中。
554EB0	Sexy::SexyAppBase::RemoveMemoryImage(MemoryImage* theMemoryImage, SexyAppBase* this)	eax, ecx, edx		将内存贴图 theMemoryImage 从程序的内存贴图集合中移出，并删除贴图的 3D 数据。
554F70	Sexy::SexyAppBase::Remove3DData(MemoryImage* theMemoryImage, eax = SexyAppBase* this)	eax, ecx, edx		删除内存贴图 theMemoryImage 的 3D 数据。
554F90	Sexy::SexyAppBase::Is3DAccelerated(eax = SexyAppBase* this)	al = 0(否) | 1(是); ecx		判断 3D 加速是否开启。
554FA0	Sexy::SexyAppBase::Is3DAccelerationSupported(eax = SexyAppBase* this)	al = 0(否) | 1(是); ecx, edx		判断当前设备是否支持 3D 加速。
554FC0	Sexy::SexyAppBase::Is3DAccelerationRecommended(eax = SexyAppBase* this)	al = 0(否) | 1(是); ecx		判断是否推荐开启 3D 加速。
554FF0	Sexy::SexyAppBase::DemoSyncRefreshRate(eax = SexyAppBase* this)	eax, ecx, edx		演示运行下同步刷新率。
555050	Sexy::SexyAppBase::Set3DAcclerated(bool reinit, bool is3D, ecx = SexyAppBase* this)	eax, ecx, edx		设置 3D 加速的开启与否。当目标值与当前值不同时，若指定了 reinit，则重新初始化 DirectDraw。
555270	Sexy::SexyAppBase::SetSharedImage;(bool* isNew, DDImage* theImage,  const std::string& theVariant, const std::string& theFileName, ; _Out_ SharedImageRef&& aSharedImageRef, ecx = SexyAppBase* this)	eax = SharedImageRef&& aSharedImageRef; ;ecx, edx		将 theImage 作为共享贴图与指定的文件名和变式名相对应地加入共享贴图映射容器中。;若容器中已存在相同文件名和变式名的共享贴图，则不作任何处理而直接返回其对应的共享贴图。;同时，将“是否为新添加的贴图”的逻辑值写入 [isNew] 地址中。		【虚函数】[[[(SexyAppBase*)]+0]+108]
555520	Sexy::SexyAppBase::GetSharedImage;(bool* isNew, const std::string& theVariant, const std::string& theFileName, ; _Out_ SharedImageRef&& aSharedImageRef, ecx = SexyAppBase* this)	eax = SharedImageRef&& aSharedImageRef; ;ecx, edx		加载 theFileName 图片文件并将其存储为共享贴图，并将其与文件名和变式名相对应地加入共享贴图映射容器中。;若容器中已存在相同文件名和变式名的共享贴图，则不作任何加载而直接返回其对应的共享贴图。;同时，将“是否为新加载的图片文件”的逻辑值写入 [isNew] 地址中。		【虚函数】[[[(SexyAppBase*)]+0]+10C]
555850	Sexy::SexyAppBase::CleanSharedImages(SexyAppBase* this)	eax, ecx, edx		清除所有不存在引用的共享贴图。
5563A0	std::list<std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator>::_Tidy;(eax = std::list<std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator>* this)	eax, ecx, edx		释放字符串映射容器迭代器的链表的每一个节点上的迭代器所占用的内存空间。
5567F0	std::map<std::pair<std::string, std::string>, Sexy::SharedImageRef>::insert;(const std::pair<std::pair<std::string, std::string>, SharedImageRef>& _Val, ; ebx = _Out_ std::pair<std::map<std::pair<std::string, std::string>, SharedImageRef>::iterator, bool>&& _Ret, ; std::map<std::pair<std::string, std::string>, Sexy::SharedImageRef>* this)	eax = &&_Ret; ecx, edx		向字符串对向共享贴图引用的映射容器中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
556C00	std::list<std::pair<std::string, int>>::push_back;(eax = const std::pair<std::string, int>& _Val, ebx = std::list<std::pair<std::string, int>>* this)	eax, edx		在字符串和整数的对组的链表容器的尾部添加一个字符串和整数的对组元素。
556C30	std::map<std::string, std::wstring>::insert;(const std::pair<std::string, std::wstring>& _Val, ; ebx = _Out_ std::pair<std::map<std::string, std::wstring>::iterator, bool>&& _Ret, ; std::map<std::string, std::wstring>* this)	eax = &&_Ret; ecx, edx		向字符串向宽字符串的映射容器中添加一个对组 _Val，若新插入的键值与原有的键值重复则插入无效。;返回一个由表示插入的键值在映射中的位置的迭代器、及表示是否插入成功的布尔逻辑值组成的对组。
5572C0	std::fstream::~basic_fstream(ecx = std::fstream* this)	eax, ecx, edx		销毁输入输出文件流。
557EB0	std::pair<std::string, std::wstring>::pair<std::string, std::wstring>;(const std::wstring& _Val2, const std::string& _Val1, std::pair<std::string, std::wstring>* this)	eax = *this; ecx, edx		从给定的字符串和宽字符串创建一个对组。需要一个大小为 0x38 的内存区域用于构造 this。
55A910	std::wstring::assign;(unsigned int _Count = -1, unsigned int _Roff, const std::wstring& _Right, ecx = std::wstring* this)	eax = std::wstring& this; ecx, edx		以 _Right 字符串的一个指定的子字符串赋值宽字符串自身，当 _Count = -1 时不限制子字符串长度。;返回对赋值后的自身的引用。
55AA00	std::wstring::assign(const unsigned int _Count, const wchar_t* const _Ptr, ecx = std::wstring* this)	eax = std::wstring& this; ecx, edx		以 _Ptr 指向的前 _Count 个宽字符赋值宽字符串自身，返回对赋值后的自身的引用。
55AC30	std::list<Sexy::Dialog*>::_Buynode()	eax = _Node* _Pnode; ecx, edx		创建一个对话指针的链表容器的节点，并初始化该节点的前、后节点指针指向其自身。
560DF0	Sexy::Ratio::operator!=(eax = const Ratio& theRatio, ecx = const Ratio* this)	al = bool _Neq; ecx, edx		比例的“!=”运算符重载：判断比例 *this 的比值是否不等于 theRatio 的比值。
560E20	Sexy::Ratio::operator>(eax = const Ratio& theRatio, edx = const Ratio* this)	al = bool _Greater; ecx, edx		比例的“>”运算符重载：判断比例 *this 的比值是否大于 theRatio 的比值。
560E60	Sexy::D3DTester::TestException::TestException(const std::string& theMsg, D3DTester::TestException* this)	eax = *this; ecx, edx		初始化创建 D3D 测试异常实例，并记录异常内容的字符串。需要一个大小为 0x28 的内存区域用于构造 this。
560ED0	Sexy::D3DTester::TestException::`scalar deleting destructor';(unsigned int flags, ecx = D3DTester::TestException* this)	eax = *this; ecx, edx		删除 D3D 测试异常，当 flags 的第 0 位置 1 时会额外释放测试异常本身占用的内存空间。		【虚函数】[[[(D3DTester::TestException*)]+0]+0]
560F20	Sexy::D3DTester::TestException::~TestException(ecx = D3DTester::TestException* this)	eax, ecx, edx		销毁 D3D 测试异常，释放异常内容的字符串。
560F50	Sexy::DDInterface::DDInterface(SexyAppBase* theApp, DDInterface* this)	eax = *this; ecx, edx		初始化创建 DDraw 接口，初始化相关数据并取得创建 DDraw 实例的相关函数。;需要一个大小为 0xD50 的内存区域用于构造 this。
561150	Sexy::DDInterface::`scalar deleting destructor'(unsigned int flags, ecx = DDInterface* this)	eax = *this; ecx, edx		删除 DDraw 接口，当 flags 的第 0 位置 1 时会额外释放接口本身占用的内存空间。		【虚函数】[[[(DDInterface*)]+0]+0]
561170	std::set<Sexy::DDImage*>::~set<Sexy::DDImage*>(eax = std::set<Sexy::DDImage*>* this)	eax, ecx, edx		销毁并释放 DDraw 贴图指针的集合容器。
561180	Sexy::DDInterface::~DDInterface(ecx = DDInterface* this)	eax, ecx, edx		销毁 DDraw 接口，释放所有使用的对象和占用的资源。
561270	Sexy::DDInterface::ResultToString(eax = int theResult, esi = _Out_ std::string&& aResultStr)	eax = std::string&& aResultStr; ecx, edx		根据结果代码 theResult 取得相应的用于向用户显示的结果描述字符串。
561330	Sexy::DDInterface::GotDXError(ebx = const char* theMsg, HResult theResult, edi = DDInterface* this)	al = bool isError; ecx, edx		根据给定的结果代码 theResult 判断是否为表示失败的结果。若是，则记录 theMsg 及错误原因。;此函数在 theResult 为失败结果代码时返回 true，在 theError 为成功结果代码时返回 false。
561400	Sexy::DDInterface::GetScreenImage(eax = DDInterface* this)	eax = DDImage* aScreenImage		取得当前屏幕的贴图（返回 mScreenImage 的值）。
561410	Sexy::DDInterface::CreateSurface;(IDirectDrawSurface** theSurface, _DDSURFACEDESC2* theDesc, ecx = DDInterface* this)	eax = HRESULT aResult; ecx, edx		根据请求描述 theDesc 创建相应的 DDraw 表面，将创建的表面的指针写入 [theSurface] 地址中。
561620	Sexy::DDInterface::ClearSurface(IDirectDrawSurface* theSurface)	eax, ecx, edx		清空 theSurface 表面上的全部像素数据。
5616B0	Sexy::DDInterface::Do3DTest(esi = DDInterface* this)	al = bool succeed; ecx, edx		进行 D3D 测试，并记录测试的结果。函数的返回值表示是否成功完成测试，与测试结果无关。
561780	Sexy::DDInterface::Init(bool IsWindowed, HWND theWindow, ecx = DDInterface* this)	eax = int aResult; ecx, edx		在 theWindow 窗口初始化 DDraw 接口，参数 IsWindowed 表示该窗口处于窗口化或全屏状态。;若初始化成功，则返回零否则，返回失败的原因的代码。
5629B0	Sexy::DDInterface::WindowResize(int theHeight, int theWidth, eax = DDInterface* this)	eax, ecx, edx		窗口大小更改为 theWidth * theHeight 时，调整显示矩形并创建若干个窗口缩放缓冲区。
562B30	Sexy::DDInterface::SetVideoOnlyDraw(bool videoOnlyDraw, ecx = DDInterface* this)	eax, ecx, edx		设置是否仅允许在使用显存时进行绘制，并进行相应的调整。
562CA0	Sexy::DDInterface::AddDDImage(DDImage* theDDImage, ecx = DDInterface* this)	eax, ecx, edx		将 theDDImage 贴图添加到自身的 DDraw 贴图集合中。
562D10	Sexy::DDInterface::RemoveDDImage(DDImage* theDDImage, ecx = DDInterface* this)	eax, ecx, edx		将 theDDImage 贴图从自身的 DDraw 贴图集合中移除。
562DC0	Sexy::DDInterface::Remove3DData(eax = MemoryImage* theImage, ecx = DDInterface* this)	eax, ecx, edx		由自身的 D3D 接口删除 theImage 内存贴图的 D3D 纹理数据。
562DD0	Sexy::DDInterface::Cleanup(esi = DDInterface* this)	eax, ecx, edx		清理 DDraw 接口中所有使用的对象和占用的资源。
562F60	Sexy::DDInterface::Redraw(ecx = const Rect* theClipRect, edx = DDInterface* this)	al = bool redrawn; ecx, edx		刷新窗口 *theClipRect 区域内的绘制，并重新绘制光标贴图。若 theClipRect 为空指针则表示重绘全屏。
5636D0	Sexy::DDInterface::RestoreOldCursorAreaFrom(IDirectDrawSurface* theSurface, esi = DDInterface* this)	eax, ecx, edx		将此前被光标贴图遮盖的区域内的图像恢复至 theSurface 表面上的当前光标位置。
5637F0	Sexy::DDInterface::DrawCursorTo(bool adjust, IDirectDrawSurface* theSurface, esi = DDInterface* this)	eax, ecx, edx		若存在光标贴图，则记录被光标贴图遮盖的区域，然后将光标绘制到 theSurface 上表面上的当前光标位置。;若指定了 adjust，则光标的坐标将转化为使用屏幕坐标，theSurface 也应相应地使用完整屏幕大小的表面。
563C30	Sexy::DDInterface::MoveCursorTo;(int theNewCursorY, int theNewCursorX, IDirectDrawSurface* theSurface, esi = DDInterface* this)	eax, ecx, edx		将光标贴图在 theSurface 表面上的位置移动至 (theNewCursorX, theNewCursorY) 处。;其中，参数的光标坐标使用屏幕坐标，theSurface 也应相应地使用完整屏幕大小的表面。
5642A0	Sexy::DDInterface::SetCursorImage(ebx = Image* theImage = 0, edi = DDInterface* this)	al = bool changed; ecx, edx		设置（或当 theImage 为 0 时表示清除）鼠标光标的贴图。;当新设置的贴图与原贴图不同（或首次设置贴图、或清除了原有贴图）时，返回 true。
5642D0	Sexy::DDInterface::SetCursorPos(edi = int theCursorY, ebx = int theCursorX, ecx = DDInterface* this)	eax, ecx, edx		设置下一帧时鼠标光标在窗口客户区内的坐标，并相应修改光标贴图在主表面上的位置。
564370	Sexy::Color::Color(ecx = Color* this)	eax = *this		创建新颜色 (0, 0, 0, 255)。需要一个大小为 0x10 的内存区域用于构造 this。
564390	Sexy::Color::Color(ecx = int theColor, eax = Color* this)	eax = *this; ecx, edx		根据给定的 ARGB 颜色创建颜色，当给定的颜色的不透明度为 0 时，创建的颜色的不透明度会被设为 255。;需要一个大小为 0x10 的内存区域用于构造 this。
5643D0	Sexy::Color::Color(int theBlue, edx = int theGreen, ecx = int theRed, eax = Color* this)	eax = *this; ecx		根据指定的 R、G、B 值创建颜色，且颜色的不透明度为 255。需要一个大小为 0x10 的内存区域用于构造 this。
5643F0	Sexy::Color::Color(int theAlpha, int theBlue, edx = int theGreen, ecx = int theRed, eax = Color* this)	eax = *this; ecx, edx		根据指定的 R、G、B、A 值创建颜色。需要一个大小为 0x10 的内存区域用于构造 this。
564410	Sexy::Color::Color(ecx = const int* theElements, eax = Color* this)	eax = *this; ecx, edx		以 theElements 数组的前三个元素分别作为 R、G、B 值创建新颜色，且新颜色的不透明度为 255。;需要一个大小为 0x10 的内存区域用于构造 this。
564430	Sexy::Color::GetRed(eax = Color* this)	eax = int aRed		取得颜色的红色值。
564440	Sexy::Color::GetGreen(eax = Color* this)	eax = int aGreen		取得颜色的绿色值。
564450	Sexy::Color::ToInt(ecx = Color* this)	eax = unsigned long aColor		将颜色数组转化为 ARGB 格式的颜色。
564470	Sexy::Color::IsWhite(eax = Color* this)	eax = 0(否) | 1(是); ecx, edx		判断颜色是否与 Color::White 相同。
5644B0	Sexy::operator!=(eax = const Color& theColor2, ecx = const Color& theColor1)	eax = 0(相等) | 1(不相等); ecx, edx		颜色的 != 运算符重载，判断两个颜色是否不相同。
5644E0	Sexy::D3DInterface::CheckDXError(edi = const char* theMsg, HResult theError)	al = bool isError; ecx, edx	0x4	根据给定的结果代码 theError 判断是否为表示失败的结果。若是，则将 theMsg 及错误原因写入注册表。;此函数在 theError 为失败结果代码时返回 true，在 theError 为成功结果代码时返回 false。
564650	Sexy::D3DInterface::D3DInterface(D3DInterface* this)	eax = *this; ecx, edx		初始化创建 D3D 接口。需要一个大小为 0x58 的内存区域用于构造 this。
564710	Sexy::D3DInterface::`scalar deleting destructor'(unsigned int flags, ecx = D3DInterface* this)	eax = *this; ecx, edx		删除 D3D 接口，当 flags 的第 0 位置 1 时会额外释放接口本身占用的内存空间。		【虚函数】[[[(D3DInterface*)]+0]+0]
564730	Sexy::D3DInterface::~D3DInterface(ecx = D3DInterface* this)	eax, ecx, edx		销毁 D3D 接口，刷新画面并清理所有使用的对象和占用的资源。
5647B0	Sexy::D3DInterface::MakeDDPixelFormat(eax = _DDPIXELFORMAT* theFormat, PixelFormt theFormatType)	eax, ecx, edx	0x4	根据像素格式类型 theFormatType 取得相应的格式信息写入 *theFormat 中。
564890	Sexy::D3DInterface::GetDDPixelFormat(eax = _DDPIXELFORMAT* theFormat)	eax = PixelFormat aFormatType; ecx, edx		根据像素格式信息 theFormat 取得相应的格式类型。
564940	Sexy::D3DInterface::PixelFormatsCallback(void* lpContext, _DDPIXELFORMAT* theFormat)	eax = 1; ecx, edx		用于从设备驱动程序中检索支持的纹理格式列表的回调函数。;根据 theFormat 取得对应的像素格式标志，将标志添加到 gSupportedPixelFormats([0x6A9588]) 中。
564960	Sexy::D3DInterface::UpdateViewport(eax = D3DInterface* this)	eax, ecx, edx		将当前使用的 D3D 设备的视口设置为整个窗口客户区的尺寸。
5649F0	Sexy::D3DInterface::EnumZBufferCallback(void* pddpfDesired, _DDPIXELFORMAT* pddpf)	eax = HRESULT aResult; ecx, edx		用于检索深度缓存使用的像素格式信息的回调函数。;当找到仅用于深度缓存的像素格式时，将其信息复制到 pddpfDesired 指向的内存区域，并返回 0 以停止枚举。
564A20	Sexy::D3DInterface::InitD3D(esi = D3DInterface* this)	al = bool initialized; ecx, edx		初始化 D3D 接口。创建 D3D 实例，然后创建并初始化绘制使用的 D3D 设备，同时设定纹理相关的数据信息。
564C30	Sexy::D3DInterface::InitFromDDInterface(ebx = DDInterface* theInterface, eax = D3DInterface* this)	al = bool initialized; ecx, edx		从 DDraw 接口取得窗口相关的信息并创建 DDraw 表面，并以此对 D3D 接口进行初始化。
564CA0	Sexy::D3DInterface::PreDraw(esi = D3DInterface* this)	al = bool succeed; ecx, edx		进行绘制前的准备工作：开启渲染场景，并设定渲染相关的参数。程序窗口处于最小化时，直接返回 false。
564E00	CreateTextureSurface(PixelFormat theFormat, int theHeight, int theWidth, ;                     ecx = IDirectDraw7* theDraw, IDirect3DDevice7* theDevice)	eax = IDirectDrawSurface7*? aSurface; ;ecx, edx	0x10	清除 theDevice 设备当前使用的纹理，并由 theDraw 创建一个指定大小和像素格式的绘制表面。
564F20	CopyImageToTexture8888(bool rightPad, eax = int theHeight, int theWidth, edx = int offy, int offx, ;                       edi = MemoryImage* theImage, unsigned long theDestPitch, void* theDest)	eax, ecx, edx	0x14	将 theImage 贴图从 (offx, offy) 位置开始 theWidth 宽度 theHeight 高度的部分，;按照 A8R8G8B8 的像素格式复制到 theDest 指向的目标纹理，其中 theDestPitch 表示目标纹理的字节宽度。;若指定了 rightPad，则额外复制 theImage 区域右边缘的一列像素置于 theDest 区域右侧进行填充。
565010	CopyTexture8888ToImage(int theHeight, int theWidth, int offy, int offx, ebx = MemoryImage* theImage, ;                       unsigned long theDestPitch, eax = void* theDest)	eax, ecx, edx	0x14	将 A8R8G8B8 格式的纹理的像素值复制到 theImage 贴图上的 (offx, offy, theWidth, theHeight) 部分。;其中 theDestPitch 表示源纹理的字节宽度（即一行像素的总字节数）。
565080	CopyImageToTexture4444(bool rightPad, eax = int theHeight, int theWidth, ecx = int offy, edx = int offx, ;                       MemoryImage* theImage, unsigned long theDestPitch, void* theDest)	eax, ecx, edx	0x14	将 theImage 贴图从 (offx, offy) 位置开始 theWidth 宽度 theHeight 高度的部分，;按照 A4R4G4B4 的像素格式复制到 theDest 指向的目标纹理，其中 theDestPitch 表示目标纹理的字节宽度。;若指定了 rightPad，则额外复制 theImage 区域右边缘的一列像素置于 theDest 区域右侧进行填充。
565200	CopyTexture4444ToImage(int theHeight, int theWidth, int offy, int offx, MemoryImage* theImage, ;                       unsigned long theDestPitch, eax = void* theDest)	eax, ecx, edx	0x18	将 A4R4G4B4 格式的纹理的像素值复制到 theImage 贴图上的 (offx, offy, theWidth, theHeight) 部分。;其中 theDestPitch 表示源纹理的字节宽度（即一行像素的总字节数）。
5652B0	CopyImageToTexture565(bool rightPad, eax = int theHeight, int theWidth, ecx = int offy, edx = int offx, ;                      MemoryImage* theImage, unsigned long theDestPitch, void* theDest)	eax, ecx, edx	0x14	将 theImage 贴图从 (offx, offy) 位置开始 theWidth 宽度 theHeight 高度的部分，;按照 R5G6B5 的像素格式复制到 theDest 指向的目标纹理，其中 theDestPitch 表示目标纹理的字节宽度。;若指定了 rightPad，则额外复制 theImage 区域右边缘的一列像素置于 theDest 区域右侧进行填充。
565410	CopyTexture565ToImage(int theHeight, int theWidth, int offy, int offx, MemoryImage* theImage, ;                      unsigned long theDestPitch, eax = void* theDest)	eax, ecx, edx	0x18	将 R5G6B5 格式的纹理的像素值复制到 theImage 贴图上的 (offx, offy, theWidth, theHeight) 部分。;其中 theDestPitch 表示源纹理的字节宽度（即一行像素的总字节数）。
5654D0	CopyImageToTexturePalette8(bool rightPad, eax = int theHeight, edi = int theWidth, int offy, int offx, ;                           edx = MemoryImage* theImage, unsigned long theDestPitch, void* theDest)	eax, ecx, edx	0x14	将 theImage 贴图从 (offx, offy) 位置开始 theWidth 宽度 theHeight 高度的部分，;按照 8 位调色板的像素格式复制到 theDest 指向的目标纹理，其中 theDestPitch 表示目标纹理的字节宽度。;若指定了 rightPad，则额外复制 theImage 区域右边缘的一列像素置于 theDest 区域右侧进行填充。
565540	CopyTexturePalette8ToImage(int theHeight, int theWidth, int offy, int offx, MemoryImage* theImage, ;                           unsigned long theDestPitch, void* theDest)	eax, ecx, edx	0x1C	将 8 位调色板格式的纹理的像素值复制到 theImage 贴图上的 (offx, offy, theWidth, theHeight) 部分。;其中 theDestPitch 表示源纹理的字节宽度（即一行像素的总字节数）。
565620	CopyImageToTexture(PixelFormat theFormat, int texHeight, int texWidth, ebx = int offy, int offx, ;                   MemoryImage* theImage, IDirectDrawSurface7* theTexture)	eax, ecx, edx	0x18	将 theImage 贴图从 (offx, offy) 位置开始的部分复制到 theFormat 像素格式的纹理 theTexture 中。;其中 texWidth 和 texHeight 表示目标纹理图像的像素宽度和像素高度。;如果目标纹理的宽度或高度大于需要复制的区域，则额外复制 theImage 区域边缘的像素进行边界填充。
5657E0	GetClosestPowerOf2Above(ecx = int theNum)	eax = int aPower2; ecx		计算不小于 theNum 的整数中最小的 2 的非负整数次幂 aPower2。
565800	IsPowerOf2(eax = int theNum)	al = bool isPow2; ecx, edx		判断 theNum 是否为 2 的非负整数次幂。
565820	GetBestTextureDimensions(unsigned long theImageFlags, bool isEdge, int& theHeight, int& theWidth)	eax, ecx, edx	0x10	计算纹理贴图最佳的切片尺寸。其中，参数 isEdge 表示需要计算尺寸的是否是位于边缘的切片;参数 theWidth 和 theHeight 作为入参时表示原始的纹理尺寸，作为出参时表示计算结果的最佳切片尺寸;参数 theImageFlags 为原贴图的 D3D 标志。最终计算得到的实际结果会向上取至 2 的整数次幂。
565970	Sexy::TextureData::TextureData(eax = TextureData* this)	eax = *this; ecx		初始化创建纹理数据。需要一个大小为 0x44 的内存区域用于构造 this。
5659B0	Sexy::TextureData::~TextureData(TextureData* this)	eax = *this; ecx, edx		销毁纹理数据，释放所有纹理切片及使用的调色板。
565A10	Sexy::TextureData::ReleaseTextures(eax = TextureData* this)	eax, ecx, edx		释放纹理数据中的所有纹理切片及使用的调色板。
565AA0	Sexy::TextureData::CreateTextureDimensions(ecx = MemoryImage* theImage, eax = TextureData* this)	eax, ecx, edx		进行纹理切片的前置步骤，计算各个切片的最佳大小及切片的总数量等前置数据，并依此初始化相关数据。
565D60	Sexy::TextureData::CreateTextures(ecx = IDirectDraw7* theDraw, IDirect3DDevice7* theDevice, ;                                  edx = MemoryImage* theImage, edi = TextureData* this)	eax, ecx, edx		删除内存贴图 theImage 的软件存储数据，将该贴图以合适的尺寸进行切片并存储为 DDraw 绘制表面的形式。
566080	Sexy::TextureData::CheckCreateTextures(IDirectDraw7* theDraw, IDirect3DDevice7* theDevice, ;                                       edx = MemoryImage* theImage, eax = TextureData* this)	eax, ecx, edx		检查是否需要对 theImage 重新进行切片，若需要则如此做。
5660C0	Sexy::TextureData::GetTexture(float& v2, float& u2, float& v1, float& u1, int& height, int& width, ;                              eax = int y, int x, ecx = TextureData* this)	eax = IDirectDrawSurface7* aSurface; ;ecx, edx		在进行纹理切片前的原贴图上指定一个由矩形 (x, y, width, height) 构成的区域，;从纹理数据中取得该位置对应的切片，将该切片从指定位置开始的实际区域的宽高分别赋值给 width 和 height，;并将实际区域左、上、右、下边缘位于切片中的位置比例分别赋值给 u1、v1、u2、v2。返回该切片的绘制表面。
5661B0	SetLinearFilter(bl = bool linear, esi = IDirect3DDevice7* theDevice)	eax, ecx, edx		设置 theDevice 设备在渲染时是否启用线性纹理过滤。
566230	Sexy::TextureData::Blt(edx = const Color& theColor, ecx = const Rect& theSrcRect, float theY, float theX, ;                       IDirect3DDevice7* theDevice, TextureData* this)	eax, ecx, edx		将纹理数据中 theSrcRect 内的图像以 theColor 颜色绘制到 theDevice 设备上的 (theX, theY) 位置处。
5664C0	VertexList::~VertexList(ecx = VertexList* this)	eax, ecx, edx		销毁顶点列表，释放其中的顶点数据占用的内存空间。
5664E0	VertexList::reserve(eax = int theCapacity, esi = VertexList* this)	eax, ecx, edx		确保顶点列表至少有 theCapacity 的容量。若容量不足，则申请新内存空间，并拷贝原有数据。
566540	VertexList::push_back(const _D3DTLVERTEX* theVert, ebx = VertexList* this)	eax, ecx, edx		将顶点 *theVert 的数据添加到顶点列表的末尾。
566580	VertexList::operator=(edi = VertexList* theList, eax = VertexList* this)	eax, ecx, edx		顶点列表的赋值运算符重载，复制顶点列表 theList 的数据给自身。
5665C0	GetCoord(ecx = int theCoord, eax = const _D3DTLVERTEX* theVert)	st(0) = aCoord		取得顶点 theVert 中第 theCoord 维度的坐标，其中参数 theCoord 的有效取值范围为 { 0, 1, 2, 3, 4 }，;分别对应顶点的屏幕 x 坐标、屏幕 y 坐标、屏幕 z 坐标、纹理 u 坐标和纹理 z 坐标。
566600	Interpolate;(float t, edx = const _D3DTLVERTEX& v2, eax = const _D3DTLVERTEX& v1, _Out_ _D3DTLVERTEX&& aVertex)	eax = _D3DTLVERTEX&& aVertex; ecx, edx	0x8	计算顶点 v1 与 v2 之间 t 时刻的线性插值，其中 t 的有效取值范围为 [0.0, 1.0]。;线性插值：aVert = v1 + t * (v2 - v1)。
5667D0	DoPolyScreenClip(VertexList* theClipped, _D3DPRIMITIVETYPE thePrimitiveType, ;                 ecx = const VertexList& theList, edx = const Rect* theClipRect)	eax, ecx, edx	0x8	为即将进行的 thePrimitiveType 类型的图元绘制进行顶点的屏幕坐标裁剪，将裁剪结果存入 *theClipped 中。;此处参数 thePrimitiveType 的有效取值范围为 { 4(D3DPT_TRIANGLELIST), 6(D3DPT_TRIANGLEFAN) }。
566AA0	DrawPolyClipped(const VertexList& theList, edx = const Rect* theClipRect, esi = IDirect3DDevice7* theDevice)	eax, ecx, edx	0x4	将由 theList 列表指定的多边形裁剪至 *theClipRect 的范围内并绘制在 theDevice 设备上。
566B70	DoPolyTextureClip(edi = VertexList& theList)	eax, ecx, edx		将 theList 列表中所有顶点的纹理坐标裁剪至 [0.0, 1.0) 范围内。
566C50	Sexy::TextureData::BltTransformed;(bool center, float theY, float theX, const Rect* theClipRect = 0, ecx = const Color& theColor, ; const Rect& theSrcRect, const SexyMatrix3& theTrans, ebx = IDirect3DDevice7* theDevice, TextureData* this)	eax, ecx, edx		在 theDevice 设备上的 (theX, theY) 位置绘制纹理数据中 theSrcRect 区域经 theTrans 变换后的图像。;参数 theColor 指定着色参数 theClipRect 指向绘制时的裁剪矩形，若为空指针则表示不进行裁剪。;当参数 center 为真时，变换的原点改为图像的中心，且目标位置改为将 (theX, theY) 对准图像的中心。
5671F0	Sexy::TextureData::BltTriangles;(const Rect* theClipRect, float ty, float tx, unsigned long theColor, int theNumTriangles, ; const TriVertex theVertices[][3], IDirect3DDevice7* theDevice, ebx = TextureData* this)	eax, ecx, edx		以纹理数据中的图像，在 theDevice 设备上的 (tx, ty) 位置处填充 theNumTriangles 个三角形区域。
567CF0	Sexy::D3DInterface::CreateImageTexture(MemoryImage* theImage, D3DInterface* this)	al = bool created; ecx, edx		创建 theImage 内存贴图的 D3D 纹理数据。若该贴图需要清除像素，则同时清除其像素数据。
567DE0	Sexy::D3DInterface::RecoverBits(MemoryImage* theImage)	al = bool recovered; ecx, edx		从 theImage 内存贴图贴图的 D3D 纹理数据中恢复贴图的像素数据。
567FE0	Sexy::D3DInterface::RemoveMemoryImage(MemoryImage* theImage, D3DInterface* this)	eax, ecx, edx		删除 theImage 内存贴图的纹理数据，并将其从自身用于记录存在纹理数据的内存贴图的集合中移除。
568080	Sexy::D3DInterface::Cleanup(D3DInterface* this)	eax, ecx, edx		刷新画面，清理所有内存贴图的纹理数据，并释放 D3D 绘制相关的所有对象。
5681A0	Sexy::D3DInterface::SetupDrawMode(int theDrawMode, eax = D3DInterface* this)	eax, ecx, edx		根据绘制模式 theDrawMode 设定当前的各项渲染参数。
5681F0	Sexy::D3DInterface::Blt(bool linearFilter, int theDrawMode, const Color& theColor, const Rect& theSrcRect, ;                        float theY, float theX, eax = Image* theImage, edi = D3DInterface* this)	eax, ecx, edx		在窗口上的 (theX, theY) 位置绘制 theImage 贴图的 theSrcRect 部分。
568290	Sexy::D3DInterface::BltMirror(int theDrawMode, const Color& theColor, edi = const Rect& theSrcRect, ;                              float theY, float theX, Image* theImage, D3DInterface* this)	eax, ecx, edx		在窗口上的 (theX, theY) 位置镜像地绘制 theImage 贴图的 theSrcRect 部分。
568330	Sexy::D3DInterface::BltClipF;(int theDrawMode, const Color& theColor, const Rect* theClipRect, const Rect& theSrcRect, ; float theY, float theX, Image* theImage, D3DInterface* this)	eax, ecx, edx		在窗口上的 (theX, theY) 位置绘制 theImage 贴图的 theSrcRect 部分。;参数 theColor 指定着色，参数 theClipRect 指向绘制时的裁剪矩形，若为空指针则表示不进行裁剪。
5683A0	Sexy::D3DInterface::StretchBlt;(bool mirror, bool fastStretch, int theDrawMode, const Color& theColor, const Rect* theClipRect, ; ebx = const Rect& theSrcRect, edi = const Rect& theDestRect, Image* theImage, D3DInterface* this)	eax, ecx, edx		拉伸 theImage 贴图中的 theSrcRect 部分以填充窗口上的 theDestRect 区域。;参数 theColor 指定着色参数 theClipRect 指向绘制时的裁剪矩形，若为空指针则表示不进行裁剪。;当指定 mirror 时，改为镜像地进行绘制当指定 fastStretch 时，快速拉伸不进行线性混合。
568470	Sexy::D3DInterface::BltRotated;(const Rect& theSrcRect, float theRotCenterY, float theRotCenterX, double theRot, int theDrawMode, ; const Color& theColor, const Rect* theClipRect, float theY, float theX, Image* theImage, D3DInterface* this)	eax, ecx, edx		在窗口上的 (theX, theY) 位置绘制贴图的 theSrcRect 部分旋转 theRot 角度后的图像。;其中参数 theRotCenterX 和 theRotCenterY 指定旋转的中心坐标（使用窗口内的绝对坐标）。;参数 theColor 指定着色参数 theClipRect 指向绘制时的裁剪矩形，若为空指针则表示不进行裁剪。
568520	Sexy::D3DInterface::BltTransformed;(bool center, float theY, float theX, bool linearFilter, const SexyMatrix3& theTransform, ; const Rect& theSrcRect, int theDrawMode, const Color& theColor, const Rect* theClipRect, ; eax = Image* theImage, D3DInterface* this)	eax, ecx, edx		在窗口上的 (theX, theY) 位置 theImage 贴图中 theSrcRect 区域经 theTrans 变换后的图像。;参数 theColor 指定着色参数 theClipRect 指向绘制时的裁剪矩形，若为空指针则表示不进行裁剪。;当参数 center 为真时，变换的原点改为图像的中心，且目标位置改为将 (theX, theY) 对准图像的中心。
568730	Sexy::D3DInterface::DrawLine(int theDrawMode, ebx = const Color& theColor, double theEndY, double theEndX, ;                             double theStartY, double theStartX, ecx = D3DInterface* this)	eax, ecx, edx		在窗口上以 theColor 颜色绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。
568960	Sexy::D3DInterface::FillRect;(int theDrawMode, eax = const Color& theColor, ecx = const Rect& theRect, edx = D3DInterface* this)	eax, ecx, edx		以 theColor 颜色和 theDrawMode 模式填充窗口上的 theRect 矩形区域。
568BE0	Sexy::D3DInterface::FillPoly;(int ty, int tx, int theDrawMode, ecx = const Color& theColor, const Rect* theClipRect, ; int theNumVertices, const Point theVertices[], D3DInterface* this)	eax, ecx, edx		在窗口上的 (tx, ty) 位置以 theColor 颜色和 theDrawMode 模式填充一个多边形。;参数 theVertices 依次指定多边形的每个顶点的坐标，参数 theNumVertices 指定多边形顶点的个数。;参数 theClipRect 指向绘制时的裁剪矩形，若为空指针则表示不进行裁剪。
568E30	Sexy::D3DInterface::DrawTrianglesTex;(const Rect* theClipRect, bool blend, float ty, float tx, Image* theTexture, int theDrawMode, ; eax = const Color& theColor, int theNumTriangles, const TriVertex theVertices[][3], D3DInterface* this)	eax, ecx, edx		以 theTexture 为纹理，在窗口上的 (tx, ty) 位置处填充 theNumTriangles 个三角形区域。;参数 theColor 指定着色参数 theClipRect 指向绘制时的裁剪矩形，若为空指针则表示不进行裁剪;参数 theDrawMode 指定绘制模式参数 blend 指定是否进行线性混合。
568EC0	Sexy::D3DInterface::Flush(esi = D3DInterface* this)	eax, ecx, edx		如果当前正在渲染中，则关闭渲染场景以结束渲染和刷新画面。
568EF0	Sexy::D3DTestImage::D3DTestImage(eax = D3DTestImage* this)	eax = *this; ecx		初始化创建 D3D 测试贴图。需要一个大小为 0x10 的内存区域用于构造 this。
568F10	Sexy::D3DTestImage::`scalar deleting destructor'(unsigned int flags, ecx = D3DTestImage* this)	eax = *this; ecx, edx		删除 D3D 测试贴图，当 flags 的第 0 位置 1 时会额外释放测试贴图本身占用的内存空间。		【虚函数】[[[(D3DTestImage*)]+0]+0]
568F30	Sexy::D3DTestImage::D3DTestImage(esi = D3DTestImage* this)	eax = *this; ecx		创建大小为 64×64 （单位：像素）的 D3D 测试贴图。需要一个大小为 0x10 的内存区域用于构造 this。
568F60	Sexy::D3DTestImage::~D3DTestImage(ecx = D3DTestImage* this)	eax, ecx, edx		销毁 D3D 测试贴图，清除其像素数据。
568F70	Sexy::D3DTestImage::Create(int theHeight, edi = int theWidth, eax = D3DTestImage* this)	eax, ecx, edx		将测试贴图重置为指定的大小，贴图原有的像素数据将全部失效。
568FC0	Sexy::D3DTestImage::FreeImage(esi = D3DTestImage* this)	eax, ecx, edx		清除测试贴图的像素数据，释放其像素占用的内存空间，并将其宽度和高度均重置为 0。
568FE0	Sexy::D3DTestImage::FillRect;(unsigned long theColor, ecx = int theHeight, int theWidth, edx = int x, esi = D3DTestImage* this)	eax, ecx, edx		在测试贴图上以 theColor 颜色填充一个 (x, 0, theWidth, theHeight) 的矩形。
569020	Sexy::D3DTestImage::MakeVerticalBands(eax = D3DTestImage* this)	eax, ecx, edx		将测试贴图制成黑白相间的纵向条纹贴图，每条宽度为 1 像素。
569060	Sexy::D3DTestImage::CopyToTexture8888;(int offy, int offx, IDirectDrawSurface7* theTexture, ebx = D3DTestImage* this)	eax, ecx, edx		将测试贴图上 (offx, offy) 处 64×64 （单位：像素）的数据复制到 A8R8G8B8 格式的纹理 theTexture 上。;如果测试贴图上该位置处的剩余宽度或高度不足 64 像素，则超出的部分以黑色填充。
569180	Sexy::D3DTestImage::CopyToTexture4444;(int offy, int offx, IDirectDrawSurface7* theTexture, D3DTestImage* this)	eax, ecx, edx		将测试贴图上 (offx, offy) 处 64×64 （单位：像素）的数据复制到 A4R4G4B4 格式的纹理 theTexture 上。;如果测试贴图上该位置处的剩余宽度或高度不足 64 像素，则超出的部分以黑色填充。
5692F0	Sexy::D3DTestImage::DrawPieceToDevice;(unsigned long theColor, eax = int offy, ecx = int offx, float y, float x, IDirectDrawSurface7* theTexture, ; esi = IDirect3DDevice7* theDevice, edx = D3DTestImage* this)	eax, ecx, edx		将测试贴图上 (offx, offy) 处 64×64 （单位：像素）的数据复制到 theTexture 纹理上，;并将 theTexture 纹理以 theColor 颜色绘制在 theDevice 上的 (x, y) 位置处。
569490	Sexy::D3DTestImage::DrawToDevice(unsigned long theColor, int y, int x, IDirectDrawSurface7* theTexture, ;                                 IDirect3DDevice7* theDevice, D3DTestImage* this)	eax, ecx, edx		将测试贴图以 theColor 颜色绘制在 theDevice 上的 (x, y) 位置处。;绘制时，将测试贴图分成若干个 64×64 （单位：像素）的部分，依次复制到 theTexture 纹理上进行绘制。
569530	Sexy::D3DTestImage::ColorDistance(ecx = unsigned long c2, eax = unsigned long c1)	eax = int aDistance; ecx, edx		取得两个 R8G8B8 格式的颜色 c1 和 c2 在 RGB 的三维颜色空间中的距离的平方值。
569580	Sexy::D3DTestImage::IsUniformColor;(ebx = int& theNumMistakes, unsigned long theColor, const D3DTestImage* this)	al = bool isUniform; ecx, edx		判断测试贴图 (0, 0, 10, 10) 内的部分是否为纯色的近似 theColor 颜色。如果不是纯色，则返回 false。;同时将“与 theColor 误差值（即距离平方）大于 768 的像素的个数”赋值给 theNumMistakes。
569,600	Sexy::D3DTestImage::CheckUniformBands(eax = D3DTestImage* this)	eax = int aNumMistakes; ecx, edx		取得测试贴图 (0, 0, 62, 62) 内的部分与黑白相间的纵向条纹的误差大于 768 的像素的个数。
569,670	D3DTestHighBit(edx = unsigned long theMask)	eax = int aBitIndex; ecx		取得 theMask 的最高有效二进制位（即 n 位二进制数的第 n-1 位）的序数。
569,690	Sexy::D3DTester::D3DTester(edx = D3DTester* this)	eax = *this; ecx, edx		初始化创建 D3D 测试器。需要一个大小为 0xC0 的内存区域用于构造 this。
569,730	Sexy::D3DTester::`scalar deleting destructor'(unsigned int flags, ecx = D3DTester* this)	eax = *this; ecx, edx		删除 D3D 测试器，当 flags 的第 0 位置 1 时会额外释放测试器本身占用的内存空间。		【虚函数】[[[(D3DTester*)]+0]+0]
569,750	Sexy::D3DTester::~D3DTester(ecx = D3DTester* this)	eax, ecx, edx		销毁 D3D 测试器，清理所有测试时使用的对象和占用的资源。
569,840	Sexy::D3DTester::CheckRegistry(edi = D3DTester* this)	al = bool is3D; ecx, edx		尝试从注册表中读取此前已写入的 D3D 测试相关数据，并依此判断此前是否已完成过 D3D 测试。;如果未读取到全部需要的数据（即未进行过 D3D 测试），或此前测试结果为失败，则返回 false。
569AB0	Sexy::D3DTester::WriteToRegistry(esi = D3DTester* this)	eax, ecx, edx		将此次 D3D 测试的结果写入注册表。
569BA0	Sexy::D3DTester::FileContains(const char* theString, esi = FILE* theFile)	al = bool found; ecx, edx		判断文件 theFile 中从当前读取位置往后是否存在与 theString 相同的字符串。不允许跨行，不区分大小写。
569D10	Sexy::D3DTester::IsSupportedCard(edi = const char* theDisplayDesc, D3DTester* this)	al = bool isSupportedCard; ecx, edx		根据显卡的描述符 theDisplayDesc 及其驱动程序的年份，判断（推测）是否为支持 D3D 的显卡类型。
569DD0	Sexy::D3DTester::Init(ecx = D3DTester* this)	al = bool needDoTest; ecx, edx		进行 D3D 测试前的准备工作（获取显卡信息等需要的数据、创建测试时需要使用的对象等）。;若检测到此前成功的测试结果，或在准备过程中发生异常，则返回 false 表示无需实际进行测试。
56A770	Sexy::D3DTester::PixelFormatsCallback(void* lpContext, _DDPIXELFORMAT* theFormat)	eax = 1; ecx, edx		用于从设备驱动程序中检索支持的纹理格式列表的回调函数。;根据 theFormat 取得对应的像素格式标志，将标志添加到 *((unsigned long*)lpContext) 中。
56A790	Sexy::D3DTester::Cleanup(esi = D3DTester* this)	eax, ecx, edx		清理所有在 D3D 测试的过程中使用的对象和占用的资源。
56A820	Sexy::D3DTester::Fail(eax = const std::string& theStr, ecx = D3DTester* this)	al = 0; ecx, edx		D3D 测试失败，记录失败的内容字符串。
56A830	Sexy::D3DTester::Warn(eax = const std::string& theStr, ecx = D3DTester* this)	al = 1; ecx, edx		D3D 测试产生警告，记录警告的内容字符串。
56A850	Sexy::D3DTester::CheckDXError(ecx = const char* theMsg, edi = HResult theResult)	eax, ecx, edx		根据给定的结果代码 theResult 判断是否为表示失败的结果。若是，抛出相应的 D3D 测试异常。
56A950	Sexy::D3DTester::TestException::TestException;(const D3DTester::TestException& _Other, ecx = D3DTester::TestException* this)	eax = *this; ecx, edx		复制 _Other 的数据以创建新 D3D 测试异常实例。需要一个大小为 0x28 的内存区域用于构造 this。
56A9D0	Sexy::D3DTester::CopyPrimaryToTestImage(ecx = D3DTester* this)	eax, ecx, edx		将当前主表面（即显示器的当前可见屏幕）上的图像按照合适的方式转化为 A8R8G8B8 的像素格式，;并复制到 D3D 测试器正在使用的 D3D 测试贴图上。若主表面使用的是不支持的像素格式，则抛出测试异常。
56AB30	Sexy::D3DTester::TestAlphaBlend(D3DTester* this)	al = bool supported; ecx, edx		测试显卡是否支持不透明度混合。若失败或产生异常，则返回 false若成功或产生警告，则返回 true。;不透明度混合：最终颜色 = 新颜色不透明度 * 新颜色 + (1 - 新颜色不透明度) * 旧有颜色。
56ADC0	Sexy::D3DTester::TestAdditiveBlend(D3DTester* this)	al = bool supported; ecx, edx		测试显卡是否支持叠加混合。若失败或产生异常，则返回 false若成功或产生警告，则返回 true。;叠加混合：最终颜色 = 新颜色 + 旧有颜色。
56B050	Sexy::D3DTester::TestAlphaAddBlend(D3DTester* this)	al = bool supported; ecx, edx		测试显卡是否支持带不透明度的叠加混合。若失败或产生异常，则返回 false若成功或产生警告，则返回 true。;带不透明度的叠加混合：最终颜色 = 新颜色不透明度 * 新颜色 + 旧有颜色。
56B2E0	Sexy::D3DTester::TestAlphaModulate(D3DTester* this)	al = bool supported; ecx, edx		测试显卡是否支持不透明度调制。若失败或产生异常，则返回 false若成功或产生警告，则返回 true。;不透明度调制：实际绘制颜色 = 纹理固有颜色 * 顶点颜色。
56B590	Sexy::D3DTester::TestClipProblem(D3DTester* this)	al = bool supported; ecx, edx		测试显卡是否支持裁剪。若失败或产生异常，则返回 false若成功或产生警告，则返回 true。
56B780	Sexy::D3DTester::DoTest(esi = D3DTester* this)	al = bool supported; ecx, edx		依次进行五项 D3D 功能的测试，当前仅当这五项测试均通过时，返回 true。
56B7C0	Sexy::D3DTester::SetVidMemoryConstraints;(edx = unsigned long theRecommended, ecx = unsigned long theMin, eax = D3DTester* this)	eax, ecx, edx		设置程序需要的显存大小的最小值和推荐值。当实际显存小于(最小值/推荐值)时，会产生(失败/警告)。
56B7D0	Sexy::D3DTester::TestD3D(eax = D3DTester* this)	eax, ecx, edx		进行 D3D 测试的流程，并记录测试的结果。
56B890	Sexy::DDImage::DDImage(edi = DDInterface* theDDInterface, DDImage* this)	eax = *this; ecx, edx		以 theDDInterface 为绘图接口初始化创建 DDImage。需要一个大小为 0xEC 的内存区域用于构造 this。
56B8F0	Sexy::DDImage::`scalar deleting destructor'(unsigned int flags, ecx = DDImage* this)	eax = *this; ecx, edx		删除 Sexy::DDImage 贴图，当 flags 的第 0 位置 1 时会额外释放贴图本身占用的内存空间。		【虚函数】[[[(DDImage*)]+0]+0]
56B910	Sexy::DDImage::DDImage(DDImage* this)	eax = *this; ecx, edx		以全局 gSexyAppBase 的 DDraw 接口初始化创建 DDImage。需要一个大小为 0xEC 的内存区域用于构造 this。
56B980	Sexy::DDImage::~DDImage(ecx = DDImage* this)	eax, ecx, edx		销毁 Sexy::DDImage 贴图，释放绘制表面并将自身从绘制接口的贴图集合中移除。
56B9F0	Sexy::DDImage::Init(esi = DDImage* this)	eax, ecx, edx		初始化 DDraw 贴图，并将自身加入绘制接口的贴图集合中。
56BA20	Sexy::DDImage::Check3D(eax = Image* theImage)	al = bool is3d; ecx, edx		检查贴图是否为 3D。函数将贴图动态转换为 DDImage 并调用56BA50的函数进行判断，转换失败则返回“否”。
56BA50	Sexy::DDImage::Check3D(ecx = DDImage* theImage)	al = bool is3d; ecx		检查贴图是否为 3D。当且仅当贴图的绘制接口为 3D 且贴图的绘制表面与接口的绘制表面一致时，返回“是”。
56BA70	Sexy::DDImage::LockSurface(ecx = DDImage* this)	al = bool succeed; ecx, edx		锁定贴图表面的完整区域以进行绘制等操作。当贴图为 3D 或锁定失败时，返回 false。		【虚函数】[[[(DDImage*)]+0]+BC]
56BAD0	Sexy::DDImage::UnlockSurface(ecx = DDImage* this)	al = bool succeed; ecx, edx		绘制等操作结束后，解锁贴图被锁定的表面。当贴图为 3D 时，返回 false。		【虚函数】[[[(DDImage*)]+0]+C0]
56BB00	Sexy::DDImage::SetSurface(IDirectDrawSurface* theSurface, ecx = DDImage* this)	eax, ecx, edx		设置 DDImage 贴图的表面，获取表面的描述信息，并依据描述信息设置贴图的像素宽度和像素高度。		【虚函数】[[[(DDImage*)]+0]+C4]
56BB70	Sexy::DDImage::GenerateDDSurface(esi = DDImage* this)	al = bool succeed; ecx, edx		生成贴图的显示表面，并将贴图的像素数据复制到该表面上。
56C480	Sexy::DDImage::DeleteDDSurface(esi = DDImage* this)	eax, ecx, edx		清除贴图表面，获取贴图原始图像的像素集（若需要），然后释放表面。
56C4C0	Sexy::DDImage::ReInit(ecx = DDImage* this)	eax, ecx, edx		重新初始化贴图，并生成贴图的显示表面（若需要）。		【虚函数】[[[(DDImage*)]+0]+60]
56C4E0	Sexy::DDImage::PurgeBits(ecx = DDImage* this)	eax, ecx, edx		若未开启 3D 加速，则生成显示表面并清除像素和颜色表否则，取得像素集并删除显示表面。		【虚函数】[[[(DDImage*)]+0]+50]
56C560	Sexy::DDImage::DeleteAllNonSurfaceData(esi = DDImage* this)	eax, ecx, edx		删除贴图除显示表面外的所有数据。
56C5B0	Sexy::DDImage::DeleteNativeData(ecx = DDImage* this)	eax, ecx, edx		删除贴图的本机显示数据，并清除贴图表面。		【虚函数】[[[(DDImage*)]+0]+6C]
56C5D0	Sexy::DDImage::DeleteExtraBuffers(ecx = DDImage* this)	eax, ecx, edx		删除贴图的软件和硬件缓冲区，并清除贴图表面。		【虚函数】[[[(DDImage*)]+0]+5C]
56C5F0	Sexy::DDImage::SetVideoMemory(bool wantVideoMemory, ecx = DDImage* this)	eax, ecx, edx		设置贴图是否使用显存。当目标值与当前值不同时，获取贴图像素集并删除显示表面。		【虚函数】[[[(DDImage*)]+0]+8C]
56C610	Sexy::DDImage::RehupFirstPixelTrans(ecx = DDImage* this)	eax, ecx, edx		计算并设置贴图显示表面的颜色键值。		【虚函数】[[[(DDImage*)]+0]+90]
56C720	Sexy::DDImage::GetSurface(eax = DDImage* this)	eax = IDirectDrawSurface* aSurface; ecx,edx		获取贴图的显示表面，若不存在则立即生成。
56C740	Sexy::DDImage::PolyFill3D;(bool convex, int ty, int tx, int theDrawMode, const Color& theColor, const Rect* theClipRect, ; int theNumVertices, const Point theVertices[], ecx = DDImage* this)	al = bool is3d; ecx, edx		由硬件绘制填充一个由 theNumVertices 个点依次连接而成的多边形，其中 convex 指定了多边形的凹凸性。;由 theVertices 指定的多边形顶点坐标使用以 (tx, ty) 位置为参考的相对坐标。;返回是否成功绘制的逻辑值，若未启用硬件绘制或贴图不可使用硬件绘制，则直接返回 0、		【虚函数】[[[(DDImage*)]+0]+4]
56C790	Sexy::DDImage::FillRect(int theDrawMode, const Color& theColor, const Rect& theRect, ecx = DDImage* this)	eax, ecx, edx		以指定的颜色和绘制模式填充一个矩形。		【虚函数】[[[(DDImage*)]+0]+8]
56C850	Sexy::DDImage::NormalDrawLine(const Color& theColor, double theEndY, double theEndX, ;                              double theStartY, double theStartX, ecx = DDImage* this)	eax, ecx, edx		以正常模式绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(DDImage*)]+0]+A4]
56DA40	Sexy::DDImage::AdditiveDrawLine(const Color& theColor, double theEndY, double theEndX, ;                                double theStartY, double theStartX, ecx = DDImage* this)	eax, ecx, edx		以叠加模式绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(DDImage*)]+0]+A8]
56E6A0	Sexy::DDImage::DrawLine(int theDrawMode, const Color& theColor, double theEndY, double theEndX, ;                        double theStartY, double theStartX, ecx = DDImage* this)	eax, ecx, edx		绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(DDImage*)]+0]+14]
56E8C0	Sexy::DDImage::NormalDrawLineAA(const Color& theColor, double theEndY, double theEndX, ;                                double theStartY, double theStartX, ecx = DDImage* this)	eax, ecx, edx		以正常模式抗锯齿地绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(DDImage*)]+0]+AC]
571010	Sexy::DDImage::DrawLineAA(int theDrawMode, const Color& theColor, double theEndY, double theEndX, ;                          double theStartY, double theStartX, ecx = DDImage* this)	eax, ecx, edx		抗锯齿地绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(DDImage*)]+0]+18]
571230	Sexy::DDImage::CommitBits(ecx = DDImage* this)	eax, ecx, edx		当贴图不存在显示表面且像素发生变化后，重新确认并记录其是否存在透明像素和是否需要不透明度通道。		【虚函数】[[[(DDImage*)]+0]+68]
571240	Sexy::DDImage::Create(int theHeight, int theWidth, ecx = DDImage* this)	eax, ecx, edx		生成指定大小的贴图。删除贴图的像素集，重置贴图的宽度和高度，然后标记为像素已变更。		【虚函数】[[[(DDImage*)]+0]+78]
571280	Sexy::DDImage::BitsChanged(ecx = DDImage* this)	eax, ecx, edx		贴图像素变更时的接口函数。删除并释放显示表面。		【虚函数】[[[(DDImage*)]+0]+64]
5712A0	Sexy::DDImage::GetBits(ecx = DDImage* this)	eax = unsigned long* aBits; ecx, edx		根据贴图的像素模式，从贴图的表面中取得原始图像的 argb 像素集以赋值 mBits 并返回。;若贴图不存在表面，则以 MemoryImage::GetBits() 的方式取得贴图原始图像的像素集。		【虚函数】[[[(DDImage*)]+0]+7C]
5714F0	Sexy::DDImage::NormalFillRect(const Color& theColor, const Rect& theRect, ecx = DDImage* this)	eax, ecx, edx		以正常模式以 theColor 颜色填充 theRect 矩形区域。		【虚函数】[[[(DDImage*)]+0]+94]
571970	Sexy::DDImage::AdditiveFillRect(const Color& theColor, const Rect& theRect, ecx = DDImage* this)	eax, ecx, edx		以叠加模式以 theColor 颜色填充 theRect 矩形区域。		【虚函数】[[[(DDImage*)]+0]+98]
571D90	Sexy::DDImage::NormalBlt;(const Color& theColor, const Rect& theSrcRect, int theY, int theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		以正常模式在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(DDImage*)]+0]+9C]
575830	Sexy::DDImage::NormalBltMirror(const Color& theColor, const Rect& theSrcRectOrig, ;                               int theY, int theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		以正常模式在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRectOrig 部分的镜像。		【虚函数】[[[(DDImage*)]+0]+B4]
577BF0	Sexy::DDImage::AdditiveBlt;(const Color& theColor, const Rect& theSrcRect, int theY, int theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		以叠加模式在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(DDImage*)]+0]+A0]
578E50	Sexy::DDImage::AdditiveBltMirror(const Color& theColor, const Rect& theSrcRectOrig, ;                                 int theY, int theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		以叠加模式在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRectOrig 部分的镜像。		【虚函数】[[[(DDImage*)]+0]+B8]
57A160	Sexy::DDImage::Blt(int theDrawMode, const Color& theColor, const Rect& theSrcRect, ;                   int theY, int theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(DDImage*)]+0]+24]
57A3D0	Sexy::DDImage::BltMirror(int theDrawMode, const Color& theColor, const Rect& theSrcRect, ;                         int theY, int theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRect 部分的镜像。		【虚函数】[[[(DDImage*)]+0]+3C]
57A490	Sexy::DDImage::BltF(int theDrawMode, const Color& theColor, const Rect& theClipRect, ;                    const Rect& theSrcRect, int theY, int theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		在 (theX, theY) 浮点位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(DDImage*)]+0]+3C]
57A610	Sexy::DDImage::BltRotated(float theRotCenterY, float theRotCenterX, double theRot, int theDrawMode, ;                          const Color& theColor, const Rect& theClipRect, const Rect& theSrcRect, ;                          float theY, float theX, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		绘制贴图绕屏幕坐标 (theRotCenterX, theRotCenterY) 处的一点旋转 theRot 弧度后的图像。		【虚函数】[[[(DDImage*)]+0]+2C]
581930	Sexy::DDImage::StretchBlt(bool fastStretch, int theDrawMode, const Color& theColor, ;                          const Rect& theClipRect, const Rect& theSrcRectOrig, ;                          const Rect& theDestRectOrig, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		将贴图的 theSrcRectOrig 区域拉伸填充 theDestRectOrig 区域，;且实际绘制的图像不会超越 theClipRect 区域。		【虚函数】[[[(DDImage*)]+0]+30]
583AF0	Sexy::DDImage::StretchBltMirror(bool fastStretch, int theDrawMode, const Color& theColor, ;                                const Rect& theClipRect, const Rect& theSrcRectOrig, ;                                const Rect& theDestRectOrig, Image* theImage, ecx = DDImage* this)	eax, ecx, edx		将贴图的 theSrcRectOrig 区域的镜像拉伸填充 theDestRectOrig 区域，;且实际绘制的图像不会超越 theClipRect 区域。		【虚函数】[[[(DDImage*)]+0]+40]
5858C0	Sexy::DDImage::BltMatrix(bool blend, const Rect& theSrcRect, int theDrawMode, const Color& theColor, ;                         const Rect& theClipRect, const SexyMatrix3& theMatrix, float y, float x, ;                         Image* theImage, ecx = DDImage* this)	eax, ecx, edx		在 (x, y) 位置绘制贴图 theImage 的 theSrcRect 部分经过矩阵 theMatrix 变换后的图像。;若指定 blend 为真，则会通过线性混合（观感上模糊）以缓解缩放产生的像素块，反之则清晰保留这些像素块。		【虚函数】[[[(DDImage*)]+0]+34]
5859F0	Sexy::DDImage::BltTrianglesTex;(bool blend, float ty, float tx, int theDrawMode, const Color& theColor, const Rect& theClipRect, ; int theNumTriangles, const TriVertex theVertices[][3], Image* theTexture, ecx = DDImage* this)	eax, ecx, edx		以 theTexture 为纹理，在 (tx, ty) 偏移位置填充 theNumTriangles 个由 TriVertex[3] 指定的三角形区域。		【虚函数】[[[(DDImage*)]+0]+38]
585B20	Sexy::DDImage::Palletize(ecx = DDImage* this)	al = bool succeed; ecx, edx		将贴图的原始像素数据量化为 8 位调色板并删除其表面，以节省其占用的内存空间。		【虚函数】[[[(DDImage*)]+0]+88]
585B40	Sexy::DDImage::FillScanLinesWithCoverage;(int theCoverHeight, int theCoverWidth, int theCoverY, int theCoverX, const unsigned char* theCoverage, ; int theDrawMode, const Color& theColor, int theSpanCount, Span* theSpans, ecx = DDImage* this)	eax, ecx, edx		指定一个不透明度值的数组 theCoverage，将其视作一张 theCoverWidth * theCoverHeight 大小的蒙版图像，;theCoverX 和 theCoverY 指定需要将该蒙版放置在 *this 图像上的位置（使用以 *this 为参考的相对坐标）。;通过 theSpans 数组指定 theSpanCount 条水平扫描线，扫描线的坐标使用以 *this 为参考的相对坐标。;此时，需要确保 theCoverage 蒙版所覆盖的区域内可以容纳 theSpans 中的全部 theSpanCount 条水平扫描线。;对于扫描线上的每个像素点，将该点处的不透明度值与 theColor 指定的颜色的不透明度值和 theCoverage 蒙版上该点的不透明度值进行一定算法的混合，同时将该点处的其他颜色值与 theColor 指定的颜色进行一定比例的混合，混合比例等于该点不透明度值的实际混合比例（即：混合后的不透明度值 / 混合前的不透明度值）。;单个 Span 结构相当于一个 (y, x, width) 形式的三元数值对。函数会直接改变实参中 Span 的 x 和 y 数据。		【虚函数】[[[(DDImage*)]+0]+20]
586050	Sexy::DDImage::ReadFromCache(const std::string& theCacheName, const std::string& theFilePath)	eax = DDImage*? anImage; ecx, edx	0x8	从缓存读取贴图。
586230	Sexy::DDImage::WriteToCache;(const std::string& theCacheName, const std::string& theFilePath, ecx = DDImage* this)	eax, ecx, edx		将贴图写入缓存。		【虚函数】[[[(DDImage*)]+0]+C8]
586780	Sexy::Font::Font(eax = Font* this)	eax = *this; ecx		初始化新字体。需要一个大小为 0x14 的内存区域用于构造 this。
5867A0	Sexy::Font::`scalar deleting destructor'(unsigned int flags, ecx = Font* this)	eax = *this; ecx, edx		删除 Sexy::Font 字体，当 flags 的第 0 位置 1 时会额外释放字体本身占用的内存空间。		【虚函数】[[[(Font*)]+0]+0]
5867C0	Sexy::Font::Font(ecx = const Font& theFont, eax = Font* this)	eax = *this; ecx, edx		复制 theFont 字体的数据以创建新字体。需要一个大小为 0x14 的内存区域用于构造 this。
5867E0	Sexy::Font::~Font(ecx = Font* this)	此函数不改变任何寄存器		销毁字体。
5867F0	Sexy::Font::GetAscent(ecx = Font* this)	eax = int aAscent		取得字体的上升高度（基线至文字区域顶端的高度）。		【虚函数】[[[(Font*)]+0]+4]
586800	Sexy::Font::GetAscentPadding(ecx = Font* this)	eax = int aAscentPadding		取得字体完整区域的上边界与文字区域顶端之间的填充高度。		【虚函数】[[[(Font*)]+0]+8]
586810	Sexy::Font::GetDecent(ecx = Font* this)	eax = int aDecent		取得字体的下沉高度（基线以下部分的高度）。		【虚函数】[[[(Font*)]+0]+C]
586820	Sexy::Font::GetHeight(ecx = Font* this)	eax = int aHeight		取得字体完整区域的高度。		【虚函数】[[[(Font*)]+0]+10]
586830	Sexy::Font::GetLineSpacingOffset(ecx = Font* this)	eax = int aLineSpacingOffset		取得字体的行距。		【虚函数】[[[(Font*)]+0]+14]
586840	Sexy::Font::GetLineSpacing(ecx = Font* this)	eax = int aLineSpacing		取得字体的行高度。		【虚函数】[[[(Font*)]+0]+18]
586850	Sexy::Font::StringWidth(const std::string& theString, ecx = Font* this)	eax = int aWidth		获取字符串在当前字体下的宽度。		【虚函数】[[[(Font*)]+0]+1C]
586860	Sexy::Font::CharWidth(char theChar, ecx = Font* this)	eax = int aWidth; ecx, edx		获取单个独立字符在当前字体下的宽度。		【虚函数】[[[(Font*)]+0]+20]
586900	Sexy::Font::CharWidthKern(char thePrevChar = 0, char theChar, ecx = Font* this)	eax = int aWidth; ecx, edx		获取单个字符在受到前一个字符影响的调整下，其实际占用的宽度。		【虚函数】[[[(Font*)]+0]+24]
586910	Sexy::Font::DrawString(const Rect& theClipRect, const Color& theColor, const std::string& theString, ;                       int theY, int theX, Graphics* g, ecx = Font* this)	此函数不改变任何寄存器		以字体绘制字符串。默认函数不进行任何处理。		【虚函数】[[[(Font*)]+0]+28]
586920	Sexy::GraphicsState::CopyStateFrom(eax = const GraphicsState* theState, ecx = GraphicsState* this)	eax, edx		将 theState 的数据复制到 *this 中。注：将 Graphics* 静态转换为 GraphicsState* 需执行 add XXX,04。
5869B0	Sexy::Graphics::Graphics(const Graphics& theGraphics, edi = Graphics* this)	eax = *this; ecx, edx		复制 theGraphics 的数据以初始化创建新 Graphics。
586A10	Sexy::Graphics::`scalar deleting destructor'(unsigned int flags, ecx = Graphics* this)	eax = *this; ecx, edx		删除 Graphics，当 flags 的第 0 位置 1 时会额外释放 Graphics 本身占用的内存空间。		【虚函数】[[[(Graphics*)]+0]+0]
586A30	Sexy::Graphics::Graphics(ecx = Image* theDestImage, Graphics* this)	eax = *this; ecx, edx		根据给定的目标贴图 theDestImage 新建 Graphics。后续的绘制均会在此目标贴图上进行。
586B10	Sexy::Graphics::~Graphics(ecx = Graphics* this)	eax, ecx, edx		删除 Graphics。
586B40	Sexy::Graphics::PushState(Graphics* this)	eax, ecx, edx		保存 Graphics 当前的数据和状态。
586BD0	Sexy::Graphics::PopState(edi = Graphics* this)	eax, ecx, edx		读取并清除最近一次保存的 Graphics 的数据和状态记录。
586C30	Sexy::Graphics::Create(Graphics* this)	eax = Graphics* aG; ecx, edx		复制自身的数据以创建新 Graphics。此函数取得的 aG 后续需要自行删除和释放。
586CA0	Sexy::Graphics::GetFont(eax = Graphics* this)	eax = Font* aFont		取得 Graphics 当前使用的字体。
586CB0	Sexy::Graphics::SetFont(ecx = Font* theFont, eax = Graphics* this)	此函数不改变任何寄存器		设定 Graphics 的字体。
586CC0	Sexy::Graphics::SetColor(eax = const Color& theColor, ecx = Graphics* this)	eax, edx		设定 Graphics 的颜色。
586CE0	Sexy::Graphics::GetColor(eax = Graphics* this)	eax = Color& aColor		获取 Graphics 的颜色，返回对 Graphics 自身颜色的引用。该函数内部仅执行了【add eax,30】。
586CF0	Sexy::Graphics::SetDrawMode(ecx = int theDrawMode, eax = Graphics* this)	此函数不改变任何寄存器		设定 Graphics 的绘制模式。theDrawMode = 0(NORMAL) | 1(ADDITIVE)。
586D00	Sexy::Graphics::GetDrawMode(eax = Graphics* this)	eax = int aDrawMode		取得 Graphics 当前的绘制模式。
586D10	Sexy::Graphics::SetColorizeImages(cl = bool colorizeImages, eax = Graphics* this)	此函数不改变任何寄存器		设定 Graphics 的着色与否。
586D20	Sexy::Graphics::GetColorizeImages(eax = Graphics* this)	al = bool colorizeImages		取得 Graphics 的着色与否。
586D30	Sexy::Graphics::SetFastStretch(cl = bool fastStretch, eax = Graphics* this)	此函数不改变任何寄存器		设定 Graphics 的快速拉伸与否。
586D40	Sexy::Graphics::SetLinearBlend(cl = bool linear, eax = Graphics* this)	此函数不改变任何寄存器		设定 Graphics 的线性混合与否。
586D50	Sexy::Graphics::FillRect(int theHeight, int theWidth, int theY, int theX, eax = Graphics* this)	eax, ecx, edx		填充一个指定位置和大小的矩形。颜色信息在 *this 的 +30 至 +3C 的地址处。
586DC0	Sexy::Graphics::FillRect(eax = const Rect& theRect, Graphics* this)	eax, ecx, edx		填充矩形。此函数的实质即为586D50的函数。
586DE0	Sexy::Graphics::DrawRect(int theHeight, int theWidth, int theY, int theX, eax = Graphics* this)	eax, ecx, edx		绘制一个指定位置和大小的空心矩形。颜色信息在 *this 的 +30 至 +3C 的地址处。
586EF0	Sexy::Graphics::DrawRect(eax = const Rect& theRect, Graphics* this)	eax, ecx, edx		绘制空心矩形。此函数的实质即为586DE0的函数。
586F10	Sexy::Graphics::DrawLineClipHelper(esi = double* theEndY, edi = double* theEndX, ;                                   ebx = double* theStartY, double* theStartX, ecx = Graphics* this)	al = bool needToDraw; ecx, edx		将给定的即将绘制的线段裁剪至 Graphics 自身的裁剪矩形范围内。;若给定线段没有位于裁剪矩形内的部分，则返回 false 表示无须实际绘制。
587080	Sexy::Graphics::DrawLine(int theEndY, int theEndX, int theStartX, Graphics* this)	eax, ecx, edx		绘制一条从 (theStartX, 1) 至 (theEndX, theEndY) 的线段。
587120	Sexy::Graphics::DrawString(int theY, int theX, const std::string& theString, eax = Graphics* this)	eax, ecx, edx		在 (theX, theY) 位置绘制字符串 theString。需要 [*this+40] 字体不为 0 才能正常显示。
587150	Sexy::Graphics::DrawImage(int theY, int theX, ebx = Image* theImage, eax = Graphics* this)	eax, ecx, edx		在 (theX, theY) 位置绘制贴图 theImage。
587270	Sexy::Graphics::DrawImage;(int theY, int theX, Image* theImage, eax = const Rect& theSrcRect, ecx = Graphics* this)	eax, ecx, edx		在 (theX, theY) 位置绘制贴图 theImage 中以矩形 theSrcRect 为蒙版裁剪下的一部分。
587490	Sexy::Graphics::DrawImageMirror(bool mirror, const Rect& theSrcRect, edi = const Rect& theDestRect, ;                                ebx = Image* theImage, eax = Graphics* this)	eax, ecx, edx		绘制镜像的贴图。其中 mirror 指定是否镜像。
587520	Sexy::Graphics::DrawImage(int theStretchedHeight, int theStretchedWidth, int theY, int theX, ;                          edi = Image* theImage, eax = Graphics* this)	eax, ecx, edx		将贴图 theImage 的宽度和高度分别缩放至 theStretchedWidth 和 theStretchedHeight，;并在 (theX, theY) 位置绘制缩放后的贴图。
5875B0	Sexy::Graphics::DrawImage;(const Rect& theSrcRect, eax = const Rect& theDestRect, Image* theImage, ecx = Graphics* this)	eax, ecx, edx		将贴图的 theSrcRect 区域缩放至 theDestRect 矩形的大小，并以缩放后的贴图填充 theDestRect 矩形区域。
587630	Sexy::Graphics::DrawImageF(float theY, float theX, edx = Image* theImage, eax = Graphics* this)	eax, ecx, edx		在浮点坐标 (theX, theY) 位置绘制贴图 theImage。
5876B0	Sexy::Graphics::DrawImageF;(const Rect& theSrcRect, float theY, float theX, Image* theImage, eax = Graphics* this)	eax, ecx, edx		在浮点坐标 (theX, theY) 位置绘制贴图 theImage 的 theSrcRect 区域。
587710	Sexy::Graphics::DrawTrianglesTex;(int theNumTriangles, const TriVertex theVertices[][3], Image* theTexture, eax = Graphics* this)	eax, ecx, edx		以 theTexture 为纹理，填充 theNumTriangles 个由 TriVertex[3] 指定的三角形区域。
587760	Sexy::Graphics::ClearClipRect(ecx = Graphics* this)	eax, edx		清除自身的裁剪矩形。
587790	Sexy::Graphics::SetClipRect(int theHeight, int theWidth, int theY, int theX, esi = Graphics* this)	eax, ecx, edx		设置自身的裁剪矩形为自身 mDestImage 贴图的范围矩形和参数给定矩形的交集。;其中，参数 theX 和 theY 采用以自身的偏移坐标为参考的相对坐标。
587820	Sexy::Graphics::SetClipRect(eax = const Rect& theRect, esi = Graphics* this)	eax, edx		设置自身的裁剪矩形为 mDestImage 的范围矩形和矩形 theRect 的交集。此函数的实质即为587790的函数。
587840	Sexy::Graphics::ClipRect(int theHeight, int theWidth, int theY, int theX, esi = Graphics* this)	eax, ecx, edx		设置自身的裁剪矩形为当前裁剪矩形和参数给定矩形的交集。;其中，参数给定矩形的坐标采用以自身的偏移坐标为参考的相对坐标。
5878B0	Sexy::Graphics::Translate(int theTransY, int theTransX, eax = Graphics* this)	此函数不改变任何寄存器		Graphics 位置移动，其偏移坐标增加 (theTransX, theTransY)。
5878D0	Sexy::Graphics::SetScale;(float theOrigY, float theOrigX, float theScaelY, float theScaleX, eax = Graphics* this)	此函数不改变任何寄存器		设定 Graphics 的拉伸原点和拉伸比例。参数中使用的拉伸原点坐标为以自身的偏移坐标为参考的相对坐标。
587900	Sexy::Graphics::DrawImageBox;(eax = Image* theComponentImage, ebx = const Rect& theDestRect, Graphics* this)	eax, ecx, edx		将贴图 theComponentImage 分割为 3×3 的 9 块，拉伸或复制其中部分块以拼接填充 theDestRect。;此函数内部获取 theComponentImage 的矩形作为 theSrcRect，实质即为587930的函数。
587930	Sexy::Graphics::DrawImageBox;(Image* theComponentImage, ebx = const Rect& theDestRect, const Rect& theSrcRect, Graphics* this)	eax, ecx, edx		将贴图 theComponentImage 的 theSrcRect 区域分割为 3×3 的 9 块，;拉伸或复制其中部分块以拼接填充 theDestRect。;需要 theSrcRect 不超出 theComponentImage 的图像范围，;且 theDestRect 的宽高均不小于 theSrcRect 的 1/3 时才能正确绘制。
587E50	Sexy::Graphics::DrawImageCel;(eax = int theCel, int theY, int theX, ecx = Image* theImageStrip, Graphics* this)	eax, ecx, edx		在 (theX, theY) 位置绘制分份贴图 theImageStrip 从左至右、从上至下计数的第 theCel 份。;此函数内部根据份序数计算了指定份所在的行列，实质即为587E80的函数。
587E80	Sexy::Graphics::DrawImageCel;(edi = int theCelRow, int theCelCol, int theY, int theX, ecx = Image* theImageStrip, Graphics* this)	eax, ecx, edx		在 (theX, theY) 位置绘制分份贴图 theImageStrip 位于 (theCelCol, theCelRow) 的一份。
587EF0	Sexy::Graphics::WriteString;(int theOldColor, int theLength, int theOffset, bool drawString, int theJustification, ; int theWidth, int theY, int theX, const std::string& theString, ecx = Graphics* this)	eax = int aXOffset; ecx, edx		计算以字符串从 theOffset 位置开始 theLength 长度的部分时的实际绘制区域宽度，;当 theLength = -1 时，绘制部分改为从 theOffset 位置开始至字符串结束。;当 drawString = 1 时，会同时直接在 (theX, theY) 位置处以 theWidth 为参考宽度绘制字符串（不换行）。
5882C0	WriteWordWrappedHelper;(edx = int theMaxChars, int theOldColor, eax = int theLength, ecx = int theOffset, int theJustification, ; int theWidth, int theY, int theX, const std::string& theString, Graphics* g)	eax = int aXOffset; ecx, edx	0x1C	计算以字符串从 theOffset 位置开始 theLength 长度的部分时的实际绘制区域宽度，;在 (theX, theY) 位置处以 theWidth 为参考宽度绘制字符串（不换行）。;当 theOffset + theLength > theMaxChars 时，调整 theLength 的值当 theLength <= 0 时，返回 -1。
588310	Sexy::Graphics::WriteWordWrapped;(int theJustification, int theLineSpacing = -1, ebx = const std::string& theLine, ; const Rect& theRect, edx = Graphics* this)	eax = int 实际文本区域高度; ecx, edx		在 theRect 矩形区域内自动换行地绘制字符串。当行距 theLineSpacing = -1 时，使用 Graphics 字体的行距;theJustification 为绘制文本的对齐方式，其取值范围为 { -1(左对齐), 0(居中对齐), 1(右对齐) }。;由于一个中文汉字编码占用 2 个字节，故在绘制中文编码的字符串时会出现乱码，可手动添加换行符解决。
5886B0	Sexy::Graphics::DrawStringWordWrapped;(theY, eax = int theX, ebx = const std::string& theLine, esi = Graphics* this)	eax = int 实际文本区域高度; ecx, edx		在 (theX, theY) 位置自动换行地绘制字符串。其设定绘制区域宽度为 108 并以默认参数调用了588310的函数。;字符串中可插入使用“^”表示后续 6 个字符为 16 进制 RGB 颜色字符串（用“^^”表示“^”符号本身），;但由于原版代码的 BUG，插入的颜色字符串的后一个字符会被无效化，需要在其后额外添加一个任意字符。
588700	Sexy::Graphics::GetWordWrappedHeight;(int aLineSpacing, ebx = const std::string& theLine, int theWidth, Graphics* this)	eax = int aHeight; ecx, edx		取得字符串 theLines 在 theWidth 宽度内自动换行地绘制时，实际绘制区域所占用的高度。
5887A0	Sexy::NativeDisplay::NativeDisplay(eax = NativeDisplay* this)	eax = *this; ecx, edx		初始化创建本机显示器。需要一个大小为 0x2C 的内存区域用于构造 this。
5887D0	Sexy::NativeDisplay::`scalar deleting destructor'(unsigned int flags, ecx = NativeDisplay* this)	eax = *this; ecx, edx		删除 NativeDisplay 本机显示器，当 flags 的第 0 位置 1 时会额外释放本机显示器本身占用的内存空间。		【虚函数】[[[(NativeDisplay*)]+0]+0]
5887F0	Sexy::NativeDisplay::~NativeDisplay(ecx = NativeDisplay* this)	eax, ecx, edx		销毁本机显示器。
588800	Sexy::Image::Image(eax = Image* this)	eax = *this; ecx, edx		初始化创建贴图。需要一个大小为 0x38 的内存区域用于构造 this。
588830	Sexy::Image::`scalar deleting destructor'(unsigned int flags, ecx = Image* this)	eax = *this; ecx, edx		删除 Sexy::Image 贴图，当 flags 的第 0 位置 1 时会额外释放贴图本身占用的内存空间。		【虚函数】[[[(Image*)]+0]+0]
588850	Sexy::Image::Image(edi = const Image& theImage, Image* this)	eax = *this; ecx, edx		复制贴图 theImage 的数据以创建新贴图。需要一个大小为 0x38 的内存区域用于构造 this。
588900	Sexy::AnimInfo::AnimInfo(const AnimInfo& __that, AnimInfo* this)	eax = *this; ecx, edx		复制贴图动画信息 __that 的数据以创建新动画信息。需要一个大小为 0x30 的内存区域用于构造 this。
588980	Sexy::Image::~Image(ecx = Image* this)	eax, ecx, edx		销毁 Sexy::Image 贴图，删除贴图动画信息和贴图文件路径字符串。
5889C0	Sexy::AnimInfo::`scalar deleting destructor'(esi = AnimInfo* this)	eax = *this; ecx, edx		删除贴图动画信息，释放每帧延迟和每帧图像的向量容器并释放自身占用的内存空间。
588A10	Sexy::Image::GetWidth(eax = Image* this)	eax = int aWidth		取得贴图整体的横向宽度。
588A20	Sexy::Image::GetHeight(eax = Image* this)	eax = int aHeight		取得贴图整体的纵向高度。
588A30	Sexy::Image::GetCelHeight(ecx = Image* this)	eax = int aCelHeight		分份贴图计算单份贴图的纵向高度。
588A40	Sexy::Image::GetCelWidth(ecx = Image* this)	eax = int aCelWidth		分份贴图计算单份贴图的横向宽度。
588A50	Sexy::AnimInfo::AnimInfo(AnimInfo* this)	eax = *this; ecx		初始化创建贴图动画信息。需要一个大小为 0x30 的内存区域用于构造 this。
588AB0	Sexy::AnimInfo::SetPerFrameDelay(ebx = int theTime, edi = int theFrame, eax = AnimInfo* this)	eax, ecx, edx		设置动画信息第 theFrame 帧的延迟时间，当前总帧数不足时则相应地进行扩容。
588B00	Sexy::AnimInfo::Compute(int theEndFrameTime, int theBeginFrameTime, eax = int theNumCels, AnimInfo* this)	eax, ecx, edx		根据给定的开始时间、结束时间和帧数，计算动画信息每一帧的图像序列及延迟时间等数据。
588CC0	Sexy::Image::CopyAttributes(ebx = Image* from, edi = Image* this)	eax, ecx, edx		删除自身的动画信息，并从 from 中复制行数、列数和动画信息数据给自身。
588D60	Sexy::Image::DrawRect(int theDrawMode, const Color& theColor, const Rect& theRect, ecx = Image* this)	eax, ecx, edx		绘制矩形。		【虚函数】[[[(Image*)]+0]+C]
588E60	Sexy::Image::DrawLine(int theDrawMode, const Color& theColor, double theEndY, double theEndX, ;                      double theStartY, double theStartX, ecx = Image* this)	eax, ecx, edx		绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。默认函数不进行任何处理。		【虚函数】[[[(Image*)]+0]+14]
588E70	Sexy::Image::FillScanLines;(int theDrawMode, const Color& theColor, int theSpanCount, Span* theSpans, ecx = Image* this)	eax, ecx, edx		以指定颜色绘制 theSpanCount 条水平线段。		【虚函数】[[[(Image*)]+0]+1C]
588EE0	Sexy::Image::PolyFill3D;(bool convex, int ty, int tx, int theDrawMode, const Color& theColor, const Rect* theClipRect, ; int theNumVertices, const Point theVertices[], ecx = Image* this)	al = 0		硬件绘制填充多边形。默认函数返回 false。		【虚函数】[[[(Image*)]+0]+4]
588EF0	Sexy::Image::BltRotated(float theRotCenterY, float theRotCenterX, double theRot, int theDrawMode, ;                        const Color& theColor, const Rect& theClipRect, const Rect& theSrcRect, ;                        float theY, float theX, Image* theImage, ecx = Image* this)	此函数不改变任何寄存器		绘制贴图绕屏幕坐标 (theRotCenterX, theRotCenterY) 处的一点旋转 theRot 弧度后的图像。;默认函数不进行任何处理。		【虚函数】[[[(Image*)]+0]+2C]
588F00	Sexy::Image::StretchBlt(bool fastStretch, int theDrawMode, const Color& theColor, ;                        const Rect& theClipRect, const Rect& theSrcRectOrig, ;                        const Rect& theDestRectOrig, Image* theImage, ecx = Image* this)	此函数不改变任何寄存器		将贴图的 theSrcRectOrig 区域拉伸填充 theDestRectOrig 区域，;且实际绘制的图像不会超越 theClipRect 区域。默认函数不进行任何处理。		【虚函数】[[[(Image*)]+0]+30]
588F10	Sexy::Image::BltMatrix(bool blend, const Rect& theSrcRect, int theDrawMode, const Color& theColor, ;                       const Rect& theClipRect, const SexyMatrix3& theMatrix, float y, float x, ;                       Image* theImage, ecx = Image* this)	此函数不改变任何寄存器		在 (x, y) 位置绘制贴图 theImage 的 theSrcRect 部分经过矩阵 theMatrix 变换后的图像。;若指定 blend 为真，则会通过线性混合以缓解缩放产生的像素块。默认函数不进行任何处理。		【虚函数】[[[(DDImage*)]+0]+34]
588F20	Sexy::CharData::CharData(esi = CharData* this)	eax = *this; ecx, edx		初始化创建字符数据。需要一个大小为 0x2C 的内存区域用于构造 this。
588F60	Sexy::FontLayer::FontLayer(FontData* theFontData, FontLayer* this)	eax = *this; ecx, edx		以指定的字体数据创建字体图层。需要一个大小为 0xD8 的内存区域用于构造 this。
5890F0	std::map<char, Sexy::CharData>::~map<char, Sexy::CharData>(eax = std::map<char, Sexy::CharData>* this)	eax, ecx, edx		销毁并释放字符向字符数据的映射容器。
589100	Sexy::FontLayer::FontLayer(edi = const FontLayer& theFontLayer, FontLayer* this)	eax = *this; ecx, edx		复制 theFontLayer 的数据以创建新字体图层。需要一个大小为 0xD8 的内存区域用于构造 this。
5892A0	Sexy::FontLayer::GetCharData(char theChar, ecx = FontLayer* this)	eax = CharData* aCharData; ecx, edx		从字体图层中获取 theChar 字符的字符数据，若图层中不存在该字符的数据则立即创建。
589400	Sexy::CharData::~CharData(eax = CharData* this)	eax, ecx, edx		销毁字符数据，销毁并释放其字符和字距偏移的映射容器。
589410	std::pair<char, Sexy::CharData>::~pair<char, Sexy::CharData>(eax = std::pair<char, Sexy::CharData>* this)	eax, ecx, edx		销毁字符和字符数据的对组。
589420	Sexy::FontData::FontData(FontData* this)	eax = *this; ecx, edx		初始化创建字体数据。需要一个大小为 0xD8 的内存区域用于构造 this。
589520	Sexy::FontData::`scalar deleting destructor'(unsigned int flags, ecx = FontData* this)	eax = *this; ecx, edx		删除字体数据，当 flags 的第 0 位置 1 时会额外释放字体数据本身占用的内存空间。		【虚函数】[[[(FontData*)]+0]+0]
589540	std::map<char, char>::~map<char, char>(eax = std::map<char, char>* this)	eax, ecx, edx		销毁并释放字符向字符的映射容器。
589550	std::map<std::string, Sexy::FontLayer*>::~map<std::string, Sexy::FontLayer*>;(eax = std::map<std::string, Sexy::FontLayer*>* this)	eax, ecx, edx		销毁并释放字符串向字体图层指针的映射容器。
589560	Sexy::FontData::~FontData(ecx = FontData* this)	eax, ecx, edx		销毁字体数据，释放其中的所有相关容器，并删除所有已定义的数据元素。
589740	Sexy::FontData::Ref(eax = FontData* this)	此函数不改变任何寄存器		增加字体数据自身的 1 次引用计数。
589750	Sexy::FontData::DeRef(ecx = FontData* this)	eax, ecx, edx		减少字体数据自身的 1 次引用计数。若减少后引用计数为 0，则删除自身。
589760	Sexy::FontData::Error(const std::string& theError, ecx = FontData* this)	al = bool ; ecx, edx		字体数据错误，获取并弹出错误弹窗。		【虚函数】[[[(FontData*)]+0]+24]
589930	Sexy::FontData::DataToLayer(FontLayer** theFontLayer, DataElement* theSource, ecx = FontData* this)	al = bool 是否成功; ecx, edx		根据 theSource 数据元素的字符串取得已定义的同名字体图层并将找到的字体图层的指针写入 [theFontLayer]。;若未找到已定义的同名图层，则将 0 写入 [theFontLayer]、弹出“Undefined Layer”错误并返回 false。
589A80	Sexy::FontData::GetColorFromDataElement;(const Color& theColor, DataElement* theElement, ecx = FontData* this)	al = bool 是否成功; ecx, edx		从 theSource 数据元素中提取颜色信息赋值给 theColor。
589C60	Sexy::FontData::HandleCommand(const ListDataElement& theParams, ecx = FontData* this)	al = bool 是否成功; ecx, edx		根据数据元素列表 theParams 中分析命令及所带参数，并根据命令和参数进行相应的处理。		【虚函数】[[[(FontData*)]+0]+2C]
58C860	Sexy::FontLayer::~FontLayer(FontLayer* this)	eax, ecx, edx		销毁字体图层，释放其中的所有相关容器。
58C980	Sexy::FontData::Load;(ebx = const std::string& theFontDescFileName, SexyAppBase* theSexyApp, ecx = FontData* this)	al = bool 是否成功; ecx, edx		加载字体描述文件以初始化字体数据。
58CAB0	Sexy::FontData::LoadLegacy(const std::string& theFontDescFileName, Image* theFontImage, FontData* this)	al = bool 是否成功; ecx, edx		【弃用】加载字体描述文件并以指定的字体贴图以初始化字体数据。
58CEA0	Sexy::ActiveFontFayer::ActiveFontFayer(esi = ActiveFontFayer* this)	eax = *this; ecx, edx		初始化创建活动字体图层。需要一个大小为 0x1C 的内存区域用于构造 this。
58CEE0	Sexy::ActiveFontFayer::`scalar deleting destructor'(unsigned int flags, ecx = ActiveFontFayer* this)	eax = *this; ecx, edx		删除活动字体图层，当 flags 的第 0 位置 1 时会额外释放活动字体图层本身占用的内存空间。		【虚函数】[[[(ActiveFontFayer*)]+0]+0]
58CF00	std::map<char, Sexy::Rect>::~map<char, Sexy::Rect>(eax = std::map<char, Sexy::Rect>* this)	eax, ecx, edx		销毁并释放字符向矩形的映射容器。
58CF10	Sexy::ActiveFontFayer::ActiveFontFayer(const ActiveFontLayer& theActiveFontLayer, ActiveFontFayer* this)	eax = *this; ecx, edx		复制 theActiveFontLayer 的数据以创建新活动字体图层。需要一个大小为 0x1C 的内存区域用于构造 this。
58CFA0	Sexy::ActiveFontFayer::~ActiveFontFayer(ecx = ActiveFontFayer* this)	eax, ecx, edx		销毁活动字体图层，若图层存在贴图，则删除该贴图。
58D010	Sexy::ImageFont::ImageFont(ImageFont* this)	eax = *this; ecx, edx		初始化创建贴图字体。需要一个大小为 0x50 的内存区域用于构造 this。
58D0C0	Sexy::ImageFont::`scalar deleting destructor'(unsigned int flags, ecx = ImageFont* this)	eax = *this; ecx, edx		删除贴图字体，当 flags 的第 0 位置 1 时会额外释放贴图字体本身占用的内存空间。		【虚函数】[[[(ImageFont*)]+0]+0]
58D0E0	Sexy::ImageFont::ImageFont;(const std::string& theFontDescFileName, SexyAppBase* theSexyApp, ImageFont* this)	eax = *this; ecx, edx		以指定的字体描述文件创建贴图字体。需要一个大小为 0x50 的内存区域用于构造 this。
58D1C0	Sexy::ImageFont::ImageFont(ecx = const ImageFont& theImageFont, ImageFont* this)	eax = *this; ecx, edx		复制 theImageFont 的数据创建新贴图字体。需要一个大小为 0x50 的内存区域用于构造 this。
58D280	Sexy::ImageFont::ImageFont(const std::string& theFontDescFileName, Image* theFontImage, ImageFont* this)	eax = *this; ecx, edx		以指定的字体描述文件和字体贴图创建贴图字体。需要一个大小为 0x50 的内存区域用于构造 this。
58D360	Sexy::ImageFont::~ImageFont(ecx = ImageFont* this)	eax, ecx, edx		销毁贴图字体，释放字体图层和字体数据等。
58D410	Sexy::ImageFont::GenerateActiveFontLayers(ecx = ImageFont* this)	eax, ecx, edx		根据字体数据中读取的字体图层信息，生成相应的活动字体图层。		【虚函数】[[[(ImageFont*)]+0]+30]
58DF00	Sexy::ImageFont::GetMappedChar(al = char theChar, eax = ImageFont* this)	al = char aChar; ecx, edx		在字体数据中寻找 theChar 字符映射的实际字符。若映射中不存在 theChar 键，则直接返回 theChar。
58DF70	Sexy::ImageFont::StringWidth(const std::string& theString, ecx = ImageFont* this)	eax = int aWidth; ecx, edx		获取字符串在当前贴图字体下的宽度。		【虚函数】[[[(ImageFont*)]+0]+1C]
58DFF0	Sexy::ImageFont::CharWidthKern(char thePrevChar = 0, char theChar, ecx = ImageFont* this)	eax = int aWidth; ecx, edx		获取单个字符在受到前一个字符影响的调整下，其实际占用的宽度。		【虚函数】[[[(ImageFont*)]+0]+24]
58E270	Sexy::ImageFont::CharWidth(char theChar, ecx = ImageFont* this)	eax = int aWidth; ecx, edx		获取单个独立字符在当前贴图字体下的宽度。		【虚函数】[[[(ImageFont*)]+0]+20]
58E290	Sexy::ImageFont::DrawStringEx;(int* theWidth = 0, std::list<Rect>* theDrawnAreas = 0, const Rect* theClipRect, const Color& theColor, ; const std::string& theString, int theY, int theX, Graphics* g, ecx = ImageFont* this)	eax, ecx, edx		以指定的贴图字体绘制字符串。若参数 theWidth 不为空指针，则将实际绘制区域的宽度存储在 [theWidth] 中;若参数 theDrawnAreas 不为空指针，则清空链表并将实际绘制的每一个字符的矩形区域依次压入链表中。;部分汉化版中，此函数头部被修改为[jmp SysFont::DrawString]，上述用作返回值的参数在这些版本不可用。		【虚函数】[[[(ImageFont*)]+0]+34]
58EAB0	Sexy::ImageFont::DrawString(const Rect& theClipRect, const Color& theColor, const std::string& theString, ;                            int theY, int theX, Graphics* g, ecx = ImageFont* this)	eax, ecx, edx		以指定的贴图字体绘制字符串。函数的实质即为 ImageFont::DrawStringEx 的函数。		【虚函数】[[[(ImageFont*)]+0]+28]
58EAE0	Sexy::ImageFont::Duplicate(ecx = ImageFont* this)	eax = ImageFont* aFont; ecx, edx		复制贴图字体自身的数据以创建新贴图字体。		【虚函数】[[[(ImageFont*)]+0]+2C]
58EB50	Sexy::ImageFont::SetPointSize(int thePointSize, ecx = ImageFont* this)	eax, ecx, edx		设置贴图字体的字号大小。		【虚函数】[[[(ImageFont*)]+0]+38]
58EB60	Sexy::ImageFont::SetScale(double theScale, ecx = ImageFont* this)	eax, ecx, edx		设置贴图字体的缩放比例。		【虚函数】[[[(ImageFont*)]+0]+40]
58EB70	Sexy::ImageFont::GetPointSize(ecx = ImageFont* this)	eax = int aPointSize		取得贴图字体的字号大小（返回 mPointSize 的值）。		【虚函数】[[[(ImageFont*)]+0]+3C]
58EB80	Sexy::ImageFont::GetDefaultPointSize(ecx = ImageFont* this)	eax = int aDefaultPointSize		取得贴图字体的默认字号大小（返回 mFontData->mDefaultPointSize 的值）。		【虚函数】[[[(ImageFont*)]+0]+44]
58EB90	Sexy::ImageFont::AddTag(const std::string& theTagName, ecx = ImageFont* this)	al = bool added; ecx, edx		为贴图字体增加一个标签。若为已有的标签，则直接返回 false。		【虚函数】[[[(ImageFont*)]+0]+48]
58EC30	Sexy::ImageFont::RemoveTag(const std::string& theTagName, ecx = ImageFont* this)	al = bool removed; ecx, edx		移除贴图字体的一个标签。若为未拥有的标签，则直接返回 false。		【虚函数】[[[(ImageFont*)]+0]+4C]
58ED40	Sexy::ImageFont::HasTag(const std::string& theTagName, ecx = ImageFont* this)	al = bool hasTag; ecx, edx		判断贴图字体是否存在指定标签。		【虚函数】[[[(ImageFont*)]+0]+50]
58EDB0	Sexy::ImageFont::GetDefine;(const std::string& theName, _Out_ std::string&& anElementString, ecx = ImageFont* this)	eax = std::string&& anElementString; ;ecx, edx		根据定义的名称取得其对应的数据元素，并以字符串的形式返回其中的数据。		【虚函数】[[[(ImageFont*)]+0]+54]
58EE10	Sexy::ImageFont::Prepare(ecx = ImageFont* this)	eax, ecx, edx		若贴图字体的活动图层不可用，则生成活动图层。		【虚函数】[[[(ImageFont*)]+0]+58]
58EE30	Sexy::ImageFont::ReadFromCache(const std::string& theCacheName, const std::string& theFilePath)	eax = ImageFont*? anImage; ecx, edx	0x8	从缓存读取贴图字体。
58F730	Sexy::ImageFont::WriteToCache;(const std::string& theCacheName, const std::string& theFilePath, ecx = ImageFont* this)	eax, ecx, edx		将贴图字体写入缓存。		【虚函数】[[[(ImageFont*)]+0]+5C]
5900F0	Sexy::MemoryImage::MemoryImage(MemoryImage* this)	eax = *this; ecx, edx		以全局 gSexyAppBase 创建内存贴图。需要一个大小为 0x6C 的内存区域用于构造 this。
590150	Sexy::MemoryImage::`scalar deleting destructor'(unsigned int flags, ecx = MemoryImage* this)	eax = *this; ecx, edx		删除 Sexy::MemoryImage 内存贴图，当 flags 的第 0 位置 1 时会额外释放贴图本身占用的内存空间。		【虚函数】[[[(MemoryImage*)]+0]+0]
590170	Sexy::MemoryImage::MemoryImage(SexyAppBase* theApp, MemoryImage* this)	eax = *this; ecx, edx		初始化创建内存贴图。需要一个大小为 0x6C 的内存区域用于构造 this。
5901D0	Sexy::MemoryImage::MemoryImage(ebx = const MemoryImage& theMemoryImage, MemoryImage* this)	eax = *this; ecx, edx		复制内存贴图 theMemoryImage 的数据以创建新内存贴图。需要一个大小为 0x6C 的内存区域用于构造 this。
590430	Sexy::MemoryImage::~MemoryImage(ecx = MemoryImage* this)	eax, ecx, edx		销毁内存贴图，释放内存贴图的像素、调色板、本机显示数据等占用的内存空间。
5904D0	Sexy::MemoryImage::Init(eax = MemoryImage* this)	eax, ecx, edx		初始化内存贴图，并将自身加入程序的内存贴图集合中。
590510	Sexy::MemoryImage::BitsChanged(ecx = MemoryImage* this)	eax, ecx, edx		内存贴图像素变更时的接口函数，删除原始不透明度数据和游程压缩后的数据。		【虚函数】[[[(MemoryImage*)]+0]+64]
590560	Sexy::MemoryImage::NormalDrawLine(const Color& theColor, double theEndY, double theEndX, ;                                  double theStartY, double theStartX, ecx = MemoryImage* this)	eax, ecx, edx		以正常模式绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(MemoryImage*)]+0]+A4]
590E10	Sexy::MemoryImage::AdditiveDrawLine(const Color& theColor, double theEndY, double theEndX, ;                                    double theStartY, double theStartX, ecx = MemoryImage* this)	eax, ecx, edx		以叠加模式绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(MemoryImage*)]+0]+A8]
591330	Sexy::MemoryImage::DrawLine(int theDrawMode, const Color& theColor, double theEndY, double theEndX, ;                            double theStartY, double theStartX, ecx = MemoryImage* this)	eax, ecx, edx		绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(MemoryImage*)]+0]+14]
5914D0	Sexy::MemoryImage::NormalDrawLineAA(const Color& theColor, double theEndY, double theEndX, ;                                    double theStartY, double theStartX, ecx = MemoryImage* this)	eax, ecx, edx		以正常模式抗锯齿地绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(MemoryImage*)]+0]+AC]
592360	Sexy::MemoryImage::DrawLineAA(int theDrawMode, const Color& theColor, double theEndY, double theEndX, ;                              double theStartY, double theStartX, ecx = MemoryImage* this)	eax, ecx, edx		抗锯齿地绘制一条从 (theStartX, theStartY) 至 (theEndX, theEndY) 的线段。		【虚函数】[[[(MemoryImage*)]+0]+18]
5924D0	Sexy::MemoryImage::CommitBits(ecx = MemoryImage* this)	eax, ecx, edx		当贴图的像素相比上次记录发生变化后，重新确认并记录贴图中是否存在透明像素和是否需要不透明度通道。;当贴图不存在像素或存在不透明度为 0 的像素时，表示存在透明像素，mHasTrans 为真，否则为假;当贴图存在不透明度不为 0 且不为 255 的像素时，表示需要不透明度通道，mHasAlpha 为真，否则为假。		【虚函数】[[[(MemoryImage*)]+0]+68]
5925B0	Sexy::MemoryImage::SetImageMode(bool hasAlpha, bool hasTrans, ecx = MemoryImage* this)	eax, ecx, edx		强制设置内存贴图的图像模式。		【虚函数】[[[(MemoryImage*)]+0]+80]
5925D0	Sexy::MemoryImage::SetVolatile(bool isVolatile, ecx = MemoryImage* this)	eax, ecx, edx		设置内存贴图是否易变。		【虚函数】[[[(MemoryImage*)]+0]+84]
5925E0	Sexy::MemoryImage::GetNativeAlphaData(NativeDisplay* theDisplay, ecx = MemoryImage* this)	eax = void* aNativeAlphaData; ecx, edx		根据本机显示器 theDisplay 的像素格式数据，获取内存贴图的原始不透明度数据。		【虚函数】[[[(MemoryImage*)]+0]+44]
592810	Sexy::MemoryImage::GetRLAlphaData(ecx = MemoryImage* this)	eax = unsigned char* aRLAlphaData; ecx, edx		取得将内存贴图的像素集以游程编码（RL）压缩后的不透明度数据。		【虚函数】[[[(MemoryImage*)]+0]+48]
592A70	Sexy::MemoryImage::GetRLAdditiveData(NativeDisplay* theDisplay, ecx = MemoryImage* this)	eax = unsigned char* aRLAdditiveData; ;ecx, edx		根据本机显示器的像素格式数据，取得将内存贴图的原始不透明度数据以游程编码（RL）压缩后的叠加数据。		【虚函数】[[[(MemoryImage*)]+0]+4C]
592CA0	Sexy::MemoryImage::PurgeBits(ecx = MemoryImage* this)	eax, ecx, edx		清除贴图的像素数据。若贴图存在 D3D 纹理数据，则同时清除其颜色表数据。		【虚函数】[[[(MemoryImage*)]+0]+50]
592D20	Sexy::MemoryImage::DeleteSWBuffers(ecx = MemoryImage* this)	eax, ecx, edx		删除内存贴图软件绘制的相关缓冲区。		【虚函数】[[[(MemoryImage*)]+0]+54]
592D70	Sexy::MemoryImage::Delete3DBuffers(ecx = MemoryImage* this)	eax, ecx, edx		删除内存贴图硬件绘制的相关缓冲区。		【虚函数】[[[(MemoryImage*)]+0]+58]
592D80	Sexy::MemoryImage::DeleteExtraBuffers(ecx = MemoryImage* this)	eax, ecx, edx		删除内存贴图软件和硬件绘制的相关缓冲区。		【虚函数】[[[(MemoryImage*)]+0]+5C]
592DA0	Sexy::MemoryImage::ReInit(ecx = DDImage* this)	eax, ecx, edx		重新初始化内存贴图，同时将贴图像素数据转化为调色板并清除像素（若需要）。		【虚函数】[[[(MemoryImage*)]+0]+60]
592DD0	Sexy::MemoryImage::DeleteNativeData(ecx = MemoryImage* this)	eax, ecx, edx		删除内存贴图的本机显示的数据。会先确保贴图至少存在像素或调色板的两者之一的数据。		【虚函数】[[[(MemoryImage*)]+0]+6C]
592E10	Sexy::MemoryImage::SetBits;(bool commitBits, int theHeight, int theWidth, unsigned long* theBits, ecx = MemoryImage* this)	eax, ecx, edx		设置贴图的宽度、高度及像素，并将贴图标记为像素已发生变化。;若指定了 commitBits，则立即重新确认并记录贴图中是否存在透明像素和是否需要不透明度通道。		【虚函数】[[[(MemoryImage*)]+0]+74]
592EE0	Sexy::MemoryImage::Create(int theHeight, int theWidth, ecx = MemoryImage* this)	eax, ecx, edx		生成指定大小的贴图。删除贴图的像素集，重置贴图的宽度和高度，然后标记为像素已变更。		【虚函数】[[[(MemoryImage*)]+0]+78]
592F20	Sexy::MemoryImage::GetBits(ecx = MemoryImage* this)	eax = unsigned long* aBits; ecx, edx		结合程序的绘制接口的颜色值信息，从贴图本地显示的数据中取得 argb 像素集以赋值 mBits 并返回。		【虚函数】[[[(MemoryImage*)]+0]+7C]
593100	Sexy::MemoryImage::FillRect;(int theDrawMode, const Color& theColor, const Rect& theRect, ecx = MemoryImage* this)	eax, ecx, edx		以指定的颜色和绘制模式填充一个矩形。		【虚函数】[[[(MemoryImage*)]+0]+8]
5932E0	Sexy::MemoryImage::ClearRect(const Rect& theRect, ecx = MemoryImage* this)	eax, ecx, edx		清除贴图中 theRect 矩形区域内的图像。		【虚函数】[[[(MemoryImage*)]+0]+10]
593350	Sexy::MemoryImage::Clear(ecx = MemoryImage* this)	eax, ecx, edx		将贴图的所有像素的值清零。		【虚函数】[[[(MemoryImage*)]+0]+70]
5933A0	Sexy::MemoryImage::AdditiveBlt(const Color& theColor, const Rect& theSrcRect, int theY, int theX, ;                               Image* theImage, ecx = MemoryImage* this)	eax, ecx, edx		以叠加模式在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(MemoryImage*)]+0]+A0]
593E70	Sexy::MemoryImage::NormalBlt(const Color& theColor, const Rect& theSrcRect, int theY, int theX, ;                             Image* theImage, ecx = MemoryImage* this)	eax, ecx, edx		以正常模式在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(MemoryImage*)]+0]+9C]
594CF0	Sexy::MemoryImage::Blt(int theDrawMode, const Color& theColor, const Rect& theSrcRect, ;                       int theY, int theX, Image* theImage, ecx = MemoryImage* this)	eax, ecx, edx		在 (theX, theY) 位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(MemoryImage*)]+0]+24]
594D60	Sexy::MemoryImage::BltF;(int theDrawMode, const Color& theColor, const Rect& theClipRect, const Rect& theSrcRect, ; int theY, int theX, Image* theImage, ecx = MemoryImage* this)	eax, ecx, edx		在 (theX, theY) 浮点位置处绘制 theImage 贴图的 theSrcRect 部分。		【虚函数】[[[(MemoryImage*)]+0]+3C]
594DB0	Sexy::MemoryImage::BltRotatedClipHelper;(double theRot, float theRotCenterY, float theRotCenterX,  _Out_ TRect<double>& theDestRect, ; const Rect& theClipRect, ebx = const Rect& theSrcRect, eax = float& theY, ecx = float& theX)	al = bool needToDraw; ecx, edx		计算贴图旋转绘制时，包含旋转后且经过 theClipRect 裁剪后的贴图的最小矩形区域，将其赋值给 theDestRect。;若旋转后贴图没有位于 theClipRect 内的部分，则返回 false 表示无需实际绘制。
595160	Sexy::MemoryImage::StretchBltClipHelper;(esi = _Out_ Rect& theDestRectOut, _Out_ TRect<double>& theSrcRectOut, ; ebx = const Rect& theDestRect, const Rect& theClipRect, const Rect& theSrcRect)	al = bool needToDraw; ecx, edx		计算贴图拉伸绘制时，拉伸后的贴图在经过 theClipRect 裁剪后，;其实际使用到的源区域矩形和实际绘制的目标区域矩形，并将其分别赋值给 theSrcRectOut 和 theDestRectOut。;若拉伸后贴图没有位于 theClipRect 内的部分，则返回 false 表示无需实际绘制。
595260	Sexy::MemoryImage::StretchBltMirrorClipHelper;(ebx = _Out_ Rect& theDestRectOut, _Out_ TRect<double>& theSrcRectOut, ; esi = const Rect& theDestRect, const Rect& theClipRect, const Rect& theSrcRect)	al = bool needToDraw; ecx, edx		计算贴图镜像拉伸绘制时，镜像且拉伸后的贴图在经过 theClipRect 裁剪后，;其实际使用到的源区域矩形和实际绘制的目标区域矩形，并将其分别赋值给 theSrcRectOut 和 theDestRectOut。;若镜像拉伸后贴图没有位于 theClipRect 内的部分，则返回 false 表示无需实际绘制。
595360	Sexy::MemoryImage::BltRotated(float theRotCenterY, float theRotCenterX, double theRot, int theDrawMode, ;                              const Color& theColor, const Rect& theClipRect, const Rect& theSrcRect, ;                              float theY, float theX, Image* theImage, ecx = MemoryImage* this)	eax, ecx, edx		绘制贴图绕屏幕坐标 (theRotCenterX, theRotCenterY) 处的一点旋转 theRot 弧度后的图像。		【虚函数】[[[(MemoryImage*)]+0]+2C]
597EA0	Sexy::MemoryImage::SlowStretchBlt;(const TRect<double>& theSrcRect, const Rect& theDestRect, Image* theImage, MemoryImage* this)	eax, ecx, edx		慢速拉伸的绘制。进行线性混合。
599310	Sexy::MemoryImage::FastStretchBlt(const Color& theColor, const TRect<double>& theSrcRect, ;                                  const Rect& theDestRect, eax = Image* theImage, MemoryImage* this)	eax, ecx, edx		快速拉伸的绘制。不进行线性混合且不支持白色以外的 theColor 实参值。
599520	Sexy::MemoryImage::StretchBlt(bool fastStretch, int theDrawMode, const Color& theColor, ;                              const Rect& theClipRect, const Rect& theSrcRectOrig, ;                              const Rect& theDestRectOrig, Image* theImage, ecx = MemoryImage* this)	eax, ecx, edx		将贴图的 theSrcRectOrig 区域拉伸填充 theDestRectOrig 区域，;且实际绘制的图像不会超越 theClipRect 区域。		【虚函数】[[[(MemoryImage*)]+0]+30]
5995C0	Sexy::MemoryImage::BltMatrixHelper;(bool blend, int thePixelFormat, int theBytePitch, void* theSurface, ; eax = const Rect& theSrcRect, const Color& theColor, const Rect& theClipRect, ; const SexyMatrix3& theMatrix, float y, float x, ecx = Image* theImage)	eax, ecx, edx		向 theSurface 绘制贴图 theImage 的 theSrcRect 区域经过 theMatrix 变换和 theClipRect 裁剪后的图像。;其中，要求 theImage 必须为可以通过 dynamic_cast 转化为 MemoryImage 类型的贴图。
5997E0	Sexy::MemoryImage::BltMatrix;(bool blend, const Rect& theSrcRect, int theDrawMode, const Color& theColor, const Rect& theClipRect, ; const SexyMatrix3& theMatrix, float y, float x, Image* theImage, ecx = MemoryImage* this)	eax, ecx, edx		在 (x, y) 位置绘制贴图 theImage 的 theSrcRect 部分经过矩阵 theMatrix 变换后的图像。;若 blend 为真，则会通过线性混合（观感上模糊）以缓解缩放产生的像素块，反之则清晰保留这些像素块。		【虚函数】[[[(MemoryImage*)]+0]+34]
599860	Sexy::MemoryImage::BltTrianglesTexHelper;(bool blend, float tx, float ty, int thePixelFormat, int theBytePitch, void* theSurface, ; int theDrawMode, const Color& theColor, const Rect& theClipRect, ecx = int theNumTriangles, ; const TriVertex theVertices[][3], eax = Image* theTexture)	eax, ecx, edx		以 theTexture 为纹理向 theSurface 的 (tx, ty) 偏移位置填充绘制 theNumTriangles 个三角形组成的图像。;其中，若 theTexture 无法通过 dynamic_cast 转化为 MemoryImage 类型，则在填充时不使用纹理贴图。
599970	Sexy::MemoryImage::FillScanLinesWithCoverage;(int theCoverHeight, int theCoverWidth, int theCoverY, int theCoverX, const unsigned char* theCoverage, ; int theDrawMode, const Color& theColor, int theSpanCount, Span* theSpans, ecx = MemoryImage* this)	eax, ecx, edx		指定一个不透明度值的数组 theCoverage，混合绘制 theSpanCount 条由 theSpans 指定的水平扫描线。;【详细注释请参考 [585B40]Sexy::DDImage::FillScanLinesWithCoverage 函数的注释】		【虚函数】[[[(MemoryImage*)]+0]+20]
599B00	Sexy::MemoryImage::BltTrianglesTex;(bool blend, float ty, float tx, int theDrawMode, const Color& theColor, const Rect& theClipRect, ; int theNumTriangles, const TriVertex theVertices[][3], Image* theTexture, ecx = MemoryImage* this)	eax, ecx, edx		以 theTexture 为纹理，在 (tx, ty) 偏移位置填充 theNumTriangles 个由 TriVertex[3] 指定的三角形区域。		【虚函数】[[[(MemoryImage*)]+0]+38]
599B80	Sexy::MemoryImage::Palletize(ecx = MemoryImage* this)	al = bool 是否成功; ecx, edx		将贴图的原始像素数据量化为 8 位调色板，以节省其占用的内存空间。		【虚函数】[[[(MemoryImage*)]+0]+88]
599C30	Sexy::SysFont::SysFont(bool underline, bool italics, bool bold, edx = int thePointSize, ;                       const std::string& theFace, eax = SysFont* this)	eax = *this; ecx, edx		初始化创建名为 theFace 的系统字体。需要一个大小为 0x20 的内存区域用于构造 this。
599C70	Sexy::SysFont::`scalar deleting destructor'(unsigned int flags, ecx = SysFont* this)	eax = *this; ecx, edx		删除系统字体，当 flags 的第 0 位置 1 时会额外释放系统字体本身占用的内存空间。		【虚函数】[[[(SysFont*)+0]+0]
599C90	Sexy::SysFont::SysFont;(int theScript, int thePointSize, edx = const std::string& theFace, SexyAppBase* theApp, eax = SysFont* this)	eax = *this; ecx, edx		初始化新系统字体基础数据。其中，script 表示使用的字符集，face 为使用的字体名称的字符串。;初始化过程中，默认不使用加粗、倾斜和下划线。需要一个大小为 0x20 的内存区域作为 SysFont。
599CC0	Sexy::SysFont::Init;(bool useDevCaps, bool underline, bool italics, cl = bool bold, int theScript, int thePointSize, ; const std::string& theFace, eax = SexyAppBase* theApp, esi = SysFont* this)	eax, ecx, edx		利用 CreateFontA 函数创建字体，存储新字体的信息，并设定系统字体的相关数据。
599DA0	Sexy::SysFont::SysFont(edi = const SysFont& theSysFont, esi = SysFont* this)	eax = *this; ecx, edx		复制 theSysFont 的数据以创建新系统字体。需要一个大小为 0x20 的内存区域作为 SysFont。
599E10	Sexy::SysFont::~SysFont(ecx = SysFont* this)	eax, edx		销毁系统字体。根据字体句柄，利用 DeleteObject 函数删除内存中的字体并释放相关的系统资源。
599E30	Sexy::SysFont::StringWidth(const std::string& theString, ecx = SysFont* this)	eax = int aWidth; ecx, edx		获取字符串在当前系统字体下的宽度。		【虚函数】[[[(SysFont*)]+0]+1C]
599EC0	Sexy::SysFont::DrawString(const Rect& theClipRect, const Color& theColor, const std::string& theString, ;                          int theY, int theX, Graphics* g, ecx = SysFont* this)	eax, ecx, edx		以指定的系统字体绘制字符串。		【虚函数】[[[(SysFont*)]+0]+28]
59A6E0	Sexy::SysFont::Duplicate(ecx = SysFont* this)	eax = SysFont* aFont; ecx, edx		复制自身的数据以创建新系统字体。		【虚函数】[[[(SysFont*)]+0]+2C]
59A700	Sexy::Quantize8Bit(unsigned long* theDestColorTable, edx = unsigned char* theDestColorIndices, ;                   int theHeight, int theWidth, ecx = const unsigned long* theSrcBits)	al = bool succeed; ecx, edx		将宽度为 theWidth、高度为 theHeight 的贴图的原始像素数据 theBits 量化为 8 位颜色表，;并将颜色表数据和颜色索引数据分别存储在 theDestColorTable 和 theDestColorIndices 指向的地址中。;其中 theDestColorTable 和 theDestColorIndices 的安全容量分别为 theWidth*theHeight 和 256。;当颜色值的数量（即颜色索引的数量）超过 256 个时，将视为量化失败，函数返回 false。
59A880	Sexy::SharedImage::SharedImage(eax = SharedImage* this)	eax = *this		初始化创建共享贴图。需要一个大小为 0x8 的内存区域用于构造 this。
59A890	Sexy::SharedImageRef::SharedImageRef;(edx = const SharedImageRef& theSharedImageRef, eax = SharedImageRef* this)	eax = *this; ecx		复制 theSharedImageRef 的数据以创建新共享贴图引用。需要一个大小为 0xC 的内存区域用于构造 this。
59A8B0	Sexy::SharedImageRef::SharedImageRef(eax = SharedImageRef* this)	eax = *this; ecx		初始化创建共享贴图引用。需要一个大小为 0xC 的内存区域用于构造 this。
59A8C0	Sexy::SharedImageRef::~SharedImageRef(esi = SharedImageRef* this)	eax, ecx, edx		【新增贴图·提取·步三】;销毁并释放共享贴图引用。内部直接跳转至59A8D0的函数。
59A8D0	Sexy::SharedImageRef::Release(esi = SharedImageRef* this)	eax, ecx, edx		释放共享贴图引用。删除自身的非共享贴图并减少 1 次共享贴图的引用计数。
59A920	Sexy::SharedImageRef::operator=(const SharedImageRef& theSharedImageRef, eax = SharedImageRef* this)	eax = SharedImageRef& this; ecx, edx		共享贴图引用的赋值函数。先释放自身，然后将目标的共享贴图指针赋值给自身。;然后当目标共享贴图引用的共享贴图存在时，增加 1 次该共享贴图的引用计数。
59A940	Sexy::SharedImageRef::operator=(edi = SharedImage* theSharedImage, eax = SharedImageRef* this)	eax = SharedImageRef& this; ecx, edx		共享贴图引用的赋值函数。先释放自身，然后将指定的共享贴图作为自身的共享贴图并增加其引用计数。
59A960	Sexy::SharedImageRef::operator=(MemoryImage* theUnsharedImage, eax = SharedImageRef* this)	eax = SharedImageRef& this; ecx, edx		共享贴图引用的赋值函数。先释放自身，然后将指定的内存贴图作为自身的非共享贴图。
59A980	Sexy::SharedImageRef::operator Image*(ecx = SharedImageRef* this)	eax = Image* aImage		【新增贴图·提取·步二】;SharedImageRef 向 Image* 的强制类型转换。内部直接跳转至59A990的函数。
59A990	Sexy::SharedImageRef::operator MemoryImage*(ecx = SharedImageRef* this)	eax = MemoryImage* aImage		SharedImageRef 向 MemoryImage* 的类型转换。获取自身非共享的内存贴图。;当自身不存在非共享贴图时，跳转至59A9A0的函数尝试获取共享的 DDImage。若均不存在，则返回 0。
59A9A0	Sexy::SharedImageRef::operator DDImage*(eax = SharedImageRef* this)	eax = DDImage* aImage		SharedImageRef 向 DDImage* 的类型转换。获取自身共享的 DDImage 贴图。当不存在共享贴图时，返回 0。
59A9B0	GetD3D8AdapterInfo2(std::string& theDescription, ebx = std::string& theDriver, esi = GUID& theGUID)	al = bool succeed; ecx, edx	0x4	加载 d3d8.dll 并创建 D3D8 实例，然后从中获取显示适配器（即显卡）的标识符、驱动程序和描述符数据。
59AAB0	Sexy::GetD3D8AdapterInfo;(eax = std::string& theDescription, ecx = std::string& theDriver, esi = GUID& theGUID)	al = bool succeed; ecx, edx		获取 D3D8 显示适配器（即显卡）的标识符、驱动程序和描述符数据，;分别赋值给 theGUID、theDriver 和 theDescription。
59BF40	std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator::operator->;(esi = std::_Tree<std::_Tmap_traits<std::string, std::string>>::iterator* this)	eax = std::pair<std::string, std::string>* _Ptr; ;ecx, edx		字符串向字符串的映射容器的迭代器的成员访问运算符重载，返回指向该迭代器指示的项的指针。;若迭代器本身的值非法，则抛出错误。
59C280	std::_Tree<std::_Tset_traits<Sexy::DDImage*>>::~_Tree<std::_Tset_traits<Sexy::DDImage*>>;(eax = std::_Tree<std::_Tset_traits<Sexy::DDImage*>>* this)	eax, ecx, edx		销毁并释放 DDraw 贴图指针的集合红黑树。
59CFC0	std::_Tree<std::_Tmap_traits<char, CharData>>::~_Tree<std::_Tmap_traits<char, CharData>>;(eax = std::_Tree<std::_Tmap_traits<char, CharData>* this)	eax, ecx, edx		销毁并释放字符向字符数据的映射红黑树。
59D4F0	std::_Tree<std::_Tmap_traits<char, Rect>>::~_Tree<std::_Tmap_traits<char, Rect>>;(eax = std::_Tree<std::_Tmap_traits<char, Rect>* this)	eax, ecx, edx		销毁并释放字符向矩形的映射红黑树。
59E070	std::_Tree<std::_Tmap_traits<char, CharData>>::erase;(std::_Tree<std::_Tmap_traits<char, CharData>>::iterator _Last, ; std::_Tree<std::_Tmap_traits<char, CharData>>::iterator _First, ; _Out_ std::_Tree<std::_Tmap_traits<char, CharData>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<char, CharData>>* this)	eax = &&_Ret; ecx, edx		移除字符向字符数据的映射红黑树从 _First 至 _Last 之间的所有节点。
59F200	std::_Tree<std::_Tmap_traits<<char, int>>::_Buynode()	eax = _Node* _Pnode; ecx, edx		创建一个字符向整数的映射红黑树的节点，令该节点的子节点和父节点指针为空指针，并初始化该节点的颜色。
5A02D0	PointClipper<std::less<float>>::ClipPoints(VertexList& out, esi = VertexList& in, float clipVal, int n)	eax, ecx, edx		裁去由 in 表示的多边形的各条有向边中第 n 维坐标小于 clipVal 的部分（通常是左、上的溢出部分），;并将裁剪后需要保留的顶点及新产生的顶点保存到 out 列表中，且仍然保持多边形各边的有向性。
5A0360	PointClipper<std::greater_equal<float>>::ClipPoints(VertexList& out, esi = VertexList& in, float clipVal, int n)	eax, ecx, edx		裁去由 in 表示的多边形的各条有向边中第 n 维坐标大于等于 clipVal 的部分（通常是右、下的溢出部分），;并将裁剪后需要保留的顶点及新产生的顶点保存到 out 列表中，且仍然保持多边形各边的有向性。
5A03F0	D3DTestPixelConvert<unsigned long>(_DDSURFACEDESC2& theDesc, D3DTestImage& theImage)	eax, ecx, edx	0x8	根据表面描述数据 theDesc 将表面上的 32 位像素转化为 A8R8G8B8 的格式以复制到测试贴图 theImage 上。
5A0520	D3DTestPixelConvert<unsigned short>(_DDSURFACEDESC2& theDesc, D3DTestImage& theImage)	eax, ecx, edx	0x8	根据表面描述数据 theDesc 将表面上的 16 位像素转化为 A8R8G8B8 的格式以复制到测试贴图 theImage 上。
5A0890	std::_Allocate<std::_Tree_nod<std::_Tmap_traits<char, int>>::_Node>(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符向整数的映射容器的红黑树的节点所需要的内存空间，;单个节点占用的内存大小为 0x30。当 _Count 个节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
5A0AE0	PointClipper<std::less<float>>::ClipPoint(eax = VertexList& out, const _D3DTLVERTEX& v2, ;                                      edx = const _D3DTLVERTEX& v1, float clipVal, ecx = int n)	eax, ecx, edx		取多边形由顶点 v1 至 v2 的一条有向边，裁去其中第 n 维坐标小于 clipVal 的部分，;并将裁剪后需要保留的顶点及新产生的顶点加入到 out 列表中，且仍然保持该边的有向性。
5A0D00	PointClipper<std::greater_equal<float>>::ClipPoint(eax = VertexList& out, const _D3DTLVERTEX& v2, ;                                              edx = const _D3DTLVERTEX& v1, float clipVal, ecx = int n)	eax, ecx, edx		取多边形由顶点 v1 至 v2 的一条有向边，裁去其中第 n 维坐标大于等于 clipVal 的部分，;并将裁剪后需要保留的顶点及新产生的顶点加入到 out 列表中，且仍然保持该边的有向性。
5A1640	GetPakPtr_XMLParser()	eax = PakInterfaceBase*? aPak; ecx, edx		从 XMLParser 的资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
5A16E0	p_fopen_XMLParser(eax = const char* theFileName)	eax = PFILE*? pFile; ecx, edx		以二进制只读模式读取指定文件，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，失败则返回 0。;优先尝试通过资源包文件接口在 pak 资源包内读取文件，当无法获取接口时尝试直接读取文件。
5A1740	p_fclose_XMLParser(esi = PFILE* theFile)	eax = 0(成功) | -1(失败); ecx, edx		尝试通过资源包文件接口关闭文件，当无法获取接口时直接关闭文件流。同时释放 pFile 占用的内存空间。
5A1780	p_fseek_XMLParser(esi = int theOrigin, edi = PFILE* theFile)	eax = 0(成功) | 非零(失败); ecx, edx		设置资源包数据文件当前读取指针指向的位置。其中 theOrigin 的取值可参考 61D72B 的函数的说明。;优先尝试通过资源包文件接口操作读取指针，当无法获取接口时尝试直接操作文件流的读取指针。
5A17B0	p_ftell_XMLParser(esi = PFILE* theFile)	eax = int aOffset; ecx, edx		取得资源包数据文件当前读取指针指向的位置距离文件头的偏移量。;优先尝试通过资源包文件接口获取偏移量，当无法获取接口时尝试直接在文件流中获取偏移量。
5A17E0	p_fread_XMLParser(esi = PFILE* theFile, edi = int theCount, ebx = void* thePtr)	eax = int 实际完整读取的项数; ecx, edx		读取资源包数据文件中 theCount 字节的数据并解密，然后将解密后的数据写入 thePtr 指向的地址;优先尝试通过资源包文件接口读取数据，当无法获取接口时尝试直接从文件流中读取数据。
5A1810	p_fgetc_XMLParser(esi = PFILE* theFile)	eax = int aChar; ecx, edx		从资源包数据文件中读取一个字符;优先尝试通过资源包文件接口读取字符，当无法获取接口时尝试直接从文件流中读取字符。
5A1840	p_unget_XMLParser(esi = PFILE* theFile, edi = int theChar)	eax = int aChar(成功) | -1(失败); ecx, edx		撤销从资源包数据文件中读取的一个字符，回退读取指针;优先尝试通过资源包文件接口读取字符，当无法获取接口时尝试直接从文件流中读取字符。
5A1870	p_feof_XMLParser(esi = PFILE* theFile)	eax = int aResult; ecx, edx		判断资源包数据文件是否已经读取至文件尾，若返回 0 则表示读取未结束，非 0 则表示读取结束;优先尝试通过资源包文件接口进行判断，当无法获取接口时尝试直接对文件流进行判断。
5A18A0	Sexy::XMLParser::XMLParser(eax = XMLParser* this)	eax = *this; ecx, edx		初始化创建 XML 解析器。需要一个大小为 0x7C 的内存区域用于构造 this。
5A18E0	Sexy::XMLParser::`scalar deleting destructor'(unsigned int flags, ecx = XMLParser* this)	eax = *this; ecx, edx		删除 XML 解析器，当 flags 的第 0 位置 1 时会额外释放 XML 解析器本身占用的内存空间。		【虚函数】[[[(XMLParser*)+0]+0]
5A1900	Sexy::XMLParser::~XMLParser(ecx = XMLParser* this)	eax, ecx, edx		销毁 XML 解析器。
5A1980	Sexy::XMLParser::Fail(ecx = const std::string& theErrorText, eax = XMLParser* this)	eax, ecx, edx		设置 XML 解析器失败，并设置失败的错误文本。
5A19A0	Sexy::XMLParser::Init(esi = XMLParser* this)	eax, ecx, edx		初始化 XML 解析器，并清除失败的记录。
5A19D0	Sexy::XMLParser::AddAttribute;(const std::string& theAttributeValue, ecx = const std::string& theAttributeKey, XMLElement* theElement)	al = bool succeed; ecx, edx		为 XML 元素 theElement 添加一个属性项和对应的属性值，若已有同名属性则返回 false。
5A1B20	Sexy::XMLParser::AddAttributeEncoded;(const std::string& theAttributeValue, ecx = const std::string& theAttributeKey, XMLElement* theElement)	al = bool succeed; ecx, edx		为 XML 元素 theElement 添加一个未解码的原始属性项和对应的属性值，若已有同名属性则返回 false。
5A1C80	Sexy::XMLParser::OpenFile(const std::string& theFileName, ecx = XMLParser* this)	al = bool succeed; ecx, edx		XML 解析器打开文件、确定文件编码，并进行初始化。		【虚函数】[[[(XMLParser*)+0]+8]
5A1D60	Sexy::XMLParser::NextElement(eax = XMLElement* theElement, ecx = XMLParser* this)	al = bool succeed; ecx, edx		读取下一个 XML 元素，并将该元素的相关数据写入到 theElement 中。
5A3560	Sexy::XMLParser::HasFailed(eax = XMLParser* this)	al = bool hasFailed; ecx, edx		判断 XML 解析器是否发生过读取失败。返回 mFailed 的值。
5A3570	Sexy::XMLParser::GetErrorText(esi = std::string&& anErrorText, eax = XMLParser* this)	eax = std::string&& anErrorText; ecx, edx		取得 XML 解析器失败时的错误文本。返回 mErrorText 的值。
5A35A0	Sexy::XMLParser::GetCurrentLineNum(eax = XMLParser* this)	eax = int aLineNum; ecx, edx		取得 XML 解析器当前读取到的行数。返回 mLineNum 的值。
5A35B0	Sexy::XMLParser::GetFileName(esi = std::string&& aFileName, eax = XMLParser* this)	eax = std::string&& aFileName; ecx, edx		取得 XML 解析器当前正在读取的文件名。返回 mFileName 的值。
5A35E0	Sexy::XMLParser::SetStringSource(const std::string& theErrorText, ecx = XMLParser* this)	eax, ecx, edx		对 XML 解析器进行初始化，并设定其读取的文本内容。		【虚函数】[[[(XMLParser*)+0]+14]
5A3600	Sexy::SexyMatrix3::LoadIdentity(eax = SexyMatrix3* this)	此函数不改变任何寄存器		将三阶矩阵加载为三阶单位矩阵：其 +0x0、+0x10、+0x20 三项为 1，其他全为 0。
5A3620	Sexy::SexyMatrix3::operator*;(eax = _Out_ SexyMatrix3&& aResult, edx = const SexyMatrix3& theMat, SexyMatrix3* this)	eax = SexyMatrix3&& aResult; ecx, edx		3 阶矩阵对 3 阶矩阵的乘法运算，计算 aResult = *this × theMat。
5A3690	Sexy::SexyMatrix3::operator*;(eax = _Out_ SexyVector2&& aResult, edx = const SexyVector2& theVec, ecx = SexyMatrix3* this)	eax = SexyVector2&& aResult		3 阶矩阵对二维向量（第三维扩展为 1）的乘法运算，计算向量在矩阵变换下得到的新向量。
5A36C0	Sexy::SexyMatrix3::operator*;(eax = _Out_ SexyVector3&& aResult, ecx = const SexyVector3& theVec, edx = SexyMatrix3* this)	eax = SexyVector3&& aResult		3 阶矩阵对三维向量的乘法运算，计算向量在矩阵变换下得到的新向量。
5A3710	Sexy::SexyTransform2D::SexyTransform2D(eax = SexyTransform2D* this)	eax = *this		初始化创建 2D 变换，将其初始化为一个三阶单位矩阵。需要一个大小为 0x24 的内存区域用于构造 this。
5A3720	Sexy::SexyTransform2D::operator=(edx = SexyMatrix3& theMat, eax = SexyTransform2D* this)	eax = SexyTransform2D& this; ecx, edx		3 阶矩阵对 2D 变换的赋值操作（*this = theMat）。
5A3730	Sexy::SexyTransform2D::Translate(float ty, float tx, esi = SexyTransform2D* this)	eax, ecx, edx		在当前 2D 变换的基础上额外叠加一个 (tx, ty) 的平移变换。
5A3770	Sexy::SexyTransform2D::RotateRad(float rot, esi = SexyTransform2D* this)	eax, ecx, edx		在当前 2D 变换的基础上额外叠加一个 rot 弧度的旋转变换。
5A37F0	Sexy::SexyTransform2D::Scale(float sy, float sx, esi = SexyTransform2D* this)	eax, ecx, edx		在当前 2D 变换的基础上额外叠加一个缩放变换，其中 sx 和 sy 分别为横向和纵向的缩放比例。
5A3830	Sexy::SEHCatcher::SEHCatcher()	eax = *this; ecx, edx		【对 gSEHCatcher(0x722848) 特化】初始化创建结构化异常处理器，;记录原先的未处理异常过滤器函数，并将未处理异常过滤器设定为自身的 UnhandledExceptionFilter 函数。
5A3850	Sexy::SEHCatcher::~SEHCatcher()	eax, ecx, edx		【对 gSEHCatcher(0x722848) 特化】销毁结构化异常处理器，恢复原先的未处理异常过滤器函数。
5A3860	Sexy::SEHCatcher::UnhandledExceptionFilter(EXCEPTION_POINTERS* lpExceptPtr)	eax = 0; ecx, edx		结构化异常发生后，触发程序的 SEHOccured 事件函数，然后对异常消息进行解析和处理。
5A38A0	Sexy::SEHCatcher::LoadImageHelp()	al = bool succeed; ecx, edx		加载 IMAGEHLP.DLL 并从中获取部分后续需要用到的函数的地址，然后初始化进程的符号处理程序。
5A3A60	Sexy::SEHCatcher::UnloadImageHelp()	eax, ecx, edx		释放 IMAGEHLP 模块（若已加载）。
5A3A80	StrToLongHex(ebx = unsigned long* theValue, edi = const std::string& aString)	al = bool succeed; ecx, edx		将表示十六进制数字的字符串 aString 转化为数字存储在 [theValue] 中。;转化过程中，若遇到对于十六进制数不合法的字符，则立即停止转化并返回 false。
5A3B00	Sexy::SEHCatcher::GetSymbolsFromMapFile(std::string& theDebugDump)	eax, ecx, edx	0x4	读取并解析工作目录下的 .map 符号文件，从中提取各函数的地址与其符号、所在源文件、所在行数的对应关系。;然后，依据这些对应关系，将 theDebugDump 中的函数地址信息替换为函数符号信息和函数在源码中的定位。
5A46E0	std::_Tree<std::_Tmap_traits<std::pair<unsigned long, unsigned long>, std::string>>::;     ~_Tree<std::_Tmap_traits<std::pair<unsigned long, unsigned long>, std::string>>;(eax = std::_Tree<std::_Tmap_traits<std::pair<unsigned long, unsigned long>, std::string>>* this)	eax, ecx, edx		销毁并释放无符号长整数与无符号长整数的对组向字符串的映射红黑树。
5A4720	std::_Tree<std::_Tmap_traits<std::pair<unsigned long, unsigned long>, std::pair<std::string, int>>>::;     ~_Tree<std::_Tmap_traits<std::pair<unsigned long, unsigned long>, std::pair<std::string, int>>>;(eax = std::_Tree<std::_Tmap_traits<std::pair<unsigned long, unsigned long>, std::pair<std::string, int>>>* this)	eax, ecx, edx		销毁并释放无符号长整数与无符号长整数的对组向字符串与整数的对组的映射红黑树。
5A4760	Sexy::SEHCatcher::DoHandleDebugEvent(EXCEPTION_POINTERS* lpEP)	eax, ecx, edx	0x4	解析异常消息，生成包含异常信息的调试转储字符串，并以该字符串执行弹出“Fatal Error”弹窗。
5A4F80	Sexy::SEHCatcher::IntelWalk(_CONTEXT* theContext, edi = _Out_ std::string&& aDebugDump)	eax = std::string&& aDebugDump; ecx, edx	0x4	尝试直接根据 theContext 中的栈帧指针进行堆栈跟踪，并生成跟踪过程的文本。
5A5160	Sexy::SEHCatcher::ImageHelpWalk(ecx = _CONTEXT* theContext, edi = _Out_ std::string&& aDebugDump)	eax = std::string&& aDebugDump; ecx, edx		尝试借助 ImageHelp 进行堆栈跟踪并生成跟踪过程的文本。
5A5580	Sexy::SEHCatcher::GetLogicalAddress;(unsigned long& offset, unsigned long& section, unsigned long len, char* szModule, eax = void* addr)	al = bool succeed; ecx, edx	0x10	根据给定的逻辑地址 addr，取得该地址所在的模块的文件名、该地址所在的区段、该地址在区段内的偏移值，;并将文件名写入 szModule 指向的地址（最多写入 len 字节）、区段号赋值给 section、偏移值赋值给 offset。
5A5630	Sexy::SEHCatcher::GetFilename(eax = const std::string& thePath, ecx = _Out_ std::string&& aFilename)	eax = std::string&& aFilename; ecx, edx		从文件的完整路径中提取单独的文件名。例如从 C:/a/b.txt 中得到 b.txt。
5A56C0	SEHProgressWindowProc(LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd)	eax = long lResult; ecx, edx		提交过程窗口的窗口处理函数。等待数据传输结束后标记退出或失败时弹出重试弹窗。
5A58A0	CreateProgressWindow()	eax, ecx, edx		创建并显示提交过程的窗口（Submitting Report）。
5A5A20	Sexy::SEHCatcher::SEHWindowProc(LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd)	eax = long lResult; ecx, edx		异常消息窗口（Fatal Error!）的窗口处理函数。等待用户按下提交、关闭或调试按钮后执行相应的处理。
5A5AD0	Sexy::SEHCatcher::SubmitInfoWindowProc(LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd)	eax = long lResult; ecx, edx		异常提交窗口的窗口处理函数。等待用户按下继续按钮时创建提交线程，或按下终止按钮时标记退出。
5A5BD0	Sexy::SEHCatcher::WriteToFile(ecx = const std::string& theErrorText)	eax, ecx, edx		将异常信息 theErrorText 写入 crash.txt 文件中。
5A5C90	Sexy::SEHCatcher::SubmitReportThread(void* theArg)	eax, ecx, edx	0x4	异常提交线程的处理，生成报告内容及发送请求的字符串，并向服务器发送该请求。
5A6E90	Sexy::SEHCatcher::ShowSubmitInfoDialog()	eax, ecx, edx		创建并显示提交异常信息的窗口（Error Details）。
5A7170	Sexy::SEHCatcher::ShowErrorDialog(ecx = const std::string& theErrorText, const std::string& theErrorTitle)	eax, ecx, edx	0x4	记录异常的标题和内容，创建并显示异常消息的窗口（Fatal Error!），并在关闭前进行消息处理的循环。
5A7580	Sexy::SEHCatcher::GetSysInfo(_Out_ std::string&& aDebugDump)	eax = std::string&& aDebugDump; ecx, edx	0x4	获取当前操作系统的版本信息和本程序使用的 DDraw 和 DSound 的版本号，返回用于显示这些信息的字符串。
5A7A10	Sexy::PropertiesParser::PropertiesParser(edx = SexyAppBase* theApp, eax = PropertiesParser* this)	eax = *this; ecx, edx		初始化创建属性文件解析器。需要一个大小为 0x2C 的内存区域用于构造 this。
5A7A30	Sexy::PropertiesParser::`scalar deleting destructor'(unsigned int flags, ecx = PropertiesParser* this)	eax = *this; ecx, edx		删除属性文件解析器，当 flags 的第 0 位置 1 时会额外释放解析器本身占用的内存空间。		【虚函数】[[[(PropertiesParser*)]+0]+4]
5A7A50	Sexy::PropertiesParser::Fail(const std::string& theErrorText, edi = PropertiesParser* this)	eax, ecx, edx		属性文件解析器失败，记录错误内容文本（theErrorText）、错误发生的行数和文件（若存在）。
5A7BB0	Sexy::Propertiesparser::~PropertiesParser(ecx = PropertiesParser* this)	eax, ecx, edx		销毁属性文件解析器，释放错误内容字符串。
5A7BE0	Sexy::PropertiesParser::ParseSingleElement(ecx = std::string* aString, PropertiesParser* this)	al = bool succeed; ecx, edx		解析下一项属性，并将属性的值以字符串的形式存储在 *aString 中。
5A7DC0	Sexy::PropertiesParser::ParseStringArray;(ecx = std::vector<std::string>* theStringVector, PropertiesParser* this)	al = bool succeed; ecx, edx		解析下一个字符串数组，并将解析得到的每一个字符串依次存储在 *theStringVector 中。
5A8140	Sexy::PropertiesParser::ParseProperties(PropertiesParser* this)	al = bool succeed; ecx, edx		分别解析每一项具体的属性的类型、名称和值，并将名称和值配对地加入到程序相应类型的属性容器中。
5A8DA0	Sexy::PropertiesParser::DoParseProperties(PropertiesParser* this)	al = bool succeed; ecx, edx		属性文件解析器解析当前文件或文本的大框架，确认是属性文件或文本后，调用具体的解析过程。;解析完成后，记录解析过程中发生的错误（若有），然后删除自身解析过程中使用的 XML 解析器。
5A9060	Sexy::PropertiesParser::ParsePropertiesBuffer(const Buffer& theBuffer, esi = PropertiesParser* this)	al = bool succeed; ecx, edx		属性文件解析器解析包含属性文本的缓冲区：创建 XML 解析器，将缓冲区中的内容赋予之，然后开始解析。
5A9120	Sexy::PropertiesParser::GetErrorText(esi = _Out_ std::string&& anErrorText, eax = PropertiesParser* this)	eax = std::string&& anErrorText; ecx, edx		取得属性文件解析器失败时的错误文本。返回 mError 的值。
5A9150	CalcCPUSpeed()	eax = int aSpeedHz; ecx, edx		计算当前 CPU 速度（单位：赫兹）。
5A9230	Sexy::PerfTimer::PerfTimer(eax = PerfTimer* this)	eax = *this; ecx		创建性能计时器，重置各项记录数据。需要一个大小为 0x18 的内存区域用于构造 this。
5A9240	Sexy::PerfTimer::CalcDuration(esi = PerfTimer* this)	eax, ecx, edx		计算从开始计时至当前时刻经过的时间（单位：毫秒）并以双浮点的形式存储在计时器的 mDuration 变量中。
5A9290	Sexy::PerfTimer::Start(eax = PerfTimer* this)	eax, ecx, edx		性能计时器开始计时。
5A92A0	Sexy::PerfTimer::Stop()	eax, ecx, edx		【对 gFPSTimer(0x722830) 特化】性能计时器重新计算一次计时时长，然后停止计时。
5A92C0	Sexy::PerfTimer::GetDuration(eax = PerfTimer* this)	st(0) = aDuration; eax, ecx, edx		取得性能计时器记录的时长（单位：毫秒）。若计时器正在计时，则会先重新计算一次时长。
5A92E0	Sexy::PerfTimer::GetCPUSpeed(eax = PerfTimer* this)	eax = int aSpeedHz; ecx, edx		计算并取得当前 CPU 速度（单位：赫兹）。取得的结果值至少为 1。
5A9330	InsertPerfRecord(PerfRecord& theRecord)	eax, ecx, edx		如果是开始性能记录：添加指定名称的性能信息，增加其 1 次开始计数，首次开始时额外记录开始时间。;如果是结束性能记录：减少 1 次指定名称的性能信息的开始计数，当计数归零时记录其持续时长和最大持续时长。
5A9480	CollatePerfRecords()	eax, ecx, edx		整理性能记录，将当前缓存的所有性能记录应用到性能信息集合的相应数据中，并记录整理用时。
5A9540	Sexy::SexyPerf::IsPerfOn()	al = bool isPerfOn		判断 SexyPerf 当前是否正在进行性能记录。返回 gPerfOn 的值。
5A9550	Sexy::SexyPerf::BeginPerf()	eax, ecx, edx		开始 SexyPerf 的性能记录，重置旧有数据，并记录当前时间（CPU 时间戳计数器的当前值）为开始时间。
5A95B0	Sexy::SexyPerf::EndPerf()	eax, ecx, edx		结束 SexyPerf 的性能记录，整理记录数据，记录总共的持续时长，并整理每一项性能信息的相关数据。
5A96B0	Sexy::SexyPerf::GetResults(ebx = _Out_ std::string&& aResult)	eax = std::string&& aResult; ecx, edx		在 SexyPerf 的性能记录结束后调用有效。取得本次性能记录的结果，包括总时长和各项性能信息的数据等。
5A9890	Sexy::MTRand::MTRand(ecx = unsigned long seed, eax = MTRand* this)	ecx = *this, edx		以 seed 种子创建一个包含 624 个无符号整数的伪随机数数组。当 seed 为 0 时，使用 4357 作为种子。;需要一个大小为 0x9C4 的内存区域用于构造 this。此函数内部直接跳转至5A98D0的函数。
5A98A0	Sexy::MTRand::MTRand()	ecx = *this, edx		【对 gMTRand(0x75A910) 特化】以 4357 为种子初始化伪随机数数组。
5A98B0	Sexy::MTRand::SetRandAllowed(bool allowed)	此函数不改变任何寄存器	0x4	设置全局是否允许随机。根据 allowed 参数的值执行增加或减少 1 次禁用随机的请求计数，;当禁用随机的请求计数大于 0 时，在 DEBUG 编译下的版本中，调用取随机数相关函数时会报错。
5A98D0	Sexy::MTRand::SRand(ecx = unsigned long seed, eax = MTRand* this)	eax, ecx, edx		以 seed 初始化 MTRand 的伪随机数数组。其中 mt[0] = seed，mti 从 1 循环至 624（不含）的过程中：;mt[mti] = 1812433253 * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti。其中“^”表示异或运算。
5A9930	Sexy::MTRand::Next()	eax = unsigned long aRandVal; ecx, edx		【对 gMTRand(0x75A910) 特化】根据 gMTRand 中的下一个数计算一个伪随机的数值。
5A9940	Sexy::MTRand::NextNoAssert(edx = MTRand* this)	eax = unsigned long aRandVal; ecx, edx		根据 MTRand 数组中的下一个数计算一个伪随机的数值。首次调用或已取遍数组的所有项时会先重置数组。
5A9A40	Sexy::MTRand::NextNoAssert(unsigned long range, edx = MTRand* this)	eax = unsigned long aRandVal; ecx, edx		根据 MTRand 数组中的下一个数计算一个 [0, range) 区间的随机整数。
5A9A50	Sexy::MTRand::Next(eax = unsigned long range, edx = MTRand* this)	eax = unsigned long aRandVal; ecx, edx		根据 MTRand 数组中的下一个数计算一个 [0, range) 区间的随机整数。
5A9A60	Sexy::MTRand::NextNoAssert(float range)	st(0) = aRandVal; eax, ecx		【对 gMTRand(0x75A910) 特化】根据 gMTRand 中的下一个数计算一个 [0, range) 区间的随机浮点数。
5A9AA0	Sexy::MTRand::Next(float range)	st(0) = aRandVal; eax, ecx		【对 gMTRand(0x75A910) 特化】根据 gMTRand 中的下一个数计算一个 [0, range) 区间的随机浮点数。
5A9AB0	Sexy::GetKeyCodeFromName(ecx = const string& theKeyName)	eax = KeyCode aKeyCode; ecx, edx		由按键的名称取得对应的按键编码。
5A9BD0	Sexy::InternetManager::InternetManager(InternetManager* this)	eax = *this; ecx, edx		初始化创建网络广告管理器。需要一个大小为 0x54C 的内存区域用于构造 this。
5A9CB0	Sexy::InternetManager::`scalar deleting destructor'(unsigned int flags, ecx = InternetManager* this)	eax = *this; ecx, edx		删除网络广告管理器，当 flags 的第 0 位置 1 时会额外释放管理器本身占用的内存空间。		【虚函数】[[[(InternetManager*)]+0]+4]
5A9CD0	Sexy::InternetManager::~InternetManager(ecx = InternetManager* this)	eax, ecx, edx		销毁网络广告管理器，保存广告列表到文件。
5A9DD0	Sexy::InternetManager::Init(esi = InternetManager* this)	eax, ecx, edx		初始化网络广告管理器，从文件加载广告列表。
5A9DE0	Sexy::InternetManager::FindAdInstanceInList;(const AdInstance& theAdInstance, std::list<AdInstance>& theAdInstanceList)	eax = AdInstance*? anAdInstance; ecx, edx		在 theAdInstanceList 中寻找与 theAdInstance 使用相同资源文件的广告实例，若未找到则返回空指针。;此函数用于判断指定广告实例是否位于指定列表中，或用于在另一列表中寻找与某列表中的当前广告相同的实例。
5A9E80	Sexy::InternetManager::ConfirmParsed(ebx = InternetManager* this)	al = bool parsed; ecx, edx		解析版本检查的超文本传输接收的返回内容，从中提取是否是最新版的逻辑值和更新网址，并解析各广告的数据。
5AA100	Sexy::Internetmanager::ParseAdLine;(bool isJustDownloaded, const std::string& theAdLine, ecx = InternetManager* this)	eax, ecx, edx		解析一行广告命令数据。其中参数 isJustDownloaded 表示该行是否来源于刚下载的广告。;对于弹出式广告，命令行格式为“popup (width) (height) | ... | (isNew) (remove)”;对于“更多游戏”广告，命令行格式为“more (url) (name) | ... | (isNew) (remove)”。;其中，省略号的部分表示若干个指示该广告需要的资源文件的名称的字符串，以空格分隔。		【虚函数】[[[(InternetManager*)]+0]+0]
5AA770	Sexy::AdInstance::~AdInstance(eax = AdInstance* this)	eax, ecx, edx		销毁广告实例，释放其名称、网址和资源文件名列表占用的内存空间。
5AA7D0	Sexy::InternetManager::EnsureSufficientMoreGamesAds(InternetManager* this)	eax, ecx, edx		尽可能确保实际展示用的广告列表中有足够多的“更多游戏”广告，且优先选择不重复的广告进行展示。
5AAD60	std::set<std::string, Sexy::StringLessNoCase>::~set<std::string, Sexy::StringLessNoCase>;(eax = std::set<std::string, Sexy::StringLessNoCase>* this)	eax, ecx, edx		销毁并释放字符串的集合容器。
5AAD70	Sexy::InternetManager::LoadAdList(esi = InternetManager* this)	al = bool loaded; ecx, edx		从 adlist.txt 中读取广告列表并解析每个广告的命令行，然后选取足够数量的“更多游戏”广告用于展示。
5AAEB0	Sexy::InternetManager::GenAdLine(std::string& theAdLine, ebx = AdInstance& theAdInstance)	eax, ecx, edx		根据广告实例的数据，生成相应的广告命令行赋值给 theAdLine。
5AB080	Sexy::InternetManager::SaveAdList(ecx = InternetManager* this)	al = bool saved; ecx, edx		选取足够数量的“更多游戏”广告用于展示，并依次生成这些广告相应的命令行，存储进 adlist.txt 中。
5AB200	Sexy::InternetManager::Update(ecx = InternetManager* this)	eax, ecx, edx		网络广告管理器更新 4 个文件传输，在广告下载完成后将广告内容缓存到本地文件，并开始下载广告需要的资源。
5AB5A0	Sexy::InternetManager::GetUpdateURL(esi = _Out_ std::string&& anUpdateURL, eax = InternetManager* this)	eax = std::string&& anUpdateURL; ecx, edx		如果成功接收并解析了版本检查的超文本传输的返回内容，则返回解析得到的更新网址，否则返回空字符串。
5AB600	Sexy::InternetManager::CheckAdResources(ebx = AdInstance& theAdInstance)	eax, ecx, edx		检查 theAdInstance 广告实例需要的全部资源文件是否均已下载完成（并相应地对该广告实例进行标记）。;特别地，当该广告实例不需要任何资源文件时，视为其未获得所有需要的资源。
5AB660	Sexy::InternetManager::CheckAdResources(eax = InternetManager* this)	eax, ecx, edx		检查当前展示用的广告列表中的所有广告是否均已获得其需要的所有资源文件，并相应地对这些广告实例进行标记。
5AB6B0	Sexy::InternetManager::HasNewAds(eax = InternetManager* this)	al = bool hasNewAds; ecx, edx		判断网络广告管理器是否有新的需要展示的弹出式广告（要求该广告实例已获得其需要的所有资源文件）。
5AB710	Sexy::InternetManager::TryShowAd(ecx = InternetManager* this)	eax, ecx, edx		挑选一个弹出式广告进行展示，优先挑选之前未展示过的广告实例。演示运行下，不会实际展示广告。
5ABA40	Sexy::HTTPTransfer::HTTPTransfer(ecx = HTTPTransfer* this)	eax = *this; ecx, edx		初始化创建超文本传输。需要一个大小为 0x100 的内存区域用于构造 this。
5ABAF0	Sexy::HTTPTransfer::`scalar deleting destructor'(unsigned int flags, ecx = HTTPTransfer* this)	eax = *this; ecx, edx		删除 HTTPTransfer 超文本传输，当 flags 的第 0 位置 1 时会额外释放超文本传输本身占用的内存空间。		【虚函数】[[[(HTTPTransfer*)]+0]+0]
5ABB10	Sexy::HTTPTransfer::~HTTPTransfer(ecx = HTTPTransfer* this)	eax, ecx, edx		销毁超文本传输，终止传输并等待传输线程执行结束。
5ABC60	Sexy::HTTPTransfer::GetAbsURL;(ebx = const std::string& theRelURL, ecx = const std::string& theBaseURL, _Out_ std::string&& aURL)	eax = std::string&& aURL; ecx, edx	0x4	由 theBaseURL 结合 theRelURL 得到绝对网址。若 theRelURL 为绝对网址，则直接返回 theRelURL;若 theRelURL 以 / 开头，则以 theRelURL 作为虚拟目录否则，以 theRelURL 作为文件名。;例如：由 theBaseURL = http://x.y.com/a/b 和 theRelURL = /m 的调用将返回 http://x.y.com/m。
5ABF00	Sexy::HTTPTransfer::Fail(ecx = int theResult, eax = HTTPTransfer* this)	此函数不改变任何寄存器		超文本传输失败，标记退出传输，并记录失败的原因 theResult。
5ABF10	Sexy::HTTPTransfer::SocketWait(bool checkWrite, bool checkRead, esi = HTTPTransfer* this)	al = bool succeed; ecx, edx		每隔 100 毫秒检查一次传输使用的 socket 的状态，直到发生异常或传输退出或取得需要的权限：;若指定 checkRead 则当 socket 取得读取权限时返回若指定 checkWrite 则当 socket 取得写入权限时返回。;因此，一般情况下参数 checkRead 和 checkWrite 应当有且仅有 1 个为真。;当 socket 发生异常时，返回 false当传输退出或成功取得需要的权限时，返回 true。
5AC020	Sexy::HTTPTransfer::GetThreadProc(ecx = HTTPTransfer* this)	eax, ecx, edx		超文本传输线程的处理。发送请求并接收返回内容。
5AC890	Sexy::HTTPTransfer::GetThreadProcStub(void* theArg)	eax, ecx, edx	0x4	传输线程的切入点，开始传输线程的处理。;其中，参数的 theArg 为开始线程时提供的参数，其值实际为超文本传输实例指针。
5AC8A0	Sexy::HTTPTransfer::PrepareTransfer(const std::string& theURL, edi = HTTPTransfer* this)	eax, ecx, edx		准备进行传输，根据指定的网址解析传输协议（proto）、域名（host）、端口（port）和虚拟目录（path）。
5ACB20	Sexy::HTTPTransfer::StartTransfer(eax = HTTPTransfer* this)	eax, ecx, edx		准备完成后，正式开始传输。特别地，在程序演示运行（Demo Playing）期间，不会实际启动传输。
5ACB60	Sexy::HTTPTransfer::GetHelper(const std::string& theURL, HTTPTransfer* this)	eax, ecx, edx		解析目标网址，格式化取得发送的请求的内容，然后开始传输。
5ACD10	Sexy::HTTPTransfer::Get;(ecx = const std::string& theRelURL, edi = const std::string& theBaseURL, esi = HTTPTransfer* this)	eax, ecx, edx		向 theBaseURL 下的 theRelURL 发送 GET 请求。
5ACDA0	Sexy::HTTPTransfer::SendRequestString(const std::string& theSendString)	eax, ecx, edx		【对 Sexy::SEHCatcher::mSubmitReportTransfer - Sexy::SEHCatcher::mSubmitHost 特化】;向 SEHCatcher::mSubmitHost 网址（服务器）发送 theSendString 请求字符串。
5ACDF0	Sexy::HTTPTransfer::Abort(eax = HTTPTransfer* this)	ecx		终止传输：标记传输的中断和退出。
5ACE00	Sexy::HTTPTransfer::Reset(eax = HTTPTransfer* this)	eax, ecx, edx		重置超文本传输，若当前传输线程正在处理中，则先终止传输并等待传输结束。
5ACE80	Sexy::HTTPTransfer::UpdateStatus(HTTPTransfer* this)	eax, ecx, edx		更新演示状态。在演示录制模式下保存传输结果数据，并在演示播放模式下加载记录的数据（如果可用）。
5AD070	Sexy::HTTPTransfer::WaitFor(esi = HTTPTransfer* this)	eax, ecx, edx		等待传输结束。等待传输线程处理完成，并在此期间每隔 20 毫秒更新一次演示状态。
5AD0A0	Sexy::HTTPTransfer::GetResultCode(esi = HTTPTransfer* this)	eax = int aResult; ecx, edx		立即更新一次演示状态，然后返回超文本传输的当前结果或状态（即 mResult 的值）。
5AD0B0	Sexy::HTTPTransfer::GetContent(esi = _Out_ std::string&& aContent, edi = HTTPTransfer* this)	eax = std::string&& aContent; ecx, edx		取得从服务器返回的内容文本。;调用时，若传输已完成，则立即更新一次演示状态，然后返回 mContent 的值否则，直接返回空字符串。
5AD110	Sexy::WininetHTTPTransfer::WininetHTTPTransfer(esi = WinInetHTTPTransfer* this)	eax = *this; ecx, edx		初始化创建互联网超文本传输，初始化读写文件用的临界区。需要一个大小为 0x1A4 的内存区域用于构造 this。
5AD210	Sexy::WininetHTTPTransfer::`scalar deleting destructor';(unsigned int flags, ecx = WinInetHTTPTransfer* this)	eax = *this; ecx, edx		删除互联网超文本传输，当 flags 的第 0 位置 1 时会额外释放超文本传输本身占用的内存空间。		【虚函数】[[[(WinInetHTTPTransfer*)]+0]+0]
5AD230	Sexy::WininetHTTPTransfer::~WininetHTTPTransfer(ecx = WinInetHTTPTransfer* this)	eax, ecx, edx		销毁互联网超文本传输，终止传输、等待传输线程执行结束并删除读写文件用的临界区。
5AD450	Sexy::WinInetHTTPTransfer::Get(edi = const std::string& theURL, esi = WinInetHTTPTransfer* this)	eax, ecx, edx		向 theURL 发送 GET 请求。
5AD480	Sexy::WinInetHTTPTransfer::Reset(edi = WinInetHTTPTransfer* this)	eax, ecx, edx		重置互联网超文本传输，若当前传输线程正在处理中，则先终止传输并等待传输结束。
5AD540	Sexy::WinInetHTTPTransfer::Abort(eax = WinInetHTTPTransfer* this)	ecx		终止传输：标记传输的中断和退出。
5AD550	Sexy::WinInetHTTPTransfer::WaitFor(esi = WinInetHTTPTransfer* this)	eax, ecx, edx		等待传输结束：每隔 1 毫秒检查一次传输线程是否处理完成。
5AD570	Sexy::WinInetHTTPTransfer::GetContent;(esi = _Out_ std::string&& aContent, ecx = WinInetHTTPTransfer* this)	eax = std::string&& aContent; ecx, edx		取得从服务器返回的内容文本。调用时，若传输未完成，则直接返回空字符串。若传输已完成，则：;若不使用文件，则返回 mContent 的值否则，从文件读二进制数据作为字符串（可能不以零为终止符）返回。
5AD710	Sexy::WinInetHTTPTransfer::TransferThreadProcStub(void* theArg)	eax, ecx, edx	0x4	传输线程的切入点，开始传输线程的处理。;其中，参数的 theArg 为开始线程时提供的参数，其值实际为互联网超文本传输实例指针。
5AD730	Sexy::WinInetHTTPTransfer::GetHelper(ecx = const std::string& theURL, eax = WinInetHTTPTransfer* this)	eax, ecx, edx		解析目标网址，初始化发送的请求的行为和协议等，然后开始传输。
5AD790	Sexy::WinInetHTTPTransfer::PrepareTransfer(ecx = const std::string& theURL, WinInetHTTPTransfer* this)	eax, ecx, edx		准备进行传输，根据指定的网址解析传输协议、域名、端口、虚拟目录、用户名和用户密码。
5ADC70	Sexy::WinInetHTTPTransfer::StartTransfer(esi = WinInetHTTPTransfer* this)	eax, ecx, edx		准备完成后，正式开始传输。
5ADCD0	Sexy::WinInetHTTPTransfer::TransferThreadProc(esi = WinInetHTTPTransfer* this)	eax, ecx, edx		互联网超文本传输线程的处理，发送请求并接收返回内容，将返回内容记录在 mContent 中。;如果指定使用文件接收返回内容，则直接将返回内容写入文件而不记录，且在传输完成后关闭文件流。
5AE170	Sexy::WinInetHTTPTransfer::Fail;(ecx = WinInetHTTPTransfer::EResult theResult, eax = WinInetHTTPTransfer* this)	eax, ecx, edx		互联网超文本传输失败，标记退出传输，并记录失败的原因 theResult。
5AE180	Sexy::GetDirectXErrorString(esi = _Out_ std::string&& anErrorStr, HRESULT theResult)	eax = std::string&& anErrorStr; ecx, edx		根据 DX 错误代码获取相应的错误字符串。
5AF0F0	SexyAllocMap::SexyAllocMap()	eax = *this; ecx, edx		【对 gSexyAllocMap(0x75A8E8) 特化】初始化并标记启用 gSexyAllocMap。
5AF140	SexyDumpUnfreed()	eax, ecx, edx		Debug 版本中用于在程序退出时检测未释放的内存，并将相关数据记录写入 mem_leaks.txt 文件中。;Beta 版（内测版）和 Final 版（正式版）中没有在每次申请和释放内存时进行记录，故此函数无实用。
5AF370	OutputDebug(..., const char* fmt)	eax, ecx, edx		将字符串 fmt 以额外参数格式化，并将格式化后的字符串发送给调试程序（若存在）以显示。;对于 Cheat Engine，当其调试器附加程序后，可在“查看内存->视图->调试字符串”中查看输出。
5AF3D0	Sexy::CritSect::CritSect(esi = CritSect* this)	eax = *this; ecx, edx		初始化创建临界区对象，初始化临界区。需要一个大小为 0x18 的内存区域用于构造 this。
5AF3E0	Sexy::CritSect::~CritSect(eax = CritSect* this)	eax, ecx, edx		销毁临界区对象，删除临界区。
5AF3F0	Sexy::Rand()	eax = int aRandVal; ecx, edx		取得一个随机整数返回给 eax。
5AF400	Sexy::Rand(eax = int range)	eax = int aRandVal; ecx, edx		取得一个 [0, range) 区间的随机整数返回给 eax。
5AF410	Sexy::Rand(float range)	st(0) = aRandVal; eax, ecx	0x4	取得一个 [0, range] 区间的随机浮点数存入 st(0)。
5AF420	Sexy::SRand(ecx = unsigned long theSeed)	eax, ecx, edx		以指定的种子 theSeed 初始化 gMTRand 数组。
5AF430	Sexy::CheckFor98Mill()	al = bool is98Mill; ecx, edx		判断当前操作系统是否为 Windows 95 或 Winsows 98 或 Windows ME。
5AF4E0	Sexy::CheckForVista()	al = bool isVista; ecx, edx		判断当前操作系统是否为 Windows Vista。
5AF590	Sexy::GetAppDataFolder(esi = _Out_ std::string&& aPath)	eax = std::string&& aPath; ecx, edx		取得游戏数据文件夹路径及名称。对于植物大战僵尸中文版原版，其返回的路径应为：;“C:\ProgramData\PopCap Games\PlantsVsZombies\”。
5AF5C0	Sexy::SetAppDataFolder(ecx = const std::string& thePath)	eax, ecx, edx		仅 Windows Vista 系统下可用，设置游戏数据文件夹路径。
5AF6C0	Sexy::URLEncode(const std::string& theString, ecx = _Out_ std::string&& aURL)	eax = std::string&& aURL; ecx, edx		将给定网址字符串 theString 转化为 URL 编码的网址。
5AF980	Sexy::StringToUpper(ebx = const std::string& theString, edi = _Out_ std::string&& aUpperString)	eax = std::string&& aUpperString; ecx, edx		将字符串转化为大写形式。
5AFA30	Sexy::StringToLower(ebx = const std::string& theString, edi = _Out_ std::string&& aLowerString)	eax = std::string&& aLowerString; ecx, edx		将字符串转化为小写形式。
5AFAE0	Sexy::StringToWString(ebx = const std::string& theString, esi = _Out_ std::wstring&& aWString)	eax = std::wstring&& aWString; ecx, edx		将 ASCII 编码的字符串转化为 Unicode 编码的宽字符串。此函数系列无法转换包含中文的字符串。
5AFBB0	Sexy::WStringToString(ebx = const std::wstring& theWString, edi = _Out_ std::string&& aString)	eax = std::string&& aString; ecx, edx		将 Unicode 编码的宽字符串转化为 ASCII 编码的字符串。此函数系列无法转换包含中文的字符串。
5AFC50	Sexy::SexyStringToString(const SexyString& theSString, esi = _Out_ std::string& aString)	eax = std::string&& aString; ecx, edx	0x4	将 SexyString 转化为 Ascii 编码的字符串。由于原版已采用 ASCII 编码，故此函数仅进行字符串复制。;SexyString：源码中，当定义了使用宽字符时，其等价于 std::wstring否则，其等价于 std::string。
5AFC80	Sexy::ToSexyString(ebx = const std::wstring& theWString, eax = _Out_ SexyString& aSString)	eax = SexyString&& aSString; ecx, edx		将 Unicode 编码的宽字符串转化为 SexyString。
5AFCA0	Sexy::ToWString(ebx = const SexyString& theSString, eax = _Out_ std::wstring& aWString)	eax = std::wstring&& aWString; ecx, edx		将 SexyString 转化为 Unicode 编码的宽字符串。
5AFCC0	Sexy::ToSexyString(eax = const std::string& theString, ecx = _Out_ SexyString& aSString)	eax = SexyString&& aSString; ecx, edx		将 Ascii 编码的字符串转化为 SexyString。
5AFCE0	Sexy::Trim(edi = const std::string& theString, eax = _Out_ std::string&& aResult)	eax = std::string&& aResult; ecx, edx		去除字符串开头和末尾的所有空白字符，返回去除后的新字符串。
5AFD80	Sexy::StringToInt(esi = int* theIntVal, const std::string theString)	al = bool 是否成功; ecx, edx	0x1C	将字符串转化为整数存储在 [theIntVal] 地址处，其中参数 theString 采用值传递。默认按照 10 进制转化，;若字符串以“0x”开头（负数则为以“-x”开头，其中“x”不区分大小写），则按照 16 进制转化。
5AFEE0	Sexy::StringToInt(esi = int* theIntVal, const std::wstring theString)	al = bool 是否成功; ecx, edx	0x1C	将 Unicode 编码的宽字符串转化为整数存储在 [theIntVal] 地址处，其中参数 theString 采用值传递。
5B0050	Sexy::StringToDouble(edi = double* theDoubleVal, const std::string theString)	al = bool 是否成功; ecx, edx	0x1C	将字符串转化为双浮点数存储在 [theDoubleVal] 地址处，其中参数 theString 采用值传递。
5B01B0	Sexy::SetNumberLocale(eax = const std::string& theLocaleString)	eax, ecx, edx	0x4	设置数字格式环境，用于在 Sexy::CommaSeperate 函数中使用符合本地化习惯的格式进行数字分隔。
5B0280	Sexy::CommaSeperate(ecx = int theVal, edx = _Out_ std::string&& aString)	eax = std::string&& aString; ecx, edx		将数值 theVal 转化为字符串，且按照当前环境的习惯进行分隔（默认为每 3 位数字之间使用“,”分隔）。
5B0430	Sexy::GetCurDir(esi = _Out_ std::string&& aDir)	eax = std::string&& aDir; ecx, edx		取得当前程序所在目录的绝对路径的字符串（路径最长为 256 字节）。
5B04B0	Sexy::GetFullPath(const std::string& theRelPath, edi = _Out_ std::string&& aFullPath)	eax = std::string&& aFullPath; ecx, edx	0x4	给定一个以当前目录为参考的相对路径 theRelPath，取得其对应的绝对路径。
5B0520	Sexy::GetPathFrom;(eax = const std::string& theDir, edx = const std::string& theRelPath, esi = _Out_ std::string&& aNewPath)	eax = std::string&& aNewPath; ecx, edx		取得从 theDir 目录经过 theRelPath 路径的目录。若 theRelPath 使用绝对路径，则直接返回 theRelPath;若 theRelPath 使用相对路径，则 theDir 即为其参考基础，最终结果使用的路径类型与 theDir 相同。;例如：由 theDir = C:/x/y 和 theRelPath = ../a.txt 的调用将返回 C:/x/a.txt。
5B0540	Sexy::Deltree(const std::string& thePath)	al = bool 是否成功; ecx, edx	0x4	删除 thePath 目录下的所有文件及 thePath 目录本身。
5B0820	Sexy::FileExists(const std::string& theFileName)	al = bool exists; ecx, edx	0x4	判断是否存在名为 theFileName 的文件。其中 theFileName 可以使用绝对路径或以当前目录为参考的相对路径。
5B0890	Sexy::MkDir(const std::string& thePath)	eax, ecx, edx	0x4	根据指定的路径和目录名称创建新目录。
5B09B0	Sexy::GetFileName(eax = const std::string& thePath, esi = _Out_ std::string&& aFileName)	eax = std::string&& aFileName; ecx, edx		从完整文件路径 thePath 中提取文件名字符串。
5B09D0	Sexy::GetFileDir(eax = const std::string& thePath, esi = _Out_ std::string&& aFileDir)	eax = std::string&& aFileDir; ecx, edx		从完整文件路径 thePath 中提取文件所在目录字符串。
5B09F0	Sexy::RemoveTrailingSlash(edi = const std::string& theDirectory, eax = _Out_ std::string&& aDir)	eax = std::string&& aDir; ecx, edx		若目录字符串 theDirectory 结尾存在斜杠或反斜杠，则删除该斜杠或反斜杠，返回删除后的新字符串。
5B0A80	Sexy::AddTrailingSlash(edi = const std::string& theDirectory, eax = _Out_ std::string&& aDir)	eax = std::string&& aDir; ecx, edx		若目录字符串 theDirectory 结尾不存在斜杠和反斜杠，则向其结尾添加一个反斜杠，返回添加后的新字符串。
5B0B10	Sexy::vformat(va_list argPtr, const char* fmt, _Out_ std::string&& result)	eax = std::string&& result; ecx, edx		根据给定的格式字符串和参数列表，格式化字符串。
5B0CA0	Sexy::StrFormat(..., const char* fmt, esi = _Out_ std::string&& result)	eax = std::string&& result; ecx, edx	0x4;(+N)	将字符串以给定的格式输出，其中所有额外参数以入栈逆序依次从头部至尾部地替换字符串中的特殊字符。;常用的特殊字符包括：%s(字符串)%d(数字)%Xd(数字补零至X位)%.Xf(保留X位小数)%%(百分号)等。
5B0CC0	Sexy::Evaluate(ecx = const std::map<std::string, std::string>& theDefinesMap, ;               const std::string& theString, _Out_ std::string&& anEvaluatedString)	eax = std::string&& anEvaluatedString; ;ecx, edx	0x8	将 HTML 语言的字符串 theString 中所有以一对百分号包裹的部分替换为其在 theDefinesMap 中对应的内容。;对于 theDefinesMap 中未定义的内容，将其直接移除。;例如，若 theDefinesMap 中有定义 { name, abc }，则 Hi %name%! 经过该函数将得到 Hi abc!。
5B11A0	Sexy::XMLDecodeString(edx = const std::string& theString, ecx = _Out_ std::string&& aNewString)	eax = std::string&& aNewString; ecx, edx		将 XML 语言的字符串 theString 解码为常规字符串，即：将其中的所有转移序列替换为相应的原字符。
5B1460	Sexy::XMLDecodeString(edx = const std::wstring& theString, ecx = _Out_ std::wstring&& aNewString)	eax = std::wstring&& aNewString; ecx, edx		将 XML 语言的宽字符串 theString 解码为常规字符串，即：将其中的所有转移序列替换为相应的原字符。
5B1710	Sexy::Upper(const std::string& _data, esi = _Out_ std::string&& s)	eax = std::string&& s; ecx, edx		将字符串 _data 中的所有字符转换为大写形式。
5B1800	Sexy::StrFindNoCase(const char* theFind, const char* theStr)	eax = int anIdx; ecx, edx		不区分大小写地寻找 theFind 字符串在 theStr 字符串中的位置，若未找到则返回 -1。
5B18B0	Sexy::BetaSupport::BetaSupport(SexyApp* theApp, BetaSupport* this)	eax = *this; ecx		初始化创建内测支持系统。需要一个大小为 0x250 的内存区域用于构造 this。
5B1A50	Sexy::BetaSupport::`scalar deleting destructor'(unsigned int flags, ecx = BetaSupport* this)	eax = *this; ecx, edx		删除内测支持系统，当 flags 的第 0 位置 1 时会额外释放内测支持系统本身占用的内存空间。		【虚函数】[[[(BetaSupport*)+0]+0]
5B1A70	Sexy::BetaSupport::~BetaSupport(ecx = BetaSupport* this)	eax, ecx, edx		销毁内测支持系统，释放使用的字体并等待对话结束。
5B1BC0	Sexy::BetaSupport::PositionDialog(ebx = HWND theHwnd)	eax, ecx, edx		将 theHwnd 窗口移动至屏幕正中央。
5B1C40	Sexy::BetaSupport::WaitForDialogClose(esi = BetaSupport* this)	eax, ecx, edx		进行窗口消息处理循环，直到当前正在进行的对话（此处即登录窗口或验证窗口）关闭。
5B1CB0	Sexy::BetaSupport::ValidateWindowProc(LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd)	eax = long lResult; ecx, edx		内测支持系统的验证窗口的窗口处理函数。等待数据传输结束后标记对话的关闭。
5B1E20	Sexy::BetaSupport::LoginWindowProc(LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd)	eax = long lResult; ecx, edx		内测支持系统的登录窗口的窗口处理函数。处理窗口的绘制并在关闭窗口或点击按钮时标记对话的关闭。
5B2040	Sexy::BetaSupport::ReadFromRegistry(esi = BetaSupport* this)	eax, ecx, edx		从注册表中读取记录的当前用户的用户名和密码数据（若存在记录）。
5B2170	Sexy::BetaSupport::WriteToRegistry(eax = BetaSupport* this)	eax, ecx, edx		将当前用户的用户名和密码数据记录到注册表中。
5B2230	Sexy::BetaSupport::GetBetaSiteDomainName(esi = _Out_ std::string&& aDomain, eax = BetaSupport* this)	eax = std::string&& aDomain; ecx, edx		取得宝开内测系统网站的域名。优先返回程序实例指定的域名，若未指定则返回 beta.popcap.com。
5B2280	Sexy::BetaSupport::GetLoginInfo(ecx = BetaSupport* this)	al = bool done; ecx, edx		获取登录信息。创建登录对话窗口，并等待登录对话关闭后，记录用户输入的用户名和密码。
5B25E0	Sexy::BetaSupport::ValidateWithServer(BetaSupport* this)	al = bool authorized; ecx, edx		向内测服务器验证登录信息，返回表示是否登录成功的逻辑值。;创建验证对话窗口，并等待对话关闭后，检查服务器返回的消息，并在验证失败时弹出相应的错误提示弹窗。
5B3800	Sexy::BetaSupport::Validate(esi = BetaSupport* this)	al = bool authorized; ecx, edx		内测资格验证：获取用户登录信息，并向内测服务器验证该信息。若验证成功，则额外将登录信息记录到注册表。
5B3870	Sexy::ResourceManager::SoundRes::`scalar deleting destructor';(unsigned int flags, ecx = ResourceManager::SoundRes* this)	eax = *this; ecx, edx		删除音效资源，当 flags 的第 0 位置 1 时会额外释放资源实例本身占用的内存空间。		【虚函数】[[[(ResourceManager::SoundRes*)]+0]+0]
5B3890	Sexy::ResourceManager::FontRes::`scalar deleting destructor';(unsigned int flags, ecx = ResourceManager::FontRes* this)	eax = *this; ecx, edx		删除字体资源，当 flags 的第 0 位置 1 时会额外释放资源实例本身占用的内存空间。		【虚函数】[[[(ResourceManager::FontRes*)]+0]+0]
5B38B0	Sexy::ResourceManager::FontRes::~FontRes(esi = ResourceManager::FontRes* this)	eax, ecx, edx		销毁字体资源，释放其贴图文件名和标签的字符串。
5B3920	Sexy::ResourceManagerException::ResourceManagerException;(const std::string& theWhat, ResourceManagerException* this)	eax = *this; ecx, edx		初始化创建资源管理器异常实例，并记录异常内容的字符串。需要一个大小为 0x28 的内存区域用于构造 this。
5B3990	Sexy::ResourceManager::ImageRes::DeleteResource(ecx = ResourceManager::ImageRes* this)	eax, ecx, edx		贴图资源释放其持有的资源内容：释放其共享贴图引用。		【虚函数】[[[(ResourceManager::ImageRes*)]+0]+4]
5B39A0	Sexy::ResourceManager::SoundRes::DeleteResource(ecx = ResourceManager::SoundRes* this)	eax, ecx, edx		音效资源释放其持有的资源内容：由程序的音效管理器释放其声音资源。		【虚函数】[[[(ResourceManager::SoundRes*)]+0]+4]
5B39D0	Sexy::ResourceManager::FontRes::DeleteResource(ecx = ResourceManager::FontRes* this)	eax, ecx, edx		字体资源释放其持有的资源内容：删除其字体实例和字体使用的贴图。		【虚函数】[[[(ResourceManager::FontRes*)]+0]+4]
5B3A10	Sexy::ResourceManager::ResourceManager(SexyAppBase* theApp, ResourceManager* this)	eax = *this; ecx, edx		初始化创建资源管理器，初始化其当前状态。需要一个大小为 0xCC 的内存区域用于构造 this。
5B3B80	Sexy::ResourceManager::`scalar deleting destructor'(unsigned int flags, ecx = ResourceManager* this)	eax = *this; ecx, edx		删除资源管理器，当 flags 的第 0 位置 1 时会额外释放资源管理器本身占用的内存空间。		【虚函数】[[[(ResourceManager*)]+0]+2C]
5B3BA0	std::map<std::string, Sexy::ResourceManager::BaseRes*>::~map<std::string, Sexy::ResourceManager::BaseRes*>;(eax = std::map<std::string, Sexy::ResourceManager::BaseRes*>* this)	eax, ecx, edx		销毁并释放字符串向基础资源指针的映射容器。
5B3BB0	std::map<std::string, std::list<Sexy::ResourceManager::BaseRes*>, Sexy::StringLessNoCase>::;     ~map<std::string, std::list<Sexy::ResourceManager::BaseRes*>, Sexy::StringLessNoCase>;(eax = std::map<std::string, std::list<Sexy::ResourceManager::BaseRes*>, Sexy::StringLessNoCase>* this)	eax, ecx, edx		销毁并释放字符串向基础资源指针链表的映射容器。
5B3BC0	Sexy::ResourceManager::~ResourceManager(ecx = ResourceManager* this)	eax, ecx, edx		销毁资源管理器，释放并删除其中的所有资源。
5B3D10	Sexy::ResourceManager::IsGroupLoaded(ebx = const std::string& theGroup, eax = ResourceManager* this)	al = bool isLoaded; ecx, edx		判断名为 theGroup 的一组游戏资源是否已被加载。
5B3D50	Sexy::ResourceManager::DeleteMap(eax = std::map<std::string, Sexy::ResourceManager::BaseRes*>& theMap)	eax, ecx, edx		释放资源容器 theMap 中的所有资源并删除资源实例，然后清空容器。
5B3E00	Sexy::ResourceManager::DeleteResources(const std::string& theGroup, ;                                       std::map<std::string, Sexy::ResourceManager::BaseRes*>& theMap, ;                                       ecx = ResourceManager* this)	eax, ecx, edx		释放资源容器 theMap 中所有属于 theGroup 组的资源。;若指定 theGroup 为空字符串，则释放 theMap 中的所有资源。		【虚函数】[[[(ResourceManager*)]+0]+1C]
5B3ED0	Sexy::ResourceManager::DeleteResources(const std::string& theGroup, ecx = ResourceManager* this)	eax, ecx, edx		释放属于 theGroup 组的所有贴图、音效和字体资源的内容，并移除该资源组（将该组重新视为未加载）。;若指定 theGroup 为空字符串，则释放所有资源组的所有资源的内容。		【虚函数】[[[(ResourceManager*)]+0]+18]
5B3F20	Sexy::ResourceManager::GetErrorText(esi = _Out_ std::string&& anErrorStr, eax = ResourceManager* this)	eax = std::string&& anErrorStr; ecx, edx		获取资源管理器中记录的错误原因的字符串（返回 mError 的值）。
5B3F50	Sexy::ResourceManager::HadError(eax = ResourceManager* this)	al = bool hadError		获取资源管理器对于是否发生错误的记录（返回 mHasFailed 的值）。
5B3F60	Sexy::ResourceManager::Fail(ecx = const std::string& theErrorText, ResourceManager* this)	al = 0; ecx, edx		资源管理器发生错误。记录错误的内容文本及发生错误时的文件名和行数。
5B41C0	Sexy::ResourceManager::ParseCommonResource;(std::map<std::string, Sexy::ResourceManager::BaseRes*>& theMap, ResourceManager::BaseRes* theRes, ; XMLElement& theElement, ecx = ResourceManager* this)	al = bool succeed; ecx, edx		根据描述该资源的 XML 元素 theElement 解析资源的通用数据并记录在 *theRes 中。;若解析成功，则额外将资源的 Id 及资源实例的指针 theRes 相对应地加入到资源容器 theMap 中。		【虚函数】[[[(ResourceManager*)]+0]+0]
5B46E0	std::map<std::string, std::string>::operator=;(eax = const std::map<std::string, std::string>& _Right, ecx = std::map<std::string, std::string>* this)	eax = std::map<std::string, std::string>& this; ;ecx, edx		清除字符串向字符串的映射容器自身的原有数据，并复制 _Right 的数据给自身，返回对赋值后的自身的引用。;若自身和 _Right 为同一对象，则不进行任何操作，直接返回对自身的引用。
5B4710	Sexy::ResourceManager::ParseSoundResource(XMLElement& theElement, ecx = ResourceManager* this)	al = bool succeed; ecx, edx		根据 theElement 解析一个音效资源的数据并将该资源实例加入到资源管理器自身的音效资源容器中。		【虚函数】[[[(ResourceManager*)]+0]+4]
5B49C0	ReadIntVector(eax = std::vector<int>& theVector, const std::string& theVal)	eax, ecx, edx	0x4	读取表示整数数组的字符串（形如“1,2,3,……”） theVal 并将解析的每个整数值依次存入 theVector 中。
5B4A90	Sexy::ResourceManager::ParseImageResource(XMLElement& theElement, ecx = ResourceManager* this)	al = bool succeed; ecx, edx		根据 theElement 解析一个贴图资源的数据并将该资源实例加入到资源管理器自身的贴图资源容器中。		【虚函数】[[[(ResourceManager*)]+0]+8]
5B5A00	Sexy::ResourceManager::ParseFontResource(XMLElement& theElement, ecx = ResourceManager* this)	al = bool succeed; ecx, edx		根据 theElement 解析一个字体资源的数据并将该资源实例加入到资源管理器自身的字体资源容器中。		【虚函数】[[[(ResourceManager*)]+0]+C]
5B6000	Sexy::ResourceManager::ParseSetDefaults(XMLElement& theElement, ecx = ResourceManager* this)	al = bool succeed; ecx, edx		根据 theElement 解析一个设置默认值（路径、标签前缀）的命令。		【虚函数】[[[(ResourceManager*)]+0]+10]
5B6280	Sexy::ResourceManager::ParseResources(ecx = ResourceManager* this)	al = bool succeed; ecx, edx		依次解析当前资源组中的每一项资源。		【虚函数】[[[(ResourceManager*)]+0]+14]
5B6700	Sexy::ResourceManager::DoParseResources(ResourceManager* this)	al = bool succeed; ecx, edx		依次解析资源描述文件中的每一个资源组。;解析完成后，记录解析过程中发生的错误（若有），然后删除自身解析过程中使用的 XML 解析器。
5B6A20	Sexy::ResourceManager::ParseResourcesFile(ecx = const std::string& theFilename, ResourceManager* this)	al = bool succeed; ecx, edx		解析资源描述文件：创建 XML 解析器，解析指定文件的大框架，确认是资源描述文件后，调用具体的解析过程。;当文件不以 ResourceManifest 标签开头时，也会尝试进行解析，但是会先产生一个错误。
5B6C60	Sexy::ResourceManager::LoadAlphaGridImage;(DDImage* theImage, ecx = ResourceManager::ImageRes* theRes, edx = ResourceManager* this)	al = bool succeed; ecx, edx		加载 theRes 指定的不透明度格子贴图，并以此调整 theDDImage 的各个像素的值。;不透明度格子贴图：与分份贴图一份的大小相同的贴图，依次按照不透明度贴图的处理方式处理原贴图的每一份。
5B6EA0	Sexy::ResourceManager::LoadAlphaImage;(DDImage* theImage, ecx = ResourceManager::ImageRes* theRes, ResourceManager* this)	al = bool succeed; ecx, edx		加载 theRes 指定的不透明度贴图，并以此调整 theDDImage 的各个像素的值。;不透明度贴图：与贴图一份的大小相同的贴图，以该贴图设置原贴图上每一像素的不透明度值。
5B7030	Sexy::ResourceManager::DoLoadImage(ResourceManager::ImageRes* theRes, ecx = ResourceManager* this)	al = bool loaded; ecx, edx		加载贴图资源，并加载该贴图资源需要的其他相关资源，同时对加载得到的贴图进行与资源描述相应的初始化。		【虚函数】[[[(ResourceManager*)]+0]+20]
5B7490	Sexy::ResourceManager::DeleteImage(ecx = const std::string& theName, eax = ResourceManager* this)	eax, ecx, edx		删除并释放标签为 theName 的贴图，同时将该标签对应的贴图指针以空指针替换。
5B74A0	Sexy::ResourceManager::LoadImageA;(_Out_ SharedImageRef&& aImage, ecx = const std::string& theName, ResourceManager* this)	eax = SharedImageRef&& aImage; ecx, edx		根据资源文件加载标签为 theName 的贴图资源，并返回该贴图资源对应的共享贴图引用。;若指定标签的贴图资源尚未加载，则立即执行加载过程。
5B7550	Sexy::ResourceManager::DoLoadSound(ResourceManager::SoundRes* theRes, ecx = ResourceManager* this)	al = bool loaded; ecx, edx		加载音效资源，同时由程序的音效管理器分配音效编号并对音效实例进行与资源描述相应的初始化。		【虚函数】[[[(ResourceManager*)]+0]+28]
5B76B0	Sexy::ResourceManager::DoLoadFont(ResourceManager::FontRes* theRes, ecx = ResourceManager* this)	al = bool loaded; ecx, edx		加载字体资源，同时对加载得到的字体进行与资源描述相应的初始化。		【虚函数】[[[(ResourceManager*)]+0]+24]
5B7C00	Sexy::ResouRceManager::LoadFont(ecx = const std::string& theName, ResourceManager* this)	eax = Font*? aFont; ecx, edx		若标签为 theName 的字体资源已加载，则直接返回已加载的字体指针否则，执行加载过程并返回加载结果。
5B7C80	Sexy::ResourceManager::LoadNextResource(ecx = ResourceManager* this)	al = bool 是否成功; ecx, edx		继续加载当前正在加载的一组游戏资源的下一个资源。返回“否”时表示加载失败或该组资源已加载完毕。		【虚函数】[[[(ResourceManager*)]+0]+30]
5B7DA0	Sexy::ResourceManager::StartLoadResources(const std::string& theGroup, ecx = ResourceManager* this)	eax, ecx, edx		资源管理器准备开始加载 theGroup 组的游戏资源，重置组名、资源组链表、迭代器等相关数据。		【虚函数】[[[(ResourceManager*)]+0]+38]
5B7E00	Sexy::ResourceManager::LoadResources(eax = const std::string& theGroup, ecx = ResourceManager* this)	al = bool 是否成功; ecx, edx		加载名为 theGroup 的一组游戏资源。		【虚函数】[[[(ResourceManager*)]+0]+3C]
5B7E70	Sexy::ResourceManager::GetNumResources;(std::map<std::string, Sexy::ResourceManager::BaseRes*>& theMap, const std::string& theGroup)	eax = int aCount; ecx, edx		取得资源容器 theMap 中属于 theGroup 组的资源的数量。;若指定 theGroup 为空字符串，则取得 theMap 中所有资源的总数量。
5B7F30	Sexy::ResourceManager::GetNumImages(ecx = const std::string& theGroup, eax = ResourceManager* this)	eax = int aCount; ecx, edx		取得 theGroup 资源组中贴图资源的数量。若 theGroup 为空字符串，则取得所有资源组中贴图资源的总数量。
5B7F40	Sexy::ResourceManager::GetNumSounds(ecx = const std::string& theGroup, eax = ResourceManager* this)	eax = int aCount; ecx, edx		取得 theGroup 资源组中音效资源的数量。若 theGroup 为空字符串，则取得所有资源组中音效资源的总数量。
5B7F50	Sexy::ResourceManager::GetNumFonts(ecx = const std::string& theGroup, eax = ResourceManager* this)	eax = int aCount; ecx, edx		取得 theGroup 资源组中字体资源的数量。若 theGroup 为空字符串，则取得所有资源组中字体资源的总数量。
5B7F60	Sexy::ResourceManager::GetNumResources(esi = const std::string& theGroup, edi = ResourceManager* this)	eax = int aCount; ecx, edx		取得 theGroup 组资源中所有资源的总数量。若 theGroup 为空字符串，则取得所有资源组中所有资源的总数量。
5B7F90	Sexy::ResourceManager::GetFont(ecx = const std::string& theId, eax = ResourceManager* this)	eax = Font*? aFont; ecx, edx		根据给定的字体资源编号 theId 寻找相应的字体资源，并返回字体的指针（未找到则返回空指针）。
5B8000	Sexy::ResourceManager::GetImageThrow;(const std::string& theId, _Out_ SharedImageRef&& anImage, ecx = ResourceManager* this)	eax = SharedImageRef&& anImage; ecx, edx		【新增贴图·提取·步一】;根据给定的贴图资源编号 theId 寻找相应的贴图资源，并返回其中的共享贴图引用。;当指定名称的贴图无法找到时，将弹出“Image resource not found: %s”并抛出相应的异常。		【虚函数】[[[(ResourceManager*)]+0]+40]
5B8170	Sexy::ResourceManagerException::~ResourceManagerException(ecx = ResourceManagerException* this)	eax = *this; ecx, edx		销毁资源管理器异常，释放异常内容的字符串。
5B81F0	Sexy::ResourceManager::GetSoundThrow(const std::string& theId, ecx = ResourceManager* this)	eax = int aSoundId; ecx, edx		根据给定的音效资源编号 theId 寻找相应的音效资源，并返回音效的编号（未找到允许，则返回 -1）。;当指定名称的音效无法找到时，将弹出“Sound resource not found: %s”并抛出相应的异常。		【虚函数】[[[(ResourceManager*)]+0]+44]
5B8330	Sexy::ResourceManager::GetFontThrow(const std::string& theId, ecx = ResourceManager* this)	eax = Font*? aFont; ecx, edx		根据给定的字体资源编号 theId 寻找相应的字体资源，并返回字体的指针（未找到且允许，则返回空指针）。;当指定名称的字体无法找到时，将弹出“Font resource not found: %s”并抛出相应的异常。		【虚函数】[[[(ResourceManager*)]+0]+48]
5B8470	Sexy::ResourceManager::ReplaceImage(ecx = const std::string& theId, eax = ResourceManager* this)	al = bool replaced; ecx, edx		释放 theId 对应的贴图资源，然后清除该资源持有的非共享的内存贴图。;若不存在编号为 theId 的贴图资源，则返回 false。
5B8510	Sexy::DataElement::DataElement(eax = DataElement* this)	此函数不改变任何寄存器		初始化基础数据元素。需要一个大小为 0x8 的内存区域用于构造 this。
5B8520	Sexy::DataElement::`scalar deleting destructor'(unsigned int flags, ecx = DataElement* this)	eax = *this; ecx, edx		删除基础数据元素，当 flags 的第 0 位置 1 时会额外释放数据元素本身占用的内存空间。		【虚函数】[[[(DataElement*)]+0]+0]
5B8540	Sexy::DataElement::~DataElement(ecx = DataElement* this)	eax, ecx, edx		销毁基础数据元素。
5B8550	Sexy::SingleDataElement::SingleDataElement(eax = SingleDataElement* this)	eax = *this; ecx, edx		初始化创建单一数据元素。需要一个大小为 0x28 的内存区域用于构造 this。
5B8580	Sexy::SingleDataElement::`scalar deleting destructor'(unsigned int flags, ecx = SingleDataElement* this)	eax = *this; ecx, edx		删除单一数据元素，当 flags 的第 0 位置 1 时会额外释放数据元素本身占用的内存空间。		【虚函数】[[[(SingleDataElement*)]+0]+0]
5B85A0	Sexy::SingleDataElement::SingleDataElement(const std::string& theString, SingleDataElement* this)	eax = *this; ecx, edx		初始化创建单一数据元素并设置其内容字符串。需要一个大小为 0x28 的内存区域用于构造 this。
5B8620	Sexy::SingleDataElement::~SingleDataElement(ecx = SingleDataElement* this)	eax, ecx, edx		销毁单一数据元素，释放其内容字符串。若其作为项（key）存在对应的值（value），则额外释放其值。
5B86B0	Sexy::SingleDataElement::Duplicate(ecx = SingleDataElement* this)	eax = DataElement* aDataElement; ecx, edx		深拷贝单一数据元素自身的数据，创建新的单一数据元素。		【虚函数】[[[(SingleDataElement*)]+0]+4]
5B8730	Sexy::SingleDataElement::SingleDataElement(edi = const SingleDataElement& __that, SingleDataElement* this)	eax = *this; ecx, edx		浅复制单一数据元素 __that 的数据以创建新单一数据元素。需要一个大小为 0x28 的内存区域用于构造 this。
5B87B0	Sexy::ListDataElement::ListDataElement(ListDataElement* this)	eax = *this; ecx, edx		初始化创建列表数据元素。需要一个大小为 0x18 的内存区域用于构造 this。
5B8800	Sexy::ListDataElement::`scalar deleting destructor'(unsigned int flags, ecx = ListDataElement* this)	eax = *this; ecx, edx		删除列表数据元素，当 flags 的第 0 位置 1 时会额外释放数据元素本身占用的内存空间。		【虚函数】[[[(ListDataElement*)]+0]+0]
5B8820	Sexy::ListDataElement::~ListDataElement(ecx = ListDataElement* this)	eax, ecx, edx		销毁列表数据元素，删除并释放其中的每一个元素。
5B88E0	Sexy::ListDataElement::ListDataElement;(edi = const ListDataElement theListDataElement, ListDataElement* this)	eax = *this; ecx, edx		复制列表数据元素 __that 的数据、深拷贝 __that 中的每一个元素给自身，以创建新列表数据元素。;需要一个大小为 0x18 的内存区域用于构造 this。
5B89A0	Sexy::ListDataElement::operator=(const ListDataElement theListDataElement, ListDataElement* this)	eax = ListDataElement& this; ecx, edx		列表数据元素的赋值运算符重载，以 theListDataElement 的数据赋值自身：;先释放并清空自身的原有数据，然后深拷贝 theListDataElement 中的每一个元素给自身。
5B8AF0	Sexy::ListDataElement::Duplicate(ecx = ListDataElement* this)	eax = DataElement* aDataElement; ecx, edx		深拷贝列表数据元素自身的数据，创建新的列表数据元素。		【虚函数】[[[(ListDataElement*)]+0]+4]
5B8B60	Sexy::DescParser::DescParser(DescParser* this)	eax = *this; ecx, edx		初始化创建描述符解析器。需要一个大小为 0x6C 的内存区域用于构造 this。
5B8C00	Sexy::DescParser::`scalar deleting destructor'(unsigned int flags, ecx = DescParser* this)	eax = *this; ecx, edx		删除描述符解析器，当 flags 的第 0 位置 1 时会额外释放解析器本身占用的内存空间。		【虚函数】[[[(DescParser*)]+0]+0]
5B8C20	Sexy::DescParser::~DescParser(ecx = DescParser* this)	eax, ecx, edx		销毁描述符解析器，释放其错误内容文本、当前行字符串和定义表等。
5B8CD0	Sexy::DescParser::Error(const std::string& theError, ecx = DescParser* this)	al = 0; ecx, edx		描述符解析器出错，若此前未记录任何错误内容，则记录 theError 作为错误内容。		【虚函数】[[[(DescParser*)]+0]+24]
5B8CF0	Sexy::DescParser::Dereference(const std::string& theString, ecx = DescParser* this)	eax = DataElement*? aDataElement; ecx, edx		以 theString 作为元素名称查找被定义为该名称的数据元素，若未找到则返回空指针。		【虚函数】[[[(DescParser*)]+0]+28]
5B8DD0	Sexy::DescParser::IsImmediate(eax = const std::string& theString)	al = bool isImmediate; ecx, edx		判断 theString 是否可能描述一个立即数据。立即数据：此处指整数或字符串的字面量。;判断的标准为：字符串 theString 是否以表示数字或正负号或单引号或双引号的字符开头。
5B8E40	Sexy::DescParser::Unquote;(edi = const std::string& theQuotedString, edx = _Out_ std::string&& aLiteralString)	eax = std::string&& aLiteralString; ;ecx, edx		从带引号的表示字符串字面量的字符串 theQuotedString 中提取字符串字面量的值，;若 theQuotedString 不以单引号或双引号开头，则直接返回 theQuotedString 的值。
5B9030	Sexy::DescParser::GetValues(ListDataElement* theValues, ListDataElement* theSource, ecx = DescParser* this)	al = bool succeed; ecx, edx		取 theSource 列表中的每一个元素的实际值，以这些值构建数据元素加入到 theValues 列表中。例如：;对于 theSource 中以引号包裹的字符串，提取其表示的字面量对于定义名，取定义为该名称的原数据元素。
5B9460	Sexy::DescParser::DataElementToString;(bool enclose, DataElement* theDataElement, _Out_ std::string&& aString)	eax = std::string&& aString; ecx, edx		将 theDataElement 数据元素转化为用于定义其的字符串形式。具体规则如下，递归进行：;(1)若 theDataElement 为列表数据元素，则罗列其中每一元素转化为的字符串，且;   当 enclose 为(真/假)时，字符串前后(以小括号包裹/无包裹)，每两个元素之间以(逗号/空格)分隔。;(2)若 theDataElement 为单一数据元素，且不存在对应的值，则直接返回 theDataElement 的内容字符串。;(3)若 theDataElement 为单一数据元素，且存在对应的值，则返回形如 (key)=(value) 的字符串。
5B96C0	Sexy::DescParser::DataToString;(std::string* theString, edx = DataElement* theSource, ecx = DescParser* this)	al = bool succeed; ecx, edx		取非键值对的单一数据元素 theSource 表示的字符串的字面量的值赋值给 *theString。;对于不符合要求的数据元素，将 *theString 赋值为空字符串并返回 false。
5B9800	Sexy::DescParser::DataToInt(int* theInt, edx = DataElement* theSource, ecx = DescParser* this)	al = bool succeed; ecx, edx		取非键值对的单一数据元素 theSource 表示的整数值赋值给 *theInt。;对于不符合要求的数据元素，将 *theInt 赋值为 0 并返回 false。
5B98F0	Sexy::DescParser::DataToStringVector;(edx = std::vector<std::string>* theStringVector, ecx = DataElement* theSource, DescParser* this)	al = bool succeed; ecx, edx		取 theSource 数据元素表示的列表中的每一个元素的实际值，;并将这些值直接以字符串的形式依次添加到 *theStringVector 中。
5B9C00	Sexy::DescParser::DataToList;(esi = ListDataElement* theValues, eax = DataElement* theSource, ecx = DescParser* this)	al = bool succeed; ecx, edx		取 theSource 数据元素表示的列表数据元素的实际值赋值给 *theValues。
5B9C40	Sexy::DescParser::DataToIntVector(std::vector<int>* theIntVector, DataElement* theSource, DescParser* this)	al = bool succeed; ecx, edx		取 theSource 数据元素表示的列表中的每一个元素的实际值，;并将这些值从字符串解析为整数值依次添加到 *theIntVector 中。
5B9DB0	Sexy::DescParser::DataToDoubleVector;(std::vector<double>* theDoubleVector, DataElement* theSource, DescParser* this)	al = bool succeed; ecx, edx		取 theSource 数据元素表示的列表中的每一个元素的实际值，;并将这些值从字符串解析为双浮点数值依次添加到 *theDoubleVector 中。
5B9F20	Sexy::DescParser::ParseToList(int* theStringPos = 0, bool expectedListEnd, ListDataElement* theList, ;                              const std::wstring& theString, ecx = DescParser* this)	al = bool succeed; ecx, edx		将一行描述符文本解析为若干个指令或参数的形式，每个指令或参数依次存储在 theList 列表数据元素中。其中：;参数 theStringPos 指向的值作为入参表示需要解析的起始位置，作为出参表示解析完成后的位置，;当 theStringPos 为空指针时，表示从文本的开头开始解析。;参数 expectedListEnd 表示是否期望以列表结尾，用于在进行递归的子过程中，对于列表数据元素的解析。
5BA2A0	Sexy::DescParser::ParseDescriptorLine(edx = const std::wstring& theDescriptorLine, esi = DescParser* this)	al = bool succeed; ecx, edx		解析一行描述符文本，并在确保是指令语句的情况下调用 HandleCommand 虚函数进行指令的处理。
5BA3C0	Sexy::DescParser::LoadDescriptor(const std::string& theFileName, ecx = DescParser* this)	al = bool succeed; ecx, edx		描述符解析器解析 theFileName 文件。		【虚函数】[[[(DescParser*)]+0]+30]
5BA7A0	Sexy::Ratio::Ratio(Ratio* this)	此函数不改变任何寄存器		初始化创建比例，将分子和分母均初始化为 1。需要一个大小为 0x8 的内存区域用于构造 this。
5BA7B0	Sexy::Ratio::Set(ebx = int theDenominator, int theNumerator, Ratio* this)	eax, ecx, edx		设置比例。实际赋值时会将 theNumerator : theDenominator 化为最简比的形式。
5BA7F0	Sexy::SexyCache::~SexyCache()	eax, ecx, edx		【对 gSexyCache(0x75B2D4) 特化】销毁 Sexy 缓存系统，释放申请的数据并删除供数据操作使用的临界区。
5BA850	Sexy::SexyCache::SexyCache(SexyCache* this)	eax = *this; ecx, edx		初始化创建 Sexy 缓存系统，取得与缓存程序连接需要的数据，并取得其注册的缓存消息的编号。;需要一个大小为 0x38 的内存区域用于构造 this。
5BA920	Sexy::SexyCache::Connected()	eax, ecx, edx		【对 gSexyCache(0x75B2D4) 特化】;判断缓存系统是否已连接到缓存程序。判断的标准为缓存系统是否成功取得缓存程序注册的缓存消息的编号。
5BA930	Sexy::SexyCache::Disconnect()	eax, ecx, edx		【对 gSexyCache(0x75B2D4) 特化】解除缓存系统与缓存程序的连接状态。
5BA940	Sexy::SexyCache::GetData;(ecx = int* theDataSize, void** theData, const std::string& theCacheName, edx = const std::string& theFilePath)	al = bool succeed; ecx, edx		【对 gSexyCache(0x75B2D4) 特化】从缓存程序取 theCacheName 缓存中 theFilePath 文件的缓存数据。;将指向的缓存数据的指针写入 [theData] 地址中，并将缓存数据的大小（字节数）写入 [theDataSize] 地址中。
5BAB50	Sexy::SexyCache::FreeGetData(void* theData)	eax, ecx, edx		【对 gSexyCache(0x75B2D4) 特化】将 theData 作为从缓存程序获取的数据进行释放。
5BAC30	Sexy::SexyCache::SetFileDeps(eax = const std::string& theDependFileName, ;                             const std::string& theCacheName, ecx = const std::string& theFilePath)	eax, ecx, edx		【对 gSexyCache(0x75B2D4) 特化】请求缓存程序设置文件缓存依赖，被依赖的文件名允许使用通配符。;如果需要同时设置多个依赖文件，则每两个依赖文件名之间以换行符（'\n'）进行分隔。;缓存依赖：当被依赖的文件发生变化时，本文件的缓存也将被视为已发生变化。
5BACA0	Sexy::SexyCache::AllocSetData;(int theDataSize, const std::string& theCacheName, edi = const std::string& theFilePath)	eax = void* aData; ecx, edx		【对 gSexyCache(0x75B2D4) 特化】申请用于向缓存程序提交设置请求的数据。
5BAE00	Sexy::SexyCache::FreeSetData(void* theData)	eax, ecx, edx		【对 gSexyCache(0x75B2D4) 特化】将 theData 作为向缓存程序提交的数据进行释放。
5BAEF0	Sexy::SexyCache::SetData(void* theData)	al = bool succeed; ecx, edx		【对 gSexyCache(0x75B2D4) 特化】向缓存程序提交设置请求。;参数 theData 仅用于缓存系统自身校验是否为有效的提交数据，实际的数据交流是通过共享内存进行的。
5BAF90	Sexy::SMemW(edi = unsigned int _Size, eax = void* _Src, esi = void*& _Dst)	eax, ecx, edx		从 *_Src 中读取 _Size 个字节的数据写入 *_Dst 中，然后将 _Dst 指针向后移动 _Size 个字节。
5BAFA0	Sexy::SMemWStr(ebx = const std::string& theString, eax = void*& _Dst)	eax, ecx, edx		依次将字符串 theString 的长度和所有字符写入 *_Dst 中，并相应地向后移动 _Dst 指针。
5BAFE0	Sexy::SMemR(edi = unsigned int _Size, ecx = void* _Dst, esi = void*& _Src)	eax, ecx, edx		从 *_Src 中读取 _Size 个字节的数据写入 *_Dst 中，然后将 _Src 指针向后移动 _Size 个字节。
5BAFF0	Sexy::SMemRStr(ebx = const std::string& theString, eax = void*& _Src)	eax, ecx, edx		依次从 *_Src 中读取并赋值字符串 theString 的长度和每个字符，并相应地向后移动 _Src 指针。
5BB050	Sexy::EncodingParser::EncodingParser(eax = EncodingParser* this)	eax = *this; ecx		初始化创建编码解析器。需要一个大小为 0x20 的内存区域用于构造 this。
5BB080	Sexy::EncodingParser::`scalar deleting destructor'(unsigned int flags, ecx = EncodingParser* this)	eax = *this; ecx, edx		删除编码解析器，当 flags 的第 0 位置 1 时会额外释放编码解析器本身占用的内存空间。		【虚函数】[[[(EncodingParser*)+0]+0]
5BB0A0	Sexy::EncodingParser::~EncodingParser(ecx = EncodingParser* this)	eax, ecx, edx		销毁编码解析器，关闭其正在读取的文件流（若存在）。
5BB110	Sexy::EncodingParser::SetEncodingType(EncodingParser::EncodingType theEncoding, ecx = EncodingParser* this)	eax, ecx		强制设置编码解析器的编码类型，并相应设置用于从文件中读取字符时使用的函数。		【虚函数】[[[(EncodingParser*)+0]+4]
5BB180	Sexy::EncodingParser::GetAsciiChar(bool* error, wchar_t* theChar, ecx = EncodingParser* this)	al = bool succeed; ecx, edx		从文件中以 ASCII 编码读取一个字符，并将读取到的字符转换为宽字符存储在 [theChar] 地址中。
5BB1D0	Sexy::EncodingParser::GetUTF8Char(bool* error, wchar_t* theChar, ecx = EncodingParser* this)	al = bool succeed; ecx, edx		从文件中以 UTF8 编码读取一个字符，并将读取到的字符转换为宽字符存储在 [theChar] 地址中。;如果读取到在该编码下非法的字符，则将 *error 赋值为 true，否则将 *error 赋值为 false。
5BB3D0	Sexy::EncodingParser::GetUTF16Char(bool* error, wchar_t* theChar, ecx = EncodingParser* this)	al = bool succeed; ecx, edx		从文件中以 UTF16 编码读取一个字符，并将读取到的字符转换为宽字符存储在 [theChar] 地址中。;如果读取到在该编码下非法的字符，则将 *error 赋值为 true，否则将 *error 赋值为 false。
5BB4F0	Sexy::EncodingParser::GetUTF16LEChar(bool* error, wchar_t* theChar, ecx = EncodingParser* this)	al = bool succeed; ecx, edx		从文件中以 UTF16LE 编码读取一个字符，并将读取到的字符转换为宽字符存储在 [theChar] 地址中。;如果读取到在该编码下非法的字符，则将 *error 赋值为 true，否则将 *error 赋值为 false。
5BB590	Sexy::EncodingParser::GetUTF16BEChar(bool* error, wchar_t* theChar, ecx = EncodingParser* this)	al = bool succeed; ecx, edx		从文件中以 UTF16BE 编码读取一个字符，并将读取到的字符转换为宽字符存储在 [theChar] 地址中。;如果读取到在该编码下非法的字符，则将 *error 赋值为 true，否则将 *error 赋值为 false。
5BB650	Sexy::EncodingParser::OpenFile(const std::string& theFileName, ecx = EncodingParser* this)	al = bool succeed; ecx, edx		编码解析器打开文件，若未强制设置编码类型，则尝试自动检测该文件使用的编码类型。		【虚函数】[[[(EncodingParser*)+0]+8]
5BB780	Sexy::EncodingParser::CloseFile(ecx = EncodingParser* this)	al = bool succeed; ecx, edx		编码解析器关闭正在读取的文件流。若不存在正在读取的文件，则返回 false。		【虚函数】[[[(EncodingParser*)+0]+C]
5BB7B0	Sexy::EncodingParser::EndOfFile(ecx = EncodingParser* this)	al = bool endOfFile; ecx, edx		判断当前正在读取的文件或缓冲区是否已经读取完毕。		【虚函数】[[[(EncodingParser*)+0]+10]
5BB7F0	Sexy::EncodingParser::SetStringSource(const std::wstring& theString, ecx = EncodingParser* this)	eax, ecx, edx		设置编码解析器读取的文本内容：将 theString 中的所有宽字符倒序加入解析器的文本缓冲区中。		【虚函数】[[[(EncodingParser*)+0]+14]
5BB880	Sexy::EncodingParser::GetChar(wchar_t* theChar, ecx = EncodingParser* this)	eax = GetCharReturnType aResult; ecx, edx		编码解析器从缓冲区或文件流中读取一个字符写入 [theChar] 地址中。返回读取的结果。;当缓冲区中存在待读取内容时，取缓冲区中的最后一个字符否则，从文件流中读取一个字符。		【虚函数】[[[(EncodingParser*)+0]+18]
5BB920	Sexy::EncodingParser::PutChar(const wchar_t& theChar, ecx = EncodingParser* this)	al = 1; ecx, edx		将 theChar 字符添加到编码解析器的文本缓冲区的末尾。		【虚函数】[[[(EncodingParser*)+0]+1C]
5BB940	Sexy::EncodingParser::PutString(const std::wstring& theString, ecx = EncodingParser* this)	al = 1; ecx, edx		将 theString 中的所有宽字符倒序添加到编码解析器的文本缓冲区的末尾。		【虚函数】[[[(EncodingParser*)+0]+20]
5BE7F0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::;     ~_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>(eax = std::_Tree<std::_Tset_traits<int>>* this)	eax, ecx, edx		销毁并释放字符串的集合红黑树。
5BEC60	std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>::insert;(std::_Tree<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>::iterator _Where, ; const std::pair<std::string, std::list<ResourceManager::BaseRes*>>& _Val, ; _Out_ std::_Tree<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>::iterator&& _Ret, ; eax = std::_Tree<std::_Tmap_traits<std::string, int>>* this)	eax = &&_Ret; ecx, edx		向字符串向基础资源指针链表的映射红黑树中的指定位置添加一个对组 _Val，;返回表示插入的键值在红黑树中的位置的迭代器。
5BEF20	std::pair<std::string, std::list<ResourceManager::BaseRes*>>::pair<std::string, std::list<ResourceManager::BaseRes*>>;(const std::list<ResourceManager::BaseRes*>& _Val2, const std::string& _Val1, ; std::pair<std::string, std::list<ResourceManager::BaseRes*>>* this)	eax = *this; ecx, edx		从给定的字符串和基础资源指针链表创建一个对组。需要一个大小为 0x28 的内存区域用于构造 this。
5BCD90	std::map<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>::operator[];(const std::string& _Keyval, ; ecx = std::map<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>* this)	eax = std::list<...::BaseRes*>& _Val; ecx, edx		在字符串向基础资源指针链表的映射容器中寻找 _Keyval 字符串对应的链表值，返回对该链表的引用。;若容器中原先不存在 _Keyval 键，则向容器中新添加一个 (_Keyval, _L) 对组，其中 _L 为默认构造的链表。
5BC8D0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::find;(ebx = const std::string& _Keyval, ; _Out_ std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::iterator&& _Ret, ; esi = std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		在字符串的集合容器中寻找 _Keyval 项所在位置，返回表示对应位置处的迭代器。;若集合中不存在指定的项，则返回相当于 set.end() 的迭代器。
5C09E0	std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>::_Lbound;(const std::string& _Keyval, eax = std::_Tree<std::_Tset_traits<std::string, Sexy::StringLessNoCase>>* this)	eax = _Node* _Bound; ecx, edx		根据红黑树的有序性，在字符串的集合红黑树中寻找可以放置 _Keyval 的最底层的一个节点。
5C0F90	std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>::_Insert;(const std::pair<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>& _Val, ; ecx = std::_Tree_nod<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>::_Node* _Wherenode, ; bool _Addleft, _Out_ std::_Tree<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>* this)	eax = &&_Ret; ecx, edx		在字符串向基础资源指针链表的映射红黑树中的指定节点下添加一个新的节点，;返回表示插入的键值在红黑树中的位置的迭代器。
5C1180	std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>::_Lbound;(const std::string& _Keyval, ; eax = std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>* this)	eax = _Node* _Bound; ecx, edx		根据红黑树的有序性，在字符串向基础资源指针链表的映射红黑树中寻找可以放置 _Keyval 的最底层的一个节点。
5C11F0	std::list<ResourceManager::BaseRes*>::list<ResourceManager::BaseRes*>;(ecx = const std::list<ResourceManager::BaseRes*>& __that, std::list<ResourceManager::BaseRes*>* this)	eax = *this; ecx, edx		复制基础资源指针链表 __that 的数据以构造新基础资源指针链表 this。;需要一个大小为 0xC 的内存区域用于构造 this。
5C1280	std::list<ResourceManager::BaseRes*>::_Incsize(ecx = std::list<ResourceManager::BaseRes*>* this)	eax, ecx, edx		基础资源指针的链表容器增加 1 个节点后，检查链表长度是否超出上限，;若超出则抛出错误，否则将链表大小记录值加 1。
5C1FE0	std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>::_Rrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		对字符串向基础资源指针链表的映射红黑树的一个节点进行右旋转。
5C2FF0	std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>::_Lrotate;(ecx = std::_Tree_nod<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>* _Wherenode, ; std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>* this)	eax, ecx, edx		对字符串向基础资源指针链表的映射红黑树的一个节点进行左旋转。
5C3040	std::_Tree<std::_Tmap_traits<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>>::_Buynode;(const std::pair<std::string, std::list<ResourceManager::BaseRes*>>& _Val, ; std::_Tree_nod<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>::_Node* _Rarg, ; std::_Tree_nod<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>::_Node* _Parg, ; std::_Tree_nod<std::_Tmap_traits<std::string, std::list<...>, Sexy::StringLessNoCase>>::_Node* _Larg)	eax = std::_Tree_nod<...>::_Node* _Pnode; ;ecx, edx		创建一个字符串向存档的映射容器的节点，令该节点的父节点指针指向 _Parg，;并令该节点的左、右子节点指针分别指向 _Larg 和 _Rarg，同时赋值该节点处的对组值为 _Val。
5C44F0	std::_Allocate<std::_Tree_nod<std::string, std::list<ResourceManager::BaseRes*>, Sexy::StringLessNoCase>::_Node>;(ecx = unsigned int _Count)	eax = void* _Mem; ecx, edx		申请 _Count 个字符串向基础资源指针链表的映射容器的红黑树的节点所需要的内存空间，;单个节点占用的内存大小为 0x30。当 _Count 个节点的总内存大于无符号整数 0xFFFFFFFF 时，将抛出错误。
5C4A50	std::list<ResourceManager::BaseRes*>::_Insert<std::list<ResourceManager::BaseRes*>::_Const_iterator<1>>;(std::list<ResourceManager::BaseRes*>::_Const_iterator<1> _Last, ; std::list<ResourceManager::BaseRes*>::_Const_iterator<1> _First, ; const std::_List_const_iterator<ResourceManager::BaseRes*> _Where, ; const std::list<ResourceManager::BaseRes*>& _Right, std::list<ResourceManager::BaseRes*>* this)	eax, ecx, edx		将 _Right 链表中 _First 至 _Last 之间的数据复制插入到自身 _Where 位置之前。
5C4B70	std::list<ResourceManager::BaseRes*>::erase(std::list<ResourceManager::BaseRes*>::const_iterator _Where, ;                                          _Out_ std::list<ResourceManager::BaseRes*>::iterator&& _Ret, ;                                          ebx = std::list<ResourceManager::BaseRes*>* this)	eax = &&_Ret; ecx, edx		移除基础资源链表指定位置的一个节点，返回表示被移除的节点的下一个节点的迭代器。
5C5320	Sexy::SoundManager::`scalar deleting destructor'(unsigned int flags, ecx = SoundManager* this)	eax = *this; ecx, edx		删除基础音效管理器，当 flags 的第 0 位置 1 时会额外释放音效管理器本身占用的内存空间。		【虚函数】[[[(SoundManager*)]+0]+0]
5C5340	Sexy::SoundInstance::~SoundInstance(ecx = SoundInstance* this)	此函数不改变任何寄存器		销毁基础音效实例。
5C5350	Sexy::SoundInstance::`scalar deleting destructor'(unsigned int flags, ecx = SoundInstance* this)	eax = *this; ecx, edx		删除基础音效实例，当 flags 的第 0 位置 1 时会额外释放音效实例本身占用的内存空间。		【虚函数】[[[(SoundInstance*)]+0]+0]
5C5370	GetPakPtr_DSoundManager()	eax = PakInterfaceBase*? aPak; ecx, edx		从 DSoundManager 的资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
5C5410	p_fopen_DSoundManager(eax = const char* theFileName)	eax = PFILE*? pFile; ecx, edx		以二进制只读模式读取指定文件，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，失败则返回 0。;优先尝试通过资源包文件接口在 pak 资源包内读取文件，当无法获取接口时尝试直接读取文件。
5C5470	p_fclose_DSoundManager(PFILE* theFile)	eax = 0(成功) | -1(失败); ecx, edx	0x4	尝试通过资源包文件接口关闭文件，当无法获取接口时直接关闭文件流。同时释放 pFile 占用的内存空间。
5C54B0	p_fseek_DSoundManager(esi = int theOrigin, edi = long theOffset, ebx = PFILE* theFile)	eax = 0(成功) | 非零(失败); ecx, edx		设置资源包数据文件当前读取指针指向的位置。其中 theOrigin 的取值可参考 61D72B 的函数的说明。;优先尝试通过资源包文件接口操作读取指针，当无法获取接口时尝试直接操作文件流的读取指针。
5C54E0	p_ftell_DSoundManager(PFILE* theFile)	eax = int aOffset; ecx, edx	0x4	取得资源包数据文件当前读取指针指向的位置距离文件头的偏移量。;优先尝试通过资源包文件接口获取偏移量，当无法获取接口时尝试直接在文件流中获取偏移量。
5C5510	p_fread_DSoundManager(PFILE* theFile, int theCount, int theSize, void* thePtr)	eax = int 实际完整读取的项数; ecx, edx	0x10	读取资源包数据文件中 theCount 项的数据并解密，然后将解密后的数据写入 thePtr 指向的地址;优先尝试通过资源包文件接口读取数据，当无法获取接口时尝试直接从文件流中读取数据。
5C5550	p_feof_DSoundManager(esi = PFILE* theFile)	eax = int eof; ecx, edx		检测文件是否读取结束。优先尝试通过资源包文件接口进行检测，当无法获取接口时尝试直接对文件流进行检测。
5C5580	Sexy::DSoundManager::DSoundManager(bool haveFMod, HWND theHWnd, DSoundManager* this)	eax = *this; ecx, edx		在 theHWnd 窗口创建 DSound 音效管理器。加载 FMod 实例（若需要），并初始化 DirectSound。;需要一个大小为 0x30A0 的内存区域用于构造 this。
5C5840	Sexy::DSoundManager::`scalar deleting destructor'(unsigned int flags, ecx = DSoundManager* this)	eax = *this; ecx, edx		删除 DSound 音效管理器，当 flags 的第 0 位置 1 时会额外释放音效管理器本身占用的内存空间。		【虚函数】[[[(DSoundManager*)]+0]+0]
5C5860	Sexy::DsoundManager::~DsoundManager(ecx = DSoundManager* this)	eax, ecx, edx		销毁 DSound 音效管理器，释放所有音效及相关资源，然后关闭并释放 FMod（若使用）和 DirectSound。
5C5920	Sexy::DSoundManager::FindFreeChannel(ebx = DSoundManager* this)	eax = int aFreeChannel; ecx, edx		整理当前各音效实例，然后寻找一个空闲的频道（用于播放新的音效实例）。若无空闲频道则返回 -1。
5C59A0	Sexy::DSoundManager::Initialized(ecx = DSoundManager* this)	al = bool initialized		判断音效管理器是否已成功初始化，判断的标准是是否成功创建了 DirectSound 实例。		【虚函数】[[[(DSoundManager*)]+0]+4]
5C59B0	Sexy::DSoundManager::VolumeToDB(double theVolume)	eax = int aVol; ecx, edx		由音量百分比（范围：[0.0, 1.0]）计算声音的分贝(×100)（范围：[-10000, 0]）。
5C59F0	Sexy::DSoundManager::SetVolume(double theVolume, ecx = DSoundManager* this)	eax, ecx, edx		设置音效管理器的主音量，并更新调整其中所有音效的音量。		【虚函数】[[[(DSoundManager*)]+0]+14]
5C5A30	Sexy::DSoundManager::LoadWAVSound;(const std::string& theFileName, unsigned int theSfxId, DSoundManager* this)	al = bool 是否成功; ecx, edx		加载文件名（含扩展名）为 theFileName 的 WAV 音乐文件作为编号为 theSfxId 的音效。
5C5E80	Sexy::DSoundManager::LoadFModSound;(eax = const std::string& theFileName, unsigned int theSfxId, ecx = DSoundManager* this)	al = bool 是否成功; ecx, edx		加载文件名（含扩展名）为 theFileName 的 FMod 音乐文件作为编号为 theSfxId 的音效。;此函数可以用于加载 .ogg 和 .mp3 以及其他任何 FMod 可以解码的格式的音乐文件。
5C60A0	p_fseek64_wrap(int whence, long long off, PFILE* f)	eax = int 实际完整读取的项数; ecx, edx	0x10	供 ogg 库使用的自定义的“将文件流的读写位置设置为从 whence 基准偏移 off 字节处”的函数。
5C60D0	ov_pak_open(OggVorbis_File* vf, PFILE* f)	eax = int result; ecx, edx	0x8	注册 ogg 库中使用的读写文件用的各个相关函数。返回 0 表示成功，返回小于 0 的值表示失败。
5C6110	Sexy::DSoundManager::LoadOGGSound;(eax = const std::string& theFileName, unsigned int theSfxId, ebx = DSoundManager* this)	al = bool 是否成功; ecx, edx		加载文件名（含扩展名）为 theFileName 的 OGG 音乐文件作为编号为 theSfxId 的音效。
5C62D0	Sexy::DSoundManager::LoadAUSound(const std::string& theFileName, unsigned int theSfxId, DSoundManager* this)	al = bool 是否成功; ecx, edx		加载文件名（含扩展名）为 theFileName 的 AU 音乐文件作为编号为 theSfxId 的音效。
5C6710	Sexy::DSoundManager::LoadSound;(const std::string& theFileName, unsigned int theSfxId, ecx = DSoundManager* this)	al = bool 是否成功; ecx, edx		加载文件名为 theFileName 的音乐文件作为编号为 theSfxId 的音效。		【虚函数】[[[(DSoundManager*)]+0]+C]
5C6B90	Sexy::DSoundManager::LoadSound(const std::string& theFileName, ecx = DSoundManager* this)	eax = int aSoundId; ecx, edx		加载文件名为 theFileName 的音乐文件，并为其分配一个当前闲置可用的音效编号，返回该音效的编号。;若同名音乐文件已加载，则不再重复加载而直接返回其编号。若加载失败，则返回 -1。		【虚函数】[[[(DSoundManager*)]+0]+8]
5C6C20	Sexy::DSoundManager::ReleaseSound(unsigned int theSfxId, ecx = DSoundManager* this)	eax, ecx, edx		释放并清除编号为 theSfxId 的上位音效，此后 theSfxId 编号将重新变为闲置可用。		【虚函数】[[[(DSoundManager*)]+0]+10]
5C6C70	Sexy::DSoundManager::GetFreeSoundId(ecx = DSoundManager* this)	eax = int aSoundId; ecx, edx		取得一个闲置可用的音效编号。通常为，将取得的编号作为即将新加载的上位音效的编号。;若当前已存在 256 种或以上的上位音效，则没有剩余闲置的编号，函数返回 -1。		【虚函数】[[[(DSoundManager*)]+0]+40]
5C6C90	Sexy::DSoundManager::GetNumSounds(ecx = DSoundManager* this)	eax = int aCount; ecx, edx		取得当前已加载的上位音效数量。		【虚函数】[[[(DSoundManager*)]+0]+44]
5C6CD0	Sexy::DSoundManager::SetBaseVolume(double theBaseVolume, unsigned int theSfxID, ecx = DSoundManager* this)	al = bool validID		设置 theSfxID 上位音效的基础音量。不影响当前正在播放的上位音效实例。		【虚函数】[[[(DSoundManager*)]+0]+18]
5C6CF0	Sexy::DSoundManager::SetBasePan(int theBasePan, unsigned int theSfxID, ecx = DSoundManager* this)	al = bool validID; edx		设置 theSfxID 上位音效的基础声像。不影响当前正在播放的上位音效实例。		【虚函数】[[[(DSoundManager*)]+0]+1C]
5C6D10	Sexy::DSoundManager::GetTheFileTime(edi = _FILETIME* theFileTime, ecx = const std::string& theDepFile)	al = bool succeed; ecx, edx		取得文件 theDepFile 最后一次写入操作的日期写入 *theFileTime 中。
5C6D60	Sexy::DSoundManager::WriteWAV;(edx = const std::string& theDepFile, ecx = const std::string& theFilename, int theSfxID, DSoundManager* this)	al = bool succeed; ecx, edx		将已加载的 theSfxID 音效缓存为 .wav 格式的 theFilename 文件。其中：;theDepFile 为该音效的原文件的名称，theFilename 应指定缓存文件的路径、文件名及拓展名。
5C70C0	Sexy::DSoundManager::WriteToSexyCache;(const std::string& theFilePath, ecx = int theSfxID, DSoundManager* this)	al = bool succeed; ecx, edx		将 theSfxID 音效的源数据写入缓存系统。
5C73B0	Sexy::DSoundManager::ReadFromSexyCache(const std::string& theFilePath, int theSfxID, DSoundManager* this)	al = bool succeed; ecx, edx		从缓存系统读取 theSfxID 音效的源数据。
5C7650	Sexy::DSoundManager::GetSoundInstance(unsigned int theSfxID, ecx = DSoundManager* this)	eax = DSoundInstance* aSoundInstance; ;ecx, edx		获取指定 theSfxID 上位音效的声音实例对象。		【虚函数】[[[(DSoundManager*)]+0]+20]
5C77B0	Sexy::DSoundManager::ReleaseSounds(ecx = DSoundManager* this)	eax, ecx, edx		释放当前所有音效的源数据。		【虚函数】[[[(DSoundManager*)]+0]+24]
5C77E0	Sexy::DSoundManager::ReleaseChannels(ecx = DSoundManager* this)	eax, ecx, edx		释放当前所有播放频道（无论该频道上的音效实例是否已播放完毕且被释放）。		【虚函数】[[[(DSoundManager*)]+0]+28]
5C7810	Sexy::DSoundManager::ReleaseFreeChannels(eax = DSoundManager* this)	eax, ecx, edx		释放所有可清理的播放频道，要求该频道上的音效实例已被释放。
5C7850	Sexy::DSoundManager::StopAllSounds(ecx = DSoundManager* this)	eax, ecx, edx		停止所有正在播放的上位音效实例。		【虚函数】[[[(DSoundManager*)]+0]+3C]
5C7890	Sexy::DSoundManager::GetMasterVolume(ecx = DSoundManager* this)	st(0) = aMasterVolume; eax, ecx, edx		取得音效管理器的主音量。		【虚函数】[[[(DSoundManager*)]+0]+2C]
5C79B0	Sexy::DSoundManager::SetMasterVolume(double theVolume, ecx = DSoundManager* this)	eax, ecx, edx		设置音效管理器的主音量。		【虚函数】[[[(DSoundManager*)]+0]+30]
5C7AF0	Sexy::DSoundManager::SetCooperativeWindow(bool isWindowed, HWND theHWnd, ecx = DSoundManager* this)	eax, ecx, edx		设置音效管理器使用的 DirectSound 实例与音效窗口 theHWnd 的协作级别为完全协作状态。		【虚函数】[[[(DSoundManager*)]+0]+38]
5C7B20	Sexy::DSoundInstance::DSoundInstance;(IDirectSoundBuffer* theSourceSound, ecx = DSoundManager* theSoundManager, DSoundInstance* this)	eax = *this; ecx, edx		初始化创建上位音效实例。需要一个大小为 0x38 大小的内存区域用于构造 this。
5C7C60	Sexy::DSoundInstance::`scalar deleting destructor'(unsigned int flags, ecx = DSoundInstance* this)	eax = *this; ecx, edx		删除上位音效实例，当 flags 的第 0 位置 1 时会额外释放上位音效实例本身占用的内存空间。		【虚函数】[[[(DSoundInstance*)]+0]+0]
5C7C80	Sexy::DSoundInstance::~DSoundInstance(ecx = DSoundInstance* this)	eax, ecx, edx		销毁上位音效实例，释放音效缓冲区。
5C7CE0	Sexy::DSoundInstance::RehupVolume(eax = DSoundInstance* this)	eax, ecx, edx		由音效管理器修改音效的音量后，重新设定调整后的实际音量值。
5C7D70	Sexy::DSoundInstance::RehupPan(eax = DSoundInstance* this)	eax, ecx, edx		由音效管理器修改音效的声像后，重新设定调整后的实际声像值。
5C7D90	Sexy::DSoundInstance::Release(ecx = DSoundInstance* this)	eax, ecx, edx		停止并释放上位音效实例。		【虚函数】[[[(DSoundInstance*)]+0]+04]
5C7DA0	Sexy::DSoundInstance::SetVolume(double theVolume, ecx = DSoundInstance* this)	eax, ecx, edx		设置上位音效实例的音量。音量 theVolume 的取值范围为 [0.0, 1.0]。		【虚函数】[[[(DSoundInstance*)]+0]+14]
5C7DC0	Sexy::DSoundInstance::SetPan(int thePosition, ecx = DSoundInstance* this)	eax, ecx, edx		设置上位音效实例的声像。声像 thePosition 的取值范围为 [-100, 100]（%，即：全左至全右）范围内的整数。		【虚函数】[[[(DSoundInstance*)]+0]+18]
5C7DE0	Sexy::DSoundInstance::SetBaseVolume(double theBaseVolume, ecx = DSoundInstance* this)	eax, ecx, edx		设置上位音效实例的基础音量。		【虚函数】[[[(DSoundInstance*)]+0]+8]
5C7E00	Sexy::DSoundInstance::SetBasePan(int theBasePan, ecx = DSoundInstance* this)	eax, ecx, edx		设置上位音效实例的基础声像。		【虚函数】[[[(DSoundInstance*)]+0]+C]
5C7E20	Sexy::DSoundInstance::Play(bool autoRelease, bool looping, ecx = DSoundInstance* this)	eax, ecx, edx		播放上位音效实例。		【虚函数】[[[(DSoundInstance*)]+0]+1C]
5C7E80	Sexy::DSoundInstance::Stop(ecx = DSoundInstance* this)	eax, ecx, edx		停止播放上位音效实例。		【虚函数】[[[(DSoundInstance*)]+0]+04]
5C7EB0	Sexy::DSoundInstance::AdjustPitch(double theNumSteps, ecx = DSoundInstance* this)	eax, ecx, edx		调整上位音效实例的音高。		【虚函数】[[[(DSoundInstance*)]+0]+10]
5C7F40	Sexy::DSoundInstance::IsPlaying(ecx = DSoundInstance* this)	al = bool isPlaying; ecx, edx		判断上位音效实例是否正在播放。		【虚函数】[[[(DSoundInstance*)]+0]+24]
5C7F70	Sexy::DSoundInstance::IsReleased(ecx = DSoundInstance* this)	al = bool isReleased; ecx, edx		若上位音效实例未释放，则尝试进行释放。然后返回是否已释放的逻辑值（返回 mReleased 的值）。		【虚函数】[[[(DSoundInstance*)]+0]+28]
5C7FA0	Sexy::DSoundInstance::GetVolume(ecx = DSoundInstance* this)	st(0) = aVolume		取得上位音效实例的音量。		【虚函数】[[[(DSoundInstance*)]+0]+2C]
5C7FB0	CheckBassFunction(const char* theName, unsigned int theFunc)	eax, ecx, edx	0x8	检查取得的函数地址 theFunc 是否为 0，若为 0 则弹出“%s function not found in bass.dll”错误弹窗。
5C8020	Sexy::BASS_INSTANCE::BASS_INSTANCE(esi = BASS_INSTANCE* this)	eax = *this; ecx, edx		初始化创建 Bass 实例，加载 bass.dll，同时获取并存储其中部分函数的地址。;需要一个大小为 0xD4 的内存区域用于构造 this。
5C85C0	Sexy::BASS_INSTANCE::`scalar deleting destructor'(unsigned int flags, ecx = BASS_INSTANCE* this)	eax = *this; ecx, edx		删除 Bass 实例。当 flags 的第 0 位置 1 时会额外释放 Bass 实例本身占用的内存空间。		【虚函数】[[[(BASS_INSTANCE*)]+0]+0]
5C85E0	Sexy::BASS_INSTANCE::~BASS_INSTANCE(ecx = BASS_INSTANCE* this)	eax, ecx, edx		销毁 Bass 实例，释放 bass.dll（若已加载）。
5C8600	Sexy::BASS_INSTANCE::BASS_MusicSetAmplify(eax = unsigned long amp, ecx = HMUSIC handle)	eax = 1; ecx, edx		【对 gBass([0x6A9FF0]) 特化】设置音乐的振幅。
5C8620	Sexy::BASS_INSTANCE::BASS_MusicPlay(ecx = HMUSIC handle)	eax = int succeed; ecx, edx		【对 gBass([0x6A9FF0]) 特化】重新开始播放音乐。
5C8630	Sexy::BASS_INSTANCE::BASS_MusicPlayEx(int flags, unsigned long pos, edi = HMUSIC handle)	eax = int succeed; ecx, edx		【对 gBass([0x6A9FF0]) 特化】以指定的 flags 从指定的位置 pos 开始播放音乐。
5C8670	Sexy::BASS_INSTANCE::BASS_ChannelResume(ecx = HMUSIC handle)	eax = int succeed; ecx, edx		【对 gBass([0x6A9FF0]) 特化】继续播放之前暂停的音乐。
5C8680	Sexy::BASS_INSTANCE::BASS_StreamPlay(eax = unsigned long flags, int flush, edi = HSTREAM handle)	eax = int succeed; ecx, edx		【对 gBass([0x6A9FF0]) 特化】以指定的 flags 播放采样音乐流。参数 flush 指定是否重新开始播放。
5C86A0	Sexy::LoadBassDLL()	eax, ecx, edx		增加 1 次 Bass 加载计数，然后尝试创建 Bass 实例。若失败，则弹出错误弹窗并退出程序。
5C8700	Sexy::FreeBassDLL()	eax, ecx, edx		减少 1 次 Bass 加载计数，然后若计数不大于 0，则删除 Bass 实例并释放 bass.dll。
5C8740	Sexy::BassMusicInfo::BassMusicInfo(eax = BassMusicInfo* this)	eax = *this; ecx		初始化创建 Bass 音乐信息。需要一个大小为 0x28 的内存区域用于构造 this。
5C8760	Sexy::BassMusicInterface::BassMusicinterface(edi = HWND theHWnd, esi = BassMusicInterface* this)	eax = *this; ecx		在 theHWnd 窗口创建 Bass 音乐接口。加载 Bass 实例，调整混音器设备的相关数据，并初始化 Bass 播放。;需要一个大小为 0x18 的内存区域用于构造 this。
5C8960	Sexy::BassMusicinterface::`scalar deleting destructor'(unsigned int flags, ecx = BassMusicInterface* this)	eax = *this; ecx		删除 Bass 音乐接口。当 flags 的第 0 位置 1 时会额外释放音乐接口本身占用的内存空间。		【虚函数】[[[(BassMusicInterface*)]+0]+0]
5C8980	std::map<int, Sexy::BassMusicInfo>::~map<int, Sexy::BassMusicInfo>(eax = std::map<int, Sexy::BassMusicInfo>* this)	eax, ecx, edx		销毁并释放整数向 Bass 音乐信息的映射容器。
5C8990	Sexy::BassMusicinterface::~BassMusicinterface(ecx = BassMusicInterface* this)	eax, ecx, edx		销毁 Bass 音乐接口，停止所有音乐并释放当前所有相关资源。
5C8A10	Sexy::BassMusicInterface::LoadMusic;(const std::string& theFileName, int theSongId, ecx = BassMusicInterface* this)	al = bool 是否成功; ecx, edx		读取 theFileName 音频文件作为编号为 theSongId 的音乐序列。		【虚函数】[[[(BassMusicInterface*)]+0]+4]
5C8D20	Sexy::BassMusicInterface::PlayMusic;(bool noLoop, int theOffset, int theSongID, ecx = BassMusicInterface* this)	eax, ecx, edx		从指定偏移位置开始循环播放编号为 theSongID 的音乐。若指定了 noLoop，则改为不循环播放。		【虚函数】[[[(BassMusicInterface*)]+0]+8]
5C8E50	Sexy::BassMusicInterface::StopMusic(int theSongID, ecx = BassMusicInterface* this)	eax, ecx, edx		停止播放编号为 theSongID 的音乐。在 Lawn 内，theSongID 为某一正在播放的音乐文件的 MusicFile 编号。		【虚函数】[[[(BassMusicInterface*)]+0]+C]
5C8EC0	Sexy::BassMusicInterface::StopAllMusic(ecx = BassMusicInterface* this)	eax, ecx, edx		停止播放所有音乐。		【虚函数】[[[(BassMusicInterface*)]+0]+18]
5C8F40	Sexy::BassMusicInterface::UnloadMusic(int theSongID, ecx = BassMusicInterface* this)	eax, ecx, edx		停止播放编号为 theSongID 的音乐，然后卸载并释放该音乐文件。		【虚函数】[[[(BassMusicInterface*)]+0]+1C]
5C8FF0	Sexy::BassMusicInterface::UnloadAllMusic(ecx = BassMusicInterface* this)	eax, ecx, edx		停止播放所有音乐，然后卸载并释放所有音乐文件。		【虚函数】[[[(BassMusicInterface*)]+0]+20]
5C90E0	Sexy::BassMusicInterface::PauseMusic(int theSongId, ecx = BassMusicInterface* this)	eax, ecx, edx		暂停播放编号为 theSongID 的音乐。		【虚函数】[[[(BassMusicInterface*)]+0]+10]
5C9150	Sexy::BassMusicInterface::PauseAllMusic(ecx = BassMusicInterface* this)	eax, ecx, edx		暂停播放编号为 theSongID 的音乐。		【虚函数】[[[(BassMusicInterface*)]+0]+24]
5C91F0	Sexy::BassMusicInterface::ResumeAllMusic(ecx = BassMusicInterface* this)	eax, ecx, edx		恢复播放所有暂停的音乐。		【虚函数】[[[(BassMusicInterface*)]+0]+28]
5C9280	Sexy::BassMusicInterface::ResumeMusic(int theSongId, ecx = BassMusicInterface* this)	eax, ecx, edx		恢复播放编号为 theSongID 的音乐。		【虚函数】[[[(BassMusicInterface*)]+0]+14]
5C92F0	Sexy::BassMusicInterface::FadeIn;(bool noLoop, double theSpeed, int theOffset, int theSongId, ecx = BassMusicInterface* this)	eax, ecx, edx		淡入编号为 theSongID 的音乐。其中，theOffset 为开始播放的位置偏移，theSpeed 为淡入的速度。		【虚函数】[[[(BassMusicInterface*)]+0]+2C]
5C9430	Sexy::BassMusicInterface::FadeOut(double theSpeed, bool stopSong, ecx = BassMusicInterface* this)	eax, ecx, edx		淡出编号为 theSongID 的音乐。若指定了 stopSong，则在淡出完成后同时停止该音乐。		【虚函数】[[[(BassMusicInterface*)]+0]+30]
5C94A0	Sexy::BassMusicInterface::FadeOutAll(double theSpeed, bool stopSong, ecx = BassMusicInterface* this)	eax, ecx, edx		淡出所有音乐，其中 theSpeed 为淡出的速度。		【虚函数】[[[(BassMusicInterface*)]+0]+34]
5C9520	Sexy::BassMusicInterface::SetVolume(double theVolume, ecx = BassMusicInterface* this)	eax, ecx, edx		设置音乐接口的全局主音量。		【虚函数】[[[(BassMusicInterface*)]+0]+44]
5C95A0	Sexy::BassMusicInterface::SetSongVolume(double theVolume, int theSongID, ecx = BassMusicInterface* this)	eax, ecx, edx		设置编号为 theSongID 的音乐的音量。其中 theVolume 的取值范围为 [0.0, 1.0]。		【虚函数】[[[(BassMusicInterface*)]+0]+38]
5C9630	Sexy::BassMusicInterface::SetSongMaxVolume;(double theMaxVolume, int theSongID, ecx = BassMusicInterface* this)	eax, ecx, edx		设置编号为 theSongID 的音乐的最大音量。		【虚函数】[[[(BassMusicInterface*)]+0]+3C]
5C96D0	Sexy::BassMusicInterface::IsPlaying(int theSongID, ecx = BassMusicInterface* this)	al = bool isPlaying; ecx, edx		判断编号为 theSongID 的音乐是否正在播放中。		【虚函数】[[[(BassMusicInterface*)]+0]+40]
5C9750	Sexy::BassMusicInterface::SetMusicAmplify(double theAmp, ecx = BassMusicInterface* this)	eax, ecx, edx		设置编号为 theSongID 的音乐的增幅。其中 theAmp 的取值范围为 [0.0, 1.0]。		【虚函数】[[[(BassMusicInterface*)]+0]+48]
5C97E0	Sexy::BassMusicInterface::Update(ecx = BassMusicInterface* this)	eax, ecx, edx		更新音乐接口中所有音乐的淡入淡出效果。		【虚函数】[[[(BassMusicInterface*)]+0]+4C]
5C9900	Sexy::BassMusicInterface::GetMusicOrder(int theSongID, eax = BassMusicInterface* this)	eax = unsigned int aPosition; ecx, edx		取得编号为 theSongID 的音乐当前播放的位置，若不存在指定编号的音乐则返回 -1。;返回值的低 16 位表示当前乐曲进行的序号（order），高 16 位表示当前播放的行（row）。
5C9980	CheckFModFunction(const char* theName, unsigned int theFunc)	eax, ecx, edx	0x8	检查取得的函数地址 theFunc 是否为 0，若为 0 则弹出“%s function not found in fmod.dll”错误弹窗。
5C99F0	Sexy::FMOD_INSTANCE::FMOD_INSTANCE(esi = FMOD_INSTANCE* this)	eax = *this; ecx, edx		初始化创建 FMod 实例，加载 fmod.dll，同时获取并存储其中部分函数的地址。;需要一个大小为 0x80 的内存区域用于构造 this。
5C9D60	Sexy::FMOD_INSTANCE::`scalar deleting destructor'(unsigned int flags, ecx = FMOD_INSTANCE* this)	eax = *this; ecx, edx		删除 FMod 实例。当 flags 的第 0 位置 1 时会额外释放 FMod 实例本身占用的内存空间。		【虚函数】[[[(FMOD_INSTANCE*)]+0]+0]
5C9D80	Sexy::FMOD_INSTANCE::~FMOD_INSTANCE(ecx = FMOD_INSTANCE* this)	eax, ecx, edx		销毁 FMod 实例，释放 fmod.dll（若已加载）。
5C9DA0	Sexy::LoadFModDLL()	eax, ecx, edx		增加 1 次 FMod 加载计数，然后尝试创建 FMod 实例。若失败，则弹出错误弹窗并退出程序。
5C9E00	Sexy::FreeFModDLL()	eax, ecx, edx		减少 1 次 FMod 加载计数，然后若计数不大于 0，则删除 FMod 实例并释放 fmod.dll。
5C9E40	Sexy::FModMusicInfo::FModMusicInfo(eax = FModMusicInfo* this)	eax = *this; ecx		初始化创建 FMod 音乐信息。需要一个大小为 0x28 的内存区域用于构造 this。
5C9E60	Sexy::FModMusicInterface::FModMusicInterface(FModMusicInterface* this)	eax = *this; ecx		创建 FMod 音乐接口，加载 FMod 实例并初始化音量数据。需要一个大小为 0x20 的内存区域用于构造 this。
5C9F00	Sexy::FModMusicInterface::`scalar deleting destructor'(unsigned int flags, ecx = FModMusicInterface* this)	eax = *this; ecx		删除 FMod 音乐接口。当 flags 的第 0 位置 1 时会额外释放音乐接口本身占用的内存空间。		【虚函数】[[[(FModMusicInterface*)]+0]+0]
5C9F20	std::map<int, Sexy::FModMusicInfo>::~map<int, Sexy::FModMusicInfo>(eax = std::map<int, Sexy::FModMusicInfo>* this)	eax, ecx, edx		销毁并释放整数向 FMod 音乐信息的映射容器。
5C9F30	Sexy::FModMusicInterface::~FModMusicInterface(ecx = FModMusicInterface* this)	eax, ecx, edx		销毁 FMod 音乐接口，释放 FMod 实例。
5C9F90	Sexy::FModMusicInterface::LoadFMODSample(const std::string& theFileName)	eax = FSOUND_SAMPLE*? aSample; ;ecx, edx		将 theFileName 文件加载为音乐采样，返回创建的采样实例的指针，加载失败时返回空指针。;优先尝试读取缓存的 .wav 格式的文件，不存在缓存时读取 .ogg 格式的文件。
5CA4B0	Sexy::FModMusicInterface::LoadSample;(bool repeat, const std::string& theFileName, int theSongId, ecx = FModMusicInterface* this)	al = bool loaded; ecx, edx		读取 theFileName 音频文件作为编号为 theSongId 的音乐采样，参数 repeat 指定音乐是否循环。		【虚函数】[[[(FModMusicInterface*)]+0]+54]
5CA5D0	Sexy::FModMusicInterface::LoadSample;(bool repeat, const std::string& theRepeatFileName, const std::string& theIntroFileName, ; int theSongId, ecx = FModMusicInterface* this)	al = bool loaded; ecx, edx		读取 theIntroFileName 文件作为音乐前奏及 theRepeatFileName 文件作为循环主体，;将两部分拼接在一起作为编号为 theSongId 的音乐采样。参数 repeat 指定音乐整体是否循环。		【虚函数】[[[(FModMusicInterface*)]+0]+50]
5CA9D0	Sexy::FModMusicInterface::LoadMusic;(const std::string& theFileName, int theSongId, ecx = FModMusicInterface* this)	al = bool loaded; ecx, edx		读取 theFileName 音频文件作为编号为 theSongId 的音乐序列。		【虚函数】[[[(FModMusicInterface*)]+0]+4]
5CAA50	Sexy::FModMusicInterface::PlayMusic;(bool noLoop, int theOffset, int theSongID, ecx = FModMusicInterface* this)	eax, ecx, edx		从指定偏移位置开始循环播放编号为 theSongID 的音乐。若指定了 noLoop，则改为不循环播放。		【虚函数】[[[(FModMusicInterface*)]+0]+8]
5CAB90	Sexy::FModMusicInterface::PauseMusic(int theSongId, ecx = FModMusicInterface* this)	eax, ecx, edx		暂停播放编号为 theSongID 的音乐。		【虚函数】[[[(FModMusicInterface*)]+0]+10]
5CAC10	Sexy::FModMusicInterface::ResumeMusic(int theSongId, ecx = FModMusicInterface* this)	eax, ecx, edx		恢复播放编号为 theSongID 的音乐。		【虚函数】[[[(FModMusicInterface*)]+0]+14]
5CAC90	Sexy::FModMusicInterface::StopMusic(int theSongID, ecx = FModMusicInterface* this)	eax, ecx, edx		停止播放编号为 theSongID 的音乐。		【虚函数】[[[(FModMusicInterface*)]+0]+C]
5CAD10	Sexy::FModMusicInterface::StopAllMusic(ecx = FModMusicInterface* this)	eax, ecx, edx		停止播放所有音乐。		【虚函数】[[[(FModMusicInterface*)]+0]+18]
5CADB0	Sexy::FModMusicInterface::FadeIn;(bool noLoop, double theSpeed, int theOffset, int theSongId, ecx = FModMusicInterface* this)	eax, ecx, edx		淡入编号为 theSongID 的音乐。其中，theOffset 为开始播放的位置偏移，theSpeed 为淡入的速度。		【虚函数】[[[(FModMusicInterface*)]+0]+2C]
5CAF10	Sexy::FModMusicInterface::FadeOut(double theSpeed, bool stopSong, ecx = FModMusicInterface* this)	eax, ecx, edx		淡出编号为 theSongID 的音乐。若指定了 stopSong，则在淡出完成后同时停止该音乐。		【虚函数】[[[(FModMusicInterface*)]+0]+30]
5CAF80	Sexy::FModMusicInterface::SetVolume(double theVolume, ecx = FModMusicInterface* this)	eax, ecx, edx		设置音乐接口的全局主音量。		【虚函数】[[[(FModMusicInterface*)]+0]+44]
5CB050	Sexy::FModMusicInterface::SetSongVolume(double theVolume, int theSongID, ecx = FModMusicInterface* this)	eax, ecx, edx		设置编号为 theSongID 的音乐的音量。其中 theVolume 的取值范围为 [0.0, 1.0]。		【虚函数】[[[(FModMusicInterface*)]+0]+38]
5CB110	Sexy::FModMusicInterface::IsPlaying(int theSongID, ecx = FModMusicInterface* this)	al = bool isPlaying; ecx, edx		判断编号为 theSongID 的音乐是否正在播放中。		【虚函数】[[[(FModMusicInterface*)]+0]+40]
5CB190	Sexy::FModMusicInterface::Update(ecx = FModMusicInterface* this)	eax, ecx, edx		更新音乐接口中所有音乐的淡入淡出效果。		【虚函数】[[[(FModMusicInterface*)]+0]+4C]
5CB300	Sexy::MusicInterface::MusicInterface(eax = MusicInterface* this)	eax = *this		初始化创建无声音乐接口。需要一个大小为 0x4 的内存区域用于构造 this。
5CB310	Sexy::MusicInterface::`scalar deleting destructor'(unsigned int flags, ecx = MusicInterface* this)	eax = *this; ecx		删除无声音乐接口。当 flags 的第 0 位置 1 时会额外释放音乐接口本身占用的内存空间。		【虚函数】[[[(MusicInterface*)]+0]+0]
5CB330	Sexy::Musicinterface::~MusicInterface(ecx = MusicInterface* this)	此函数不改变任何寄存器		销毁无声音乐接口。
5CB340	Sexy::MusicInterface::FadeIn;(bool noLoop, double theSpeed, int theOffset, int theSongId, ecx = MusicInterface* this)	eax, ecx, edx		淡入编号为 theSongID 的音乐。不进行任何处理。		【虚函数】[[[(MusicInterface*)]+0]+2C]
5CB350	Sexy::MusicInterface::PlayMusic(bool noLoop, int theOffset, int theSongID, ecx = MusicInterface* this)	eax, ecx, edx		播放编号为 theSongID 的音乐。不进行任何处理。		【虚函数】[[[(MusicInterface*)]+0]+8]
5CB7B0	std::_Tree<std::_Tmap_traits<int, Sexy::BassMusicInfo>>::~_Tree<std::_Tmap_traits<int, Sexy::BassMusicInfo>>;(eax = std::_Tree<std::_Tmap_traits<int, Sexy::BassMusicInfo>>* this)	eax, ecx, edx		销毁并释放整数向 Bass 音乐信息的映射红黑树。
5CB9E0	std::_Tree<std::_Tmap_traits<int, Sexy::FModMusicInfo>>::~_Tree<std::_Tmap_traits<int, Sexy::FModMusicInfo>>;(eax = std::_Tree<std::_Tmap_traits<int, Sexy::FModMusicInfo>>* this)	eax, ecx, edx		销毁并释放整数向 FMod 音乐信息的映射红黑树。
5CC070	GetPakPtr_ImageLib()	eax = PakInterfaceBase*? aPak; ecx, edx		从 ImageLib 的资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
5CC110	p_fopen_ImageLib(eax = const char* theFileName)	eax = PFILE*? pFile; ecx, edx		以二进制只读模式读取指定文件，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，失败则返回 0。;优先尝试通过资源包文件接口在 pak 资源包内读取文件，当无法获取接口时尝试直接读取文件。
5CC170	p_fclose_ImageLib(esi = PFILE* theFile)	eax = 0(成功) | -1(失败); ecx, edx		尝试通过资源包文件接口关闭文件，当无法获取接口时直接关闭文件流。同时释放 pFile 占用的内存空间。
5CC1B0	p_fseek_ImageLib(esi = long theOffset, edi = PFILE* theFile)	eax = 0(成功) | 非零(失败); ecx, edx		设置资源包数据文件当前读取指针指向的位置。;优先尝试通过资源包文件接口操作读取指针，当无法获取接口时尝试直接操作文件流的读取指针。
5CC1E0	p_ftell_ImageLib(esi = PFILE* theFile)	eax = int aOffset; ecx, edx		取得资源包数据文件当前读取指针指向的位置距离文件头的偏移量。;优先尝试通过资源包文件接口获取偏移量，当无法获取接口时尝试直接在文件流中获取偏移量。
5CC210	p_fread_ImageLib(esi = PFILE* theFile, edi = int theCount, ebx = int theSize, void* thePtr)	eax = int 实际完整读取的项数; ecx, edx	0x4	读取资源包数据文件中 theCount 项的数据并解密，然后将解密后的数据写入 thePtr 指向的地址;优先尝试通过资源包文件接口读取数据，当无法获取接口时尝试直接从文件流中读取数据。
5CC250	ImageLib::Image::Image(eax = ImageLib::Image* this)	eax = *this; ecx		初始化创建图像处理库图片。需要一个大小为 0x10 的内存区域用于构造 this。
5CC270	ImageLib::Image::`scalar deleting destructor'(unsigned int flags, ecx = ImageLib::Image* this)	eax = *this; ecx, edx		删除图像处理库图片，当 flags 的第 0 位置 1 时会额外释放图片本身占用的内存空间。		【虚函数】[[[(ImageLib::Image*)]+0]+0]
5CC290	ImageLib::Image::~Image(ecx = ImageLib::Image* this)	eax, ecx, edx		销毁图像处理库图片，释放图片像素占用的内存空间。
5CC2B0	ImageLib::Image::GetHeight(eax = ImageLib::Image* this)	eax = int aHeight		取得图像处理库图片的像素高度。
5CC2C0	ImageLib::Image::GetBits(eax = ImageLib::Image* this)	eax = unsigned long* aBits		取得图像处理库图片的像素集指针。
5CC2D0	png_pak_read_data(unsigned int length, unsigned char* data, png_struct_def* png_ptr)	eax, ecx, edx	0xC	供 png 库使用的自定义的兼容 pak 的“从 png 文件中读取 length 个字节写入 data 指向的地址”的函数。
5CC310	GetPNGImage()	eax = ImageLib::Image*? anImage; ecx, edx		按照 PNG 格式读取图片文件，并创建相应的图像库图片实例。读取失败则返回空指针。;此函数原有的一个参数在原版中被内联至函数内：;【const std::string& theFileName（实参 = ImageLib::gColorFileName(0x6A5390)）】
5CC4B0	GetTGAImage()	eax = ImageLib::Image*? anImage; ecx, edx		按照 TGA 格式读取图片文件，并创建相应的图像库图片实例。读取失败则返回空指针。;此函数原有的一个参数在原版中被内联至函数内：;【const std::string& theFileName（实参 = ImageLib::gColorFileName(0x6A5390)）】
5CC610	ReadBlobBlock(char* data, eax = PFILE* fp)	eax = int aCount; ecx, edx	0x4	读取小块数据：先读取 1 个字节表示块的长度，再读取 [长度] 个字节的实际数据写入 data 指向的地址。
5CC650	GetGIFImage()	eax = ImageLib::Image*? anImage; ecx, edx		按照 GIF 格式读取图片文件（仅读取第一帧），并创建相应的图像库图片实例。读取失败则返回空指针。;此函数原有的一个参数在原版中被内联至函数内：;【const std::string& theFileName（实参 = ImageLib::gColorFileName(0x6A5390)）】
5CCEC0	my_error_exit(jpeg_common_struct* cinfo)	eax, ecx, edx	0x4	自定义的 jpeg 异常处理函数，通过 longjmp 跳转到 setjmp 的函数内的清理临时数据并返回的部分继续执行。
5CCEE0	SetJpegTable(int scale_factor, const unsigned char* basic_table, int which_tbl, jpeg_common_struct* cinfo)	eax, ecx, edx	0x10	使用 scale_factor 缩放（即 quality）以 basic_table 的数据初始化第 which_tbl 个量化表。
5CD0F0	ImageLib::WriteJPEGImage(int theQuality, ImageLib::Image* theImage, const std::string& theFileName)	al = bool 是否成功; ecx, edx	0xC	将库图片保存为指定路径和名称的 .jpg 文件（需要路径存在）。其中 theQuality 的取值范围为 [0, 100]。
5CFA30	ImageLib::WritePNGImage(ImageLib::Image* theImage, const std::string& theFileName)	al = bool 是否成功; ecx, edx	0x8	将库图片保存为指定路径和名称的 .png 文件（需要路径存在）。
5CFBF0	init_source(jpeg_decompress_struct* cinfo)	eax, ecx	0x4	供 jpeg 库使用的自定义的“初始化源管理器”的函数。
5CFC00	fill_input_buffer(jpeg_decompress_struct* cinfo)	eax, ecx, edx	0x4	供 jpeg 库使用的自定义的“读取文件数据到解压缓冲区”的函数。
5CFC90	skip_input_data(long num_bytes, jpeg_decompress_struct* cinfo)	eax, ecx, edx	0x4	供 jpeg 库使用的自定义的“跳过数据中 num_bytes 个字节（可能大于缓冲区剩余长度）的无效数据”的函数。
5CFCD0	jpeg_pak_src(PFILE infile, esi = jpeg_decompress_struct* cinfo)	eax, ecx, edx	0x4	初始化 cinfo 使用的源管理器，记录当前文件流 infile 并修改解压过程中使用的部分函数。
5CFD40	GetJPEGImage()	eax = ImageLib::Image*? anImage; ecx, edx		按照 JPEG 格式读取图片文件，并创建相应的图像库图片实例。读取失败则返回空指针。;此函数原有的一个参数在原版中被内联至函数内：;【const std::string& theFileName（实参 = ImageLib::gColorFileName(0x6A5390)）】
5CFFB0	ImageLib::InitJPEG2000()	eax, ecx, edx		加载 j2k-codec.dll。
5D0080	ImageLib::CloseJPEG2000()	eax, ecx, edx		释放 j2k-codec.dll（若已加载）。
5D00B0	ImageLib::SetJ2KCodecKey(eax = const std::string& theKey)	eax, ecx, edx		设置使用 j2k-codec 库的秘钥。
5D00C0	Pak_seek(int offset, void* data_source)	eax, ecx, edx		供 j2k-codec 库使用的自定义的“设置文件读写位置”的函数。
5D00E0	Pak_read(void* data_source, int size, void* ptr)	eax, ecx, edx		供 j2k-codec 库使用的自定义的“从文件读取 size 字节写入到 ptr 指向的地址”的函数。
5D0110	ImageLib::GetJPEG2000Image()	eax = ImageLib::Image*? anImage; ecx, edx		按照 JPEG2000 格式读取图片文件，并创建相应的图像库图片实例。读取失败则返回空指针。;此函数原有的一个参数在原版中被内联至函数内：;【const std::string& theFileName（实参 = ImageLib::gColorFileName(0x6A5390)）】
5D04D0	ImageLib::GetImage(bool lookForAlphaImage, const std::string& theFileName)	eax = ImageLib::Image* anImage; ecx, edx	0x8	加载 theFileName 图片。若指定了 loopForAlphaImage 且找到透明蒙版图片，则相应地对原图进行处理。
5D0D40	crc32(eax = unsigned int len, ecx = const unsigned char* buf, edx = unsigned long crc)	eax = unsigned long aCrcVal; ecx, edx		计算一组数据的循环冗余校验值。其中，buf 指向需要计算的数据的存储地址，len 为数据的字节数。;参数 crc 为校验值初始值，用于分段计算校验值。整段计算或分段计算的首次调用时，一般可令 crc = 0。;分段计算的情况下，每次调用此函数进行计算时，令参数 crc = 上一次调用得到的校验值结果。
5D0E70	uncompress(ecx = unsigned long sourceLen, eax = const unsigned char* source, ;           unsigned long* destLen, edx = unsigned char* dest)	eax = int err; ecx, edx		解压缩 source 指向的区域的数据（参数 sourceLen 表示 source 数据的字节数），;并将解压后的数据写入 dest 指向的区域中（参数 destLen 指向的值表示 dest 区域最多可以写入的字节数）。;同时，将解压缩后的实际数据长度写入 [destLen] 地址中。若解压失败则返回相应的错误类型，成功则返回 0。
5D0EF0	Sexy::SexyApp::SexyApp(SexyApp* this)	eax = *this; ecx, edx		初始化创建应用程序。需要一个大小为 0x768 的内存区域用于构造 this。
5D1170	Sexy::SexyApp::`scalar deleting destructor'(unsigned int flags, ecx = SexyApp* this)	eax = *this; ecx, edx		删除应用程序，当 flags 的第 0 位置 1 时会额外释放应用程序本身占用的内存空间。		【虚函数】[[[(SexyApp*)]+0]+0]
5D1190	Sexy::SexyApp::~SexyApp(ecx = SexyApp* this)	eax, ecx, edx		销毁应用程序，删除内测支持系统和网络管理器。
5D13A0	Sexy::SexyApp::Validate(ecx = const std::string& theRegCode, const std::string& theUserName, SexyApp* this)	al = bool accessed; ecx, edx		借助 RSA 加密算法，计算用户名（已加密） theUserName 和注册码 theRegCode 是否正确匹配。
5D1790	Sexy::SexyApp::WriteRegistrationInfo(const std::string theRegCode, const std::string theRegName)	eax, ecx, edx		原意为将用户名、注册码、游玩次数、运行次数写入注册文件或注册表，实际不进行任何操作。
5D17D0	Sexy::SexyApp::ReadRegistrationInfo(int* theTimesExecuted, edx = int* theTimesPlayed, ;                                    ecx = std::string* theRegCode, std::string* theRegName, SexyApp* this)	eax, ecx, edx		从注册文件或注册表读取用户名、注册码、游玩次数、运行次数，分别写入四个参数指向的地址。
5D1D90	Sexy::SexyApp::ReadFromRegistry(ecx = SexyApp* this)	eax, ecx, edx		从注册表或记录文件中读取程序需要的各项基础数据（标识编号、合作方名称、版本检查时间、注册相关数据等）。		【虚函数】[[[(SexyApp*)]+0]+60]
5D2940	Sexy::SexyApp::WriteToRegistry(ecx = SexyApp* this)	eax, ecx, edx		将程序的各项基础数据（版本检查时间、注册相关数据等）写入注册表或记录文件。		【虚函数】[[[(SexyApp*)]+0]+5C]
5D2A70	Sexy::SexyApp::OpenHTMLTemplate;(const std::map<std::string, std::string>& theDefinesMap, const std::string& theTemplateFile, ecx = SexyApp* this)	al = bool succeed; ecx, edx		以 theDefinesMap 格式化 theTemplateFile 模板中的内容，然后以网页的形式打开格式化后的文件。		【虚函数】[[[(SexyApp*)]+0]+19C]
5D2FC0	Sexy::SexyApp::OpenRegisterPage(std::map<std::string, std::string> theDefinesMap, ecx = SexyApp* this)	al = bool succeed; ecx, edx		以程序的各项基础数据及指定的统计定义 theStatsMap 对注册模板进行格式化，并以网页的形式打开。;如果不存在注册模板文件，则直接打开注册网站。其中，参数 theStatsMap 采用值传递。		【虚函数】[[[(SexyApp*)]+0]+198]
5D3D60	Sexy::SexyApp::ShouldCheckForUpdate(ecx = SexyApp* this)	al = bool shouldCheck; ecx, edx		查询程序是否需要检测更新。除非设定了不检测更新，否则程序应当在每次崩溃后或每隔一周进行一次检测。		【虚函数】[[[(SexyApp*)]+0]+18C]
5D3DD0	Sexy::SexyApp::UpdateCheckQueried(ecx = SexyApp* this)	eax, ecx, edx		查询到程序需要进行检测更新时的接口函数。记录当前时间作为上一次更新检测的时间。		【虚函数】[[[(SexyApp*)]+0]+190]
5D3E00	Sexy::SexyApp::URLOpenSucceeded(const std::string& theURL, ecx = SexyApp* this)	eax, ecx, edx		打开 theURL 网页成功时的接口函数。若调用打开网页时指定了“shutdownOnOpen”，则标记跳过广告。		【虚函数】[[[(SexyApp*)]+0]+90]
5D3E30	Sexy::SexyApp::OpenRegisterPage(ecx = SexyApp* this)	al = bool succeed; ecx, edx		以程序的各项基础数据对注册模板进行格式化并以网页的形式打开，不存在注册模板文件时直接打开注册网站。		【虚函数】[[[(SexyApp*)]+0]+194]
5D3ED0	Sexy::SexyApp::CheckSignature(const std::string& theFileName, const Buffer& theBuffer, ecx = SexyApp* this)	al = bool passed; ecx, edx		借助 RSA 加密算法，检测 theFileName 文件的签名是否与相应的 .sig 文件中记录的一致。		【虚函数】[[[(SexyApp*)]+0]+168]
5D4280	Sexy::SexyApp::PreTerminate(ecx = SexyApp* this)	eax, ecx, edx		程序即将关闭时的接口函数。若需要且能够显示广告，则由自身的网络广告管理器显示广告。		【虚函数】[[[(SexyApp*)]+0]+54]
5D42D0	Sexy::SexyApp::OpenUpdateURL(ecx = SexyApp* this)	eax, ecx, edx		打开更新网页。打开由自身的网络广告管理器指定的更新网页，然后关闭程序。		【虚函数】[[[(SexyApp*)]+0]+1A0]
5D4370	Sexy::SexyApp::HandleCmdLineParam;(const std::string& theParamValue, const std::string& theParamName, ecx = SexyApp* this)	eax, ecx, edx		处理一个命令行指令。判断“-version”指令以弹出版本信息，或“-betasite”指令以覆写内测支持网站。		【虚函数】[[[(SexyApp*)]+0]+B4]
5D4780	Sexy::SexyApp::GetGameSEHInfo(_Out_ std::string&& anInfoString, ecx = SexyApp* this)	eax = std::string&& anInfoString; ecx, edx		获取程序结构化异常的基础信息。		【虚函数】[[[(SexyApp*)]+0]+A0]
5D4C10	Sexy::SexyApp::GetSEHWebParams(std::map<std::string, std::string>& theDefinesMap, ecx = SexyApp* this)	eax, ecx, edx		为结构化异常消息获取程序的部分基础数据，将数据项的名称和值相应地加入 theDefinesMap 中。		【虚函数】[[[(SexyApp*)]+0]+A4]
5D4FD0	Sexy::SexyApp::PreDisplayHook(ecx = SexyApp* this)	eax, ecx, edx		程序初始化结束、切换全屏模式并显示窗口之前的钩子。如果需要进行内测资格验证且验证失败，则退出程序。		【虚函数】[[[(SexyApp*)]+0]+68]
5D5010	Sexy::SexyApp::InitPropertiesHook(ecx = SexyApp* this)	eax, ecx, edx		加载属性文件的钩子。加载 partner.xml 并从中获取程序名、窗口标题、是否默认窗口化等部分信息。;同时，对程序自身的网络广告管理器和内测支持系统进行初始化。		【虚函数】[[[(SexyApp*)]+0]+174]
5D54E0	Sexy::SexyApp::Init(ecx = SexyApp* this)	eax, ecx, edx		应用程序初始化，设定结构化异常捕获器的部分文本内容，并设置使用 j2k-codec 库的秘钥值。		【虚函数】[[[(SexyApp*)]+0]+C4]
5D59A0	Sexy::SexyApp::UpdateFrames(ecx = SexyApp* this)	eax, ecx, edx		应用程序对网络广告管理器进行一轮的更新。		【虚函数】[[[(SexyApp*)]+0]+20]
5D59C0	Sexy::SexyApp::OverrideWindowProc;(LRESULT* theResult, LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd, ecx = SexyApp* this)	al = bool processed; ecx, edx		应用程序的窗口处理覆盖，用于判断并处理从其他进程传递来数据的窗口消息（WM_COPYDATA）。;返回值表示是否对消息进行了处理，当返回 true 时主窗口处理函数将不再重复对该消息进行处理。;若确实进行了对消息的处理，则额外将处理的结果写入 [theResult] 地址中，将作为主窗口处理函数的返回值。		【虚函数】[[[(SexyApp*)]+0]+188]
5D5A90	std::wstring::basic_string(const unsigned int _Count, const wchar_t* const _Ptr, ecx = std::wstring* this)	eax = *this; ecx, edx		以 _Ptr 指向的前 _Count 个宽字符创建宽字符串。需要一个大小为 0x1C 的内存区域用于构造 this。
5D5AC0	PopDRMComm::PopDRMComm(eax = PopDRMComm* this)	ecx = *this; edx		初始化新版权管理系统，注册若干窗口消息，并初始化关键段。需要一个大小为 0x60 的内存区域用于构造 this。
5D5B60	PopDRMComm::~PopDRMComm(eax = PopDRMComm* this)	eax, ecx, edx		销毁版权管理系统，关闭时间窗口和文件映射，并删除关键段。
5D5BC0	PopDRMComm::Start(esi = PopDRMComm* this)	eax, ecx, edx		开启版权管理系统，创建系统窗口线程，并等待直到窗口创建完成。
5D5C10	PopDRMComm::CreateData(esi = PopDRMComm* this)	eax, ecx, edx		创建共享内存数据，若已创建则直接获取数据指针。
5D5C80	PopDRMComm::EnableLocking(esi = PopDRMComm* this)	eax, ecx, edx		向窗口发送启用锁定的消息，需要版权管理系统存在窗口才可正常执行。
5D5CB0	PopDRMComm::QueryData(esi = PopDRMComm* this)	al = bool boughtGame; ecx, edx		向窗口发送查询数据的消息，查询是否已经购买完整游戏，需要版权管理系统存在窗口才可正常执行。
5D5CE0	PopDRMComm::BuyGame(eax = PopDRMComm* this)	eax, ecx, edx		开始购买完整游戏，创建共享内存数据并向其中写入“_ingame”字符串，然后向窗口发送购买游戏的消息。;需要版权管理系统存在窗口才可正常执行。
5D5D60	PopDRMComm::Connect(esi = PopDRMComm* this)	al = bool isConnected; ecx, edx		当版权管理系统未连接时，在进程间广播连接请求的消息，并等待直到收到回应消息（最多等待 100 毫秒）。
5D5DC0	PopDRMComm::ShowWindow(void* lpThreadParameter)	eax, ecx, edx	0x4	通过 PopDRMComm::Start() 函数创建的线程的起始函数。创建版权系统窗口，并进行窗口消息处理的循环。;当窗口创建成功时，通过 SetEvent 使主线程结束阻塞继续执行。
5D5EC0	PopDRMComm::WindowProc(LPARAM lParam, WPARAM wParam, UINT uMsg, HWND hWnd)	eax = long lResult; ecx, edx		版权系统窗口处理函数。当收到 PopDRMComm::Connect() 中广播的连接请求消息的回应消息时，判定为连接成功。
5D5F20	GetUTF8Char(wchar_t* theChar, int theLen, const char** theBuffer)	eax = int aConsumedCount; ecx, edx	0xC	从 *theBuffer 指向的区域中读取一个 utf8 字符，并将其转化为 unicode 宽字符写入 [theChar] 地址中。;其中，theLen 表示 *theBuffer 最大可读取的字节数。返回读取到的 utf8 字符占用的字节数，失败则返回 0。;读取成功后，将 *theBuffer 指针相应地向后移动至该字符之后，将移动后的指针重新写入 [theBuffer] 中。
5D60A0	Sexy::Buffer::Buffer(eax = Buffer* this)	eax = *this; ecx		创建数据缓冲区。需要一个大小为 0x20 的内存区域用于构造 this。
5D60C0	Sexy::Buffer::~Buffer(ecx = Buffer* this)	eax, ecx, edx		销毁 Sexy::Buffer 缓冲区，释放缓存数据占用的内存空间。
5D60F0	Sexy::Buffer::UTF8ToWideString(edi = _Out_ std::wstring&& aString, ecx = Buffer* this)	eax = std::wstring&& aString; ecx, edx		将缓冲区中的 utf8 字符串转化为 unicode 宽字符串。
5D61E0	Sexy::Buffer::SeekFront(eax = Buffer* this)	此函数不改变任何寄存器		将缓冲区的当前读取位置重置为起始位置（即 0 位置）。
5D61F0	Sexy::Buffer::Clear(eax = Buffer* this)	eax, ecx, edx		清空缓冲区中的数据和所有读取、写入的记录。
5D6240	Sexy::Buffer::WriteByte(unsigned char theByte, Buffer* this)	eax, ecx, edx		向缓冲区中写入一个字节的数据。
5D62E0	Sexy::Buffer::WriteNumBits(int theBits, int theNum, esi = Buffer* this)	eax, ecx, edx		向缓冲区中写入整数 theNum 的低 theBits 个二进制位。其中 theBits 的有效取值范围为 [1, 32] 的整数。
5D63E0	Sexy::Buffer::WriteBoolean(bool theBool, ecx = Buffer* this)	eax, ecx, edx		将布尔逻辑值上升为字节型并写入缓冲区。
5D6400	Sexy::Buffer::WriteShort(eax = short theShort, edi = Buffer* this)	eax, ecx, edx		向缓冲区中写入一个二字节的短整数。
5D6420	Sexy::Buffer::WriteLong(eax = long theLong, edi = Buffer* this)	eax, ecx, edx		向缓冲区中写入一个四字节的长整数。
5D6450	Sexy::Buffer::WriteString(ebx = const std::string& theString, eax = Buffer* this)	eax, ecx, edx		先将字符串的长度作为短整数写入缓冲区，然后依次向缓冲区中写入字符串中的每一个字符（不含终止符）。
5D64A0	Sexy::Buffer::WriteLine(ecx = const std::string& theString, Buffer* this)	eax, ecx, edx		在字符串后添加一个回车符和一个换行符，然后将添加后的新字符串写入缓冲区。
5D6530	Sexy::Buffer::WriteBytes(edi = int theCount, ebx = const unsigned char* theBytes, Buffer* this)	eax, ecx, edx		将 theBytes 指向的 theCount 个字节写入缓冲区。
5D6560	Sexy::Buffer::SetData(int theCount, unsigned char* thePtr, Buffer* this)	eax, ecx, edx		清空缓冲区中的当前数据，然后将 thePtr 指向的 theCount 个字节作为缓冲区的数据。
5D6600	Sexy::Buffer::ReadByte(esi = Buffer* this)	al = unsigned char b; ecx, edx		从缓冲区中读取一个字节的数据。
5D66E0	Sexy::Buffer::ReadNumBits(bool isSigned, int theBits, esi = Buffer* this)	eax = int aNum; ecx, edx		从缓冲区中读取 theBits 个二进制位的数据，并将其零扩展为 32 位的整数。;若指定了 isSigned，则扩展方式改为符号位扩展。
5D67C0	Sexy::Buffer::ReadBoolean(esi = Buffer* this)	al = bool b; ecx, edx		从缓冲区中读取一个字节的数据并转化为布尔逻辑值：若读取到的数据为 0 则返回 false，否则返回 true。
5D67D0	Sexy::Buffer::ReadShort(eax = Buffer* this)	ax = short aShort; ecx, edx		从缓冲区中读取一个二字节的短整数。
5D6800	Sexy::Buffer::ReadLong(eax = Buffer* this)	eax = long aLong; ecx, edx		从缓冲区中读取一个四字节的长整数。
5D6840	Sexy::Buffer::ReadString(edi = _Out_ std::string&& aString, ecx = Buffer* this)	eax = std::string&& aString; ecx, edx		从缓冲区中读取一个短整数作为字符串长度，然后依次从缓冲区中读取字符串的每一个字符（不含终止符）。
5D68D0	Sexy::Buffer::ReadLine(edi = _Out_ std::string&& aString, ecx = Buffer* this)	eax = std::string&& aString; ecx, edx		从缓冲区中读取一行字符串。读取原理为：不断依次读取一个字符，直到读取到换行符为止。
5D6960	Sexy::Buffer::ReadBytes(ebx = int theLen, unsigned char* theData, eax = Buffer* this)	eax, ecx, edx		读取缓冲区中的 theLen 个字节写入 theData 指向的地址。
5D6990	Sexy::Buffer::GetDataPtr(esi = Buffer* this)	eax = const unsigned char*? aData; ecx, edx		取得缓冲区数据指针，当数据长度为 0 时返回空指针。
5D69C0	Sexy::Buffer::GetDataLen(eax = Buffer* this)	eax = int aLen; ecx, edx		取得缓冲区数据的字节数（比特数 / 8，向上取整）。
5D69D0	Sexy::Buffer::AtEnd(eax = Buffer* this)	al = bool atEnd; ecx, edx		判断缓冲区的当前读取位置是否位于数据区的最后一个二进制位或之后。
5D6F30	lClip(const float edge, eax = const SWHelper::XYZStruct& off, ;      ecx = const SWHelper::XYZStruct& on, esi = SWHelper::XYZStruct& dst)	eax, ecx, edx	0x4	将超出左侧边界的三角顶点 off 参照边界内的三角顶点 on 进行裁剪，并将结果写入 dst 中。;其中，edge 为左侧边界的横坐标。裁剪的实质是以 on 为参考将 off 的横坐标缩放至边界上。
5D6F30	rClip(const float edge, eax = const SWHelper::XYZStruct& off, ;      ecx = const SWHelper::XYZStruct& on, esi = SWHelper::XYZStruct& dst)	eax, ecx, edx	0x4	将超出右侧边界的三角顶点 off 参照边界内的三角顶点 on 进行裁剪，并将结果写入 dst 中。;其中，edge 为右侧边界的横坐标。裁剪的实质是以 on 为参考将 off 的横坐标缩放至边界上。
5D7060	tClip(const float edge, eax = const SWHelper::XYZStruct& off, ;      ecx = const SWHelper::XYZStruct& on, esi = SWHelper::XYZStruct& dst)	eax, ecx, edx	0x4	将超出顶部边界的三角顶点 off 参照边界内的三角顶点 on 进行裁剪，并将结果写入 dst 中。;其中，edge 为顶部边界的纵坐标。裁剪的实质是以 on 为参考将 off 的纵坐标缩放至边界上。
5D7060	bClip(const float edge, eax = const SWHelper::XYZStruct& off, ;      ecx = const SWHelper::XYZStruct& on, esi = SWHelper::XYZStruct& dst)	eax, ecx, edx	0x4	将超出底部边界的三角顶点 off 参照边界内的三角顶点 on 进行裁剪，并将结果写入 dst 中。;其中，edge 为底部边界的纵坐标。裁剪的实质是以 on 为参考将 off 的纵坐标缩放至边界上。
5D7190	leClip(const float edge, eax = SWHelper::XYZStruct** dst, SWHelper::XYZStruct** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为左边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
5D7290	reClip(const float edge, eax = SWHelper::XYZStruct** dst, SWHelper::XYZStruct** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为右边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
5D7390	teClip(const float edge, eax = SWHelper::XYZStruct** dst, SWHelper::XYZStruct** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为上边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
5D7490	beClip(const float edge, eax = SWHelper::XYZStruct** dst, SWHelper::XYZStruct** src)	eax = unsigned int vCount; ecx, edx	0x8	将 src 中指向的所有三角顶点（以空指针为结束标志）依次连接组成的多边形以 edge 为下边界进行裁剪。;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。
5D7590	clipShape(const float bottom, const float top, const float right, const float left, ;          eax = SWHelper::XYZStruct** src, esi = SWHelper::XYZStruct** dst)	eax = unsigned int vCount; ecx, edx	0x10	将 src 中的 3 个三角顶点指针指向的三角顶点组成的三角形依次分别以指定的左、右、上、下边界进行裁剪，;将裁剪后的图形的每个顶点的指针依次写入 dst 指向的地址中，并返回裁剪后的图形含有的三角顶点数量。;当任意一次裁剪后得到的三角顶点数量小于 2 个（无法组成图形）时，将立即终止裁剪过程并返回 0。
5D7640	Sexy::SWHelper::SWDrawShape(bool vertexColor, bool blend, int thePixelFormat, int thePitch, ;                            void* theSurface, eax = const Rect& theClipRect, ecx = const Color& theColor, ;                            MemoryImage* theImage, int theNumVerts, XYZStruct* theVerts)	eax, ecx, edx	0x20	以 theImage 为纹理图片向 theSurface 绘制由 theNumVerts 个三角顶点组成的多边形。其中：;thePitch 为纹理图片的字节宽度，即一行像素占用的总字节数thePixelFormat 为纹理图片的像素模式[注];blend 表示是否进行线性混合（或双线性混合）vertexColor 表示是否使用三角顶点的固有颜色。;[注]像素模式：一个像素的 argb 颜色的存储方式，例如 0x8888 表示每种色值各占用 8 个二进制位。
5D79F0	Sexy::SWTri_AddDrawTriFunc(edi = DrawTriFunc theFunc, bool blend, int thePixelFormat, ;                           cl = bool global_argb, dl = bool mod_argb, al = bool talpha)	eax, ecx, edx	0x8	根据绘制时的各项参数，将三角绘制函数 theFunc 的指针加入到绘制函数数组 gDrawTriFunc 中合适的位置。;原版中实际使用的三角绘制函数详见48E6F0~50EA10的函数，各项参数的意义详见5D7A60的函数的注释。
5D7A60	Sexy::SWHelper::SWDrawTriangle;(bool blend, int thePixelFormat, SWDiffuse& globalDiffuse, SWTextureInfo* textureInfo, ; unsigned int bytepitch, unsigned int* pFrameBuffer, SWVertex* pVerts, cl = bool global_argb, ; dl = bool mod_argb, bool talpha, al = bool textured)	eax, ecx, edx	0x20	根据绘制时的各项参数，选择合适的三角绘制函数并调用以向 pFrameBuffer 输出绘制纹理三角形。其中：;textured 表示是否存在纹理图片，不存在时以白色替代（但原版中只添加了存在纹理图片时的绘制函数）;talpha 表示是否需要alpha渲染（用到或可能用到不透明度通道时为 1），不需要时不透明度锁定为 255;mod_argb 表示是否使用三角顶点的固有颜色（需要至少存在 1 个拥有固有颜色的三角顶点），;为 0 时直接使用函数调用中指定的颜色global_argb 表示函数调用时指定的颜色是否影响最终的颜色，;当 mod_argb 和 global_argb 均为 1 时，会将三角顶点的固有颜色与函数调用时指定的颜色进行混合;pVerts 为需要绘制的三角形的顶点的信息的数组pFrameBuffer 为绘制输出的目标图像像素集;bytepitch 为纹理图片的字节宽度，即一行像素占用的总字节数textureInfo 包含了纹理图片的各项信息;globalDiffuse 为函数调用时指定的绘制颜色thePixelFormat 为纹理图片的像素模式;blend 表示从纹理中取得的一点的像素颜色是否与附近点的像素颜色进行线性混合（或双线性混合）。
5D7AF0	PakInterfaceBase::FOpen(const wchar_t* theAccess, const wchar_t* theFileName, ecx = PakInterface* this)	eax = 0		以指定的连接模式打开指定文件，连接模式和文件名使用宽字符串指定。默认函数返回 0。		【虚函数】[[[(PakInterface*)]+0]+0]
5D7B00	PakInterfaceBase::FGetS(PFILE* theFile, int theSize, char* thePtr, ecx = PakInterfaceBase* this)	eax = char* thePtr		从资源文件中读取一行字符串并写入 thePtr 指向的地址中。默认函数返回 thePtr 且不作任何处理。		【虚函数】[[[(PakInterface*)]+0]+20]
5D7B10	GetPakPtr()	eax = PakInterfaceBase*? aPak; ecx, edx		从资源包接口指针的内存映射中取得全局资源包文件接口，若不存在该内存映射则创建。
5D7BB0	StringToUpper(ebx = const std::string& theString, edi = _Out_ const std::string&& aString)	eax = std::string&& aUpperString; ecx, edx		将字符串转化为大写形式。
5D7C60	PakInterface::PakInterface()	eax = *this; ecx, edx		【对 gPakInterface(0x75B410) 特化】初始化创建资源包接口。
5D7D10	PakInterface::~PakInterface()	eax, ecx, edx		【对 gPakInterface(0x75B410) 特化】销毁资源包接口。
5D7D90	PakInterface::AddPakFile(ecx = const std::string& theFileName)	al = bool 是否成功; ecx, edx		向资源包接口中添加一个新的资源包文件，会立即加载指定资源包内的所有文件。;使用资源包接口提供的相关函数可以像读写正常文件一样读写所有已添加的资源包内的文件。
5D84D0	FixFileName(_Out_ char* theUpperName, ecx = const char* theFileName)	eax, ecx, edx	0x4	规范化 theFileName 并将其化为最简的形式，然后将其转化为大写形式存储在 theUpperName 指向的地址中。;其执行的操作包括：(1)若 theFileName 使用绝对路径且位于当前工作目录下，则转为使用相对路径;(2)统一使用“\”而非“/”(3)避免路径折返，例如将“a\b\..\c”简化为“a\c”。
5D85C0	PakInterface::FOpen(const char* theAccess, const char* theFileName, ecx = PakInterface* this)	eax = PFILE*? pFile; ecx, edx		以指定的连接模式打开指定文件，创建一个记录资源包数据读取信息的结构 pFile 并返回其指针，失败则返回 0。;当连接为只读类型时，尝试在资源文件中寻找并读取连接非只读或在资源文件中未找到时，尝试直接读取。		【虚函数】[[[(PakInterface*)]+0]+4]
5D8780	PakInterface::FClose(PFILE* theFile, ecx = PakInterface* this)	eax = 0(成功) | -1(失败); ecx, edx		对于资源包内的资源文件，关闭资源文件的文件流。释放 theFile 占用的内存空间。		【虚函数】[[[(PakInterface*)]+0]+8]
5D87B0	PakInterface::FSeek(int theOrigin, int theOffset, PFILE* theFile, ecx = PakInterface* this)	eax = 0(成功) | 非零(失败); ecx, edx		设置资源文件当前读取指针指向的位置。其中 theOrigin 的取值可参考 61D72B 的函数的说明。		【虚函数】[[[(PakInterface*)]+0]+C]
5D8830	PakInterface::FTell(PFILE* theFile, ecx = PakInterface* this)	eax = int aOffset; ecx, edx		取得资源文件当前读取指针指向的位置距离文件头的偏移量。		【虚函数】[[[(PakInterface*)]+0]+10]
5D8850	PakInterface::FRead(PFILE* theFile, int theCount, int theElemSize, void* thePtr, ecx = PakInterface* this)	eax = int 实际完整读取的项数; ecx, edx		对于资源包内的资源文件，按字节读取 theCount 项（其中每项的大小为 theElemSize 字节）的数据，;同时分别将每一字节的数据与 0xF7 进行异或运算以解密，然后将解密后的数据写入 thePtr 指向的地址;对于非资源包内的文件，从文件流中读取 theCount 项的数据并直接写入 thePtr 指向的地址。		【虚函数】[[[(PakInterface*)]+0]+14]
5D88D0	PakInterface::FGetC(PFILE* theFile, ecx = PakInterface* this)	eax = int aChar; ecx, edx		从资源文件中读取一个字符，若为资源包内的资源文件则同时将该字符进行解密。读取失败则返回 -1。		【虚函数】[[[(PakInterface*)]+0]+18]
5D8930	PakInterface::UnGetC(PFILE* theFile, ecx = PakInterface* this)	eax = 0(成功) | -1(失败); ecx, edx		把字符 theChar 退回资源文件中，同时回退当前读取位置。		【虚函数】[[[(PakInterface*)]+0]+1C]
5D8970	PakInterface::FGetS(PFILE* theFile, int theSize, char* thePtr, ecx = PakInterface* this)	eax = char*? thePtr; ecx, edx		从资源文件中读取一行字符串并写入 thePtr 指向的地址中，若为资源包内的资源文件则同时进行解密。;其中，theSize 表示 thePtr 指向的地址最多可以容纳的字节数。返回 thePtr，读取失败则返回空指针。		【虚函数】[[[(PakInterface*)]+0]+24]
5D8A00	PakInterface::FEof(PFILE* theFile, ecx = PakInterface* this)	eax = int eof; ecx, edx		判断资源文件是否读取结束。		【虚函数】[[[(PakInterface*)]+0]+28]
5D8A30	PakInterface::PFindNext;(_WIN32_FIND_DATAA* lpFindFileData, PFindData* theFindData, eax = PakInterface* this)	al = bool found; ecx, edx		在 pak 内查找符合名称规则的下一个文件。;若找到，则将该文件的相关信息及此次寻找的状态信息分别记录在 *lpFindData 和 *theFindData 中。
5D8D10	PakInterface::FindFirstFileA;(_WIN32_FIND_DATAA* lpFindFileData, const char* lpFileName, ecx = PakInterface* this)	eax = HANDLE hFindFile; ecx, edx		在目录中搜索名称与 lpFileName 匹配的文件或子目录（如果使用通配符，则为部分名称）。;优先在 pak 内查找，无法找到时尝试在 pak 外查找。;最终若找到，则将找到的文件的相关信息记录在 *lpFindFileData 中，并返回此次查找的句柄否则，返回 -1。		【虚函数】[[[(PakInterface*)]+0]+2C]
5D8E00	PFindData::`scalar deleting destructor'(esi = PFindData* this)	eax, ecx, edx		销毁并删除资源包查找数据，释放记录使用的相关字符串，然后释放查找数据本身占用的内存空间。
5D8E50	PakInterface::FindNextFile;(_WIN32_FIND_DATAA* lpFindFileData, HANDLE* hFindFile, ecx = PakInterface* this)	eax = int found; ecx, edx		从此前调用的 PakInterface::FindFirstFileA 继续查找下一个文件，参数 hFindFile 应为其返回的查找句柄。;优先在 pak 内查找，无法找到时尝试在 pak 外查找。;最终若找到，则将找到的文件的相关信息记录在 *lpFindFileData 中，并返回一个非零值否则，返回零。		【虚函数】[[[(PakInterface*)]+0]+30]
5D8EB0	PakInterface::FindClose;(_WIN32_FIND_DATAA* lpFindFileData, HANDLE* hFindFile, ecx = PakInterface* this)	eax = 1; ecx, edx		关闭由此前调用的 PakInterface::FindFirstFileA 发起的文件查找，参数 hFindFile 应为其返回的查找句柄。		【虚函数】[[[(PakInterface*)]+0]+34]
5D9070	std::_Tree<std::_Tmap_traits<std::string, PakRecord>>::find;(ebx = const std::string& _Keyval, _Out_ std::_Tree<std::_Tmap_traits<std::string, PakRecord>>::iterator&& _Ret, ; edi = std::_Tree<std::_Tmap_traits<std::string, PakRecord>>* this)	eax = &&_Ret; ecx, edx		在字符串向资源文件数据的映射容器中寻找 _Keyval 字符串对应的资源文件数据。;若找到，则返回指示该对组所在位置处的迭代器否则，返回相当于 map.end() 的迭代器。
5D9D40	BigInt::BigInt(eax = BigInt* this)	eax = *this; ecx		初始化创建大整数。需要一个大小为 0x14 的内存区域用于构造 this。
5D9D60	BigInt::`scalar deleting destructor'(unsigned int flags, ecx = BigInt* this)	eax = *this; ecx, edx		删除大整数，当 flags 的第 0 位置 1 时会额外释放大整数本身占用的内存空间。		【虚函数】[[[(BigInt*)]+0]+0]
5D9D80	BigInt::BigInt(eax = int theInteger, esi = BigInt* this)	eax = *this; ecx, edx		由整数值创建大整数。需要一个大小为 0x14 的内存区域用于构造 this。
5D9DD0	BigInt::BigInt(edi = const BigInt& theBigInt, eax = BigInt* this)	eax = *this; ecx, edx		复制大整数 theBigInt 的数据以创建新的大整数。需要一个大小为 0x14 的内存区域用于构造 this。
5D9DF0	BigInt::BigInt(const std::string& theInteger, ebx = BigInt* this)	eax = *this; ecx, edx		由一个表示十六进制数字的字符串创建大整数。需要一个大小为 0x14 的内存区域用于构造 this。;该函数会忽略 theInteger 字符串前的正负号，且创建得到的大整数固定为正值。
5D9EE0	BigInt::~BigInt(ecx = BigInt* this)	eax, ecx, edx		销毁大整数，释放其各字占用的内存空间。
5D9F00	BigInt::Resize(eax = int theNewCapacity, esi = BigInt* this)	eax, ecx, edx		重新设定大整数的字容量。其中 theNewCapacity 不能小于当前字数且不应小于当前字容量。
5D9F50	BigInt::DoubleSize(eax = BigInt* this)	eax, ecx, edx		翻倍大整数的当前字容量。特别地，若当前字容量为 0，则重置为 8。
5D9F70	BigInt::Trim(eax = BigInt* this)	ecx, edx		清除大整数最高位上的所有 0 字（例如：将 00001234 简化为 1234）。
5D9FA0	BigInt::SetZero(eax = BigInt* this)	ecx		将大整数重置为 +0。
5D9FB0	BigInt::IsOdd(eax = BigInt* this)	al = bool isOdd		判断大整数是否为奇数。
5D9FD0	BigInt::IsNegative(eax = BigInt* this)	al = bool isNegative		判断大整数是否为负数（返回 mNegative 的值）。
5D9FE0	BigInt::NumBits(edx = BigInt* this)	eax = int aNumBits; ecx		取得大整数的二进制位数量。
5DA020	BigInt::HighWord(ecx = BigInt* this)	ax = unsigned short aWord		取得大整数最高字的值，若大整数没有任何有效字则返回 0。
5DA040	BigInt::GetWord(eax = int theIndex, ecx = BigInt* this)	ax = unsigned short aWord; ecx		取得大整数从低至高的第 theIndex 个字的值，若不存在足够的字数则返回 0。
5DA060	BigInt::SetWord(unsigned short theValue, edi = int theIndex, esi = BigInt* this)	eax, ecx, edx		将大整数从低至高的第 theIndex 个字赋值为 theValue，若不存在足够的字容量则执行若干次翻倍扩容。
5DA0D0	BigInt::Divide(ebx = BigInt& theRemainder, BigInt& theQuotient, const BigInt& theDivisor, BigInt* this)	eax, ecx, edx		计算大整数 *this 除以 theDivisor，将商和余数分别赋值给 theQuotient 和 theRemainder。
5DA310	BigInt::ShiftLeft(eax = int theShiftBits, ecx = BigInt* this)	eax = BigInt& this; ecx, edx		将大整数算数左移 theShiftBits 个二进制位，返回对移位后的自身的引用。
5DA400	BigInt::ShiftRight(int theShiftBits, eax = BigInt* this)	eax = BigInt& this; ecx, edx		将大整数算数右移 theShiftBits 个二进制位，返回对移位后的自身的引用。
5DA4B0	BigInt::operator==(ecx = const BigInt& theBigInt, eax = BigInt* this)	al = bool _Equal; ecx, edx		大整数的“==”运算符重载：忽略符号位地比较两个大整数的绝对值是否相等。
5DA4F0	BigInt::operator<(eax = const BigInt& theBigInt, edx = BigInt* this)	al = bool _Less; ecx, edx		大整数的“<”运算符重载：考虑符号地比较大整数 *this 是否小于 theBigInt。
5DA5A0	BigInt::operator>(esi = const BigInt& theBigInt, edi = BigInt* this)	al = bool _Greater; ecx, edx		大整数的“>”运算符重载：考虑符号地比较大整数 *this 是否大于 theBigInt。
5DA5D0	BigInt::operator>=(eax = const BigInt& theBigInt, edx = BigInt* this)	al = bool _GreaterEqual; ecx, edx		大整数的“>=”运算符重载：考虑符号地比较大整数 *this 是否不小于 theBigInt。
5DA5E0	BigInt::operator-(esi = _Out_ BigInt&& aBigInt, edi = BigInt* this)	eax = BigInt&& aBigInt; ecx, edx		大整数的前置“-”运算符重载：返回大整数 *this 的相反数。
5DA600	BigInt::operator=(edi = const BigInt& theBigInt, esi = BigInt* this)	eax = BigInt& this; ecx, edx		大整数的“=”赋值运算符重载：清除自身原数据并将 theBigInt 的值复制给自身，返回对赋值后的自身的引用。
5DA660	BigInt::operator*=(const BigInt& theBigInt, ecx = BigInt* this)	eax = BigInt& this; ecx, edx		大整数的“*=”运算符重载：将大整数 *this 自身的值乘以 theBigInt，返回对相乘后的自身的引用。
5DA6D0	BigInt::operator+=(const BigInt& theBigInt, ecx = BigInt* this)	eax = BigInt& this; ecx, edx		大整数的“+=”运算符重载：将大整数 *this 自身的值加上 theBigInt，返回对相加后的自身的引用。
5DA740	BigInt::operator<<=(int theShiftBits, ecx = BigInt* this)	eax = BigInt& this; ecx, edx		大整数的“<<=”运算符重载：将大整数 *this 自身的值左移 theShiftBits 位，返回对移位后的自身的引用。
5DA7B0	BigInt::operator>>=(ecx = BigInt* this)	eax = BigInt& this; ecx, edx		大整数的“>>=”运算符重载：将大整数 *this 自身的值右移 1 位，返回对移位后的自身的引用。
5DA810	BigInt::operator|=(const BigInt& theBigInt, ecx = BigInt* this)	eax = BigInt& this; ecx, edx		大整数的“|=”运算符重载：将大整数 *this 自身的值与 theBigInt 按位或，返回对运算后的自身的引用。
5DA880	BigInt::operator+(const BigInt& theBigInt, _Out_ BigInt&& aResult, ecx = BigInt* this)	eax = BigInt&& aResult; ecx, edx		大整数的“+”运算符重载：计算大整数 *this 加 theBigInt 的和。
5DA9D0	BigInt::operator-(const BigInt& theBigInt, _Out_ BigInt&& aResult, ecx = BigInt* this)	eax = BigInt&& aResult; ecx, edx		大整数的“-”运算符重载：计算大整数 *this 减 theBigInt 的差。
5DAB70	BigInt::operator*(const BigInt& theBigInt, _Out_ BigInt&& aResult, BigInt* this)	eax = BigInt&& aResult; ecx, edx		大整数的“*”运算符重载：计算大整数 *this 乘 theBigInt 的积。
5DACC0	BigInt::operator%(const BigInt& theBigInt, _Out_ BigInt&& aResult, BigInt* this)	eax = BigInt&& aResult; ecx, edx		大整数的“%”运算符重载：计算大整数 *this 除以 theBigInt 的余数。
5DAD40	BigInt::operator<<(int theShiftBits, _Out_ BigInt&& aResult, edi = BigInt* this)	eax = BigInt&& aResult; ecx, edx		大整数的“<<”运算符重载：计算大整数 *this 左移 theShiftBits 位后的结果。
5DADB0	BigInt::operator>>(_Out_ BigInt&& aResult, edi = BigInt* this)	eax = BigInt&& aResult; ecx, edx		大整数的“>>”运算符重载：计算大整数 *this 右移 1 位后的结果。
5DAE20	BigInt::operator|(const BigInt& theBigInt, _Out_ BigInt&& aResult, BigInt* this)	eax = BigInt&& aResult; ecx, edx		大整数的“|”运算符重载：计算大整数 *this 与 theBigInt 按位或的结果。
5DAEE0	BigInt::ModPow(const BigInt& theModulus, const BigInt& theExponent, _Out_ BigInt&& aResult, BigInt* this)	eax = BigInt&& aResult; ecx, edx		计算大整数 *this 的 theExponent 次方除以 theModulus 的余数。
5DB090	HashData(unsigned int theDataLen, eax = const char* theData, edi = _Out_ BigInt&& aHash)	eax = BigInt&& aHash; ecx, edx	0x4	计算数据的散列校验值，值 = 数据的 MD5 值的最高 94 个二进制位。其中 theDataLen 表示数据的字节长度。
5DB1A0	HashString(eax = const std::string& theString, ecx = _Out_ BigInt&& aHash)	eax = BigInt&& aHash; ecx, edx		计算字符串的散列校验值，值 = 字符串的 MD5 值的最高 94 个二进制位。
5DB1F0	KeyToInt(ebx = const std::string& theRegKey, _Out_ BigInt&& aSignature)	eax = BigInt&& aSignature; ecx, edx	0x4	计算注册码字符串的签名值。对于非法的注册码，返回 0。
5DB4D0	MD5Init(eax = MD5Context* theContext)	ecx		【MD5·步一】;初始化 MD5 计算，向 theContext 中装入标准幻数。;需要一个大小为 0x58 的内存区域用于存放 *theContext 的数据。
5DB500	MD5Update(unsigned int theLength, unsigned char* theData, eax = MD5Context* theContext)	eax, ecx, edx	0x8	【MD5·步二】;将输入的数据 theData 进行分块处理，每块 64 字节，传入 MD5Transform 中进行运算。;若最后一块的长度不满 64 字节，则该块内容会延迟至 MD5Final 中进行运算。
5DB5C0	MD5Final(esi = MD5Context* theContext, ebx = unsigned char* const theDigest)	eax, ecx, edx		【MD5·步三】;填充 MD5Update 中不足 64 字节的部分并进行最后一次运算（若需要），然后整理并填写输出结果。;需要一个大小为 16 字节的无符号字符数组 theDigest 用于接收结果。
5DB650	MD5Transform(eax = unsigned long* const theBlock, unsigned int* const theState)	eax, ecx, edx	0x4	MD5 的主要运算逻辑。对传入的 64 字节 theBlock 进行 64 次运算，每次运算相应修改 theState。
				
60AE9B	operator new[](unsigned int _Size)	eax = void* _Mem; ecx, edx	0x4	在堆上申请一段大小为 _Size 的内存空间，并将申请的内存的地址返回给 eax。用于为数组分配内存。
60B4E4	std::ios_base::_Ios_base_dtor(std::ios_base* _This)	eax, ecx, edx	0x4	基础输入输出流的析构函数。
61BEF1	std::exception::exception(ecx = std::exception* this)	eax = *this		初始化创建异常。需要一个大小为 0xC 的内存区域用于构造 this。
61BFC0	std::exception::~exception(ecx = std::exception* this)	eax, ecx, edx		销毁异常。
61C130	operator new(unsigned int _Size)	eax = void* _Mem; ecx, edx	0x4	在堆上申请一段大小为 _Size 的内存空间，并将申请的内存的地址返回给 eax。
61C19A	operator delete(void* _Block)	eax, ecx, edx	0x4	delete 操作，释放 _Block 指向的内存空间。用于释放 new 操作申请的内存。
61C19F	operator delete[](void* _Block)	eax, ecx, edx	0x4	delete[] 操作，释放 _Block 指向的内存空间。用于释放 new[] 操作申请的内存。
61C1B0	memmove(unsigned int _Size, const void* _Src, void* _Dst)	eax, ecx, edx	0xC	将 _Src 指向的地址开始的 _Size 个字节复制至 _Dst 指向的地址处。允许 _Src 和 _Dst 有重叠。
61C63F	_invalid_parameter_noinfo()	eax, ecx, edx		当程序出现非法的参数时，调用此函数以报告运行错误。
61C64F	_time32(_Out_ long* _Time = 0)	eax = long time; ecx, edx	0x4	取得当前时间，返回 32 位整数型的时间值。当 _Time 不为 0 时，额外将时间值存储在 [_Time] 地址处。
61C6A0	strchr(int _Val, const char* _Str)	eax = const char* _Ptr; ecx, edx	0x8	将整数 _Val 视为 ASCII 编码的字符，并在 _Str 中查找该字符。;若发现该字符，则返回指向原字符数组中该字符首次出现的位置处的指针若未发现，则返回空指针。
61C834	isalpha(int _C)	eax = int result; ecx, edx	0x4	判断给定的字符 _C 是否为英文字母，以及其是否为小写字母或大写字母。;返回值 eax 的含义：0(非字母) | 1(大写字母) | 2(小写字母)。
61CA95	isspace(int _C)	eax = int result; ecx, edx	0x4	判断给定的字符 _C 是否为空白字符，若是则返回非零的数值，否则返回 0。标准的空白字符包括：;空格符(0x20)、水平制表符(0x9)、换行符(0xA)、垂直制表符(0xB)、换页符(0xC)、回车(0xD)。
61CBA5	sscanf(..., const char* _Format, const char* _String)	eax = int 成功匹配和赋值的个数; ecx, edx	0x8(+N)	以给定的格式扫描字符串，其中所有额外参数以入栈逆序依次从头部至尾部地存储字符串中扫描到的特殊字符。;可以使用类似正则表达式的格式字符串，例如“%[a-zA-Z]”表示扫描字母，“%[^0-9]”表示扫描非数字等。;使用“*”表示过滤扫描结果，例如“%*[/]%s”，则“%[/]”的扫描结果不会被存储，仅存储“%s”的结果。;扫描时使用贪婪匹配，默认以空格分隔原字符串一旦遇到不符合格式规定的字符串，则会立即中止扫描。
61CCCC	_stricmp(const char* _String2, const char* _String1)	eax = int result; ecx, edx	0x8	不区分大小写地比较两个字符串。当返回值小于/等于/大于 0 时，表示 _String1 小于/等于/大于 _String2。
61CD2D	atoi(const char* _String)	eax = int _Val; ecx, edx	0x4	将 _String 字符串转化为整数。
61CD40	memchr(unsigned int _MaxCount, int _Val, const void* _Buf)	eax = const void* _Ptr; ecx, edx	0xC	从 _Buf 所指内存区域的前 _MaxCount 个字节查找字符 _Val，;返回指向字符 _Val 所在位置的指针，若未找到则返回 0。
61CEB1	fopen(const char* _Mode, const char* _FileName)	eax = FILE*? f; ecx, edx	0x8	以指定的模式打开指定文件，创建该文件的流并返回指向文件流的指针，若打开文件失败则返回 0。
61CF36	fclose(FILE* _Stream)	eax = 0(成功) | -1(失败); ecx, edx	0x4	关闭文件流，并释放文件流中的相关数据及文件流本身占用的内存空间。
61D24E	fread(FILE* _Stream, unsigned int _ElementCount, unsigned int _ElementSize, void* _Buffer)	eax = int 实际完整读取的项数; ecx, edx	0x10	从文件流中读取 _ElementCount 项（每项的大小为 _ElementSize 字节）的数据并写入 _Buffer 指向的地址。
61D24E	fwrite(FILE* _Stream, unsigned int _ElementCount, unsigned int _ElementSize, void* _Buffer)	eax = int 实际完整写入的项数; ecx, edx	0x10	从 _Buffer 指向的地址读取 _ElementCount 项（每项的大小为 _ElementSize 字节）的数据并写入文件流中。
61D450	strspn(const char* _Control, const char* _Str)	eax = int 连续包含字符数; ecx, edx	0x8	取得字符数组 _Str 开头连续包含 _Control 内的字符数目，亦即首个不包含于 _Control 中的字符的位置。
61D4E6	sprintf(..., const char* _Format, _Out_ char* _Buffer)	eax = int 成功匹配和写入的个数; ecx, edx	0x4(+N)	格式化输出字符串。将格式化后的字符串写入 _Buffer 指向的地址。
61D580	strncpy(unsigned int _Count, const char* _Source, char* _Destination)	eax = char* _Destiniation; ecx, edx	0xC	将 _Source 字符串的前 _Count 个字符复制至 _Destination 处。不会向 _Destination 结尾追加零终止符。;要求 _Source 和 _Destination 指向的区域不能重叠。若 _Source 字符串长度不足 _Count，则以 '\0' 补足。
61D72B	fseek(int _Origin, long _Offset, FILE* _Stream)	eax = 0(成功) | 非零(失败); ecx, edx	0xC	设置文件流当前读取指针指向的位置为“基准（由 _Origin 决定） + 偏移量（即 _Offset 的值）”。;其中，起始位置 _Origin = 0(文件头) | 1(当前位置) | 2(文件尾)。
61D948	ftell(FILE* _Stream)	eax = int _Offset; ecx, edx	0x4	取得文件流当前读取指针指向的位置距离文件头的偏移量。
61DAA6	_strnicmp(unsigned int _MaxCount, const char* _String2, const char* _String1)	eax = int result; ecx, edx	0xC	不区分大小写地比较 _String1 和 _String2 字符串，且至多比较二者的前 _MaxCount 个字符。;当返回值小于/等于/大于 0 时，表示 _String1 小于/等于/大于 _String2。
61DC1E	_cinit(int initFloatingPrecision)	eax = int result; ecx, edx	0x4	程序启动前的全局初始化。各种全局量的初始化在此处进行。具体的初始化函数可参考“dynamic”页。;全局量的初始化方式为依次调用函数指针表（从 __xc_a(0x652478) 至 __xc_z(0x6525D0)）中的代理函数。
61DE1E	`eh vector constructor iterator';(void (__thiscall* pDtor)(void*), void (__thiscall* pCtor)(void*), int _Count, unsigned int _Size, void* _Ptr)	eax, ecx, edx		构造 _Count 个大小为 _Size 的对象，其中 _Ptr 为这些对象的数组的指针，;pCtor 和 pDtor 分别为该对象类型的构造函数和析构函数的指针。
61DFA7	atexit(void (__cdecl* _Func)())	eax = 0(成功) | 非零(失败); ecx, edx		注册一个在程序正常终止时调用的函数，所有被注册的函数都将在 exit() 时被自动调用。
61E017	`eh vector destructor iterator'(void (__thiscall* pDtor)(void*), int _Count, unsigned int _Size, void* _Ptr)	eax, ecx, edx		析构 _Count 个大小为 _Size 的对象，其中 _Ptr 为这些对象的数组的指针，pDtor 指向该对象类型的析构函数。
61E07A	srand(unsigned int _Seed)	eax, ecx, edx	0x4	以给定的随机种子初始化随机数发生器。
61E087	rand()	eax = int _Val; ecx, edx		取得一个 [0, 32767) 之间的随机整数。
61E0A9	_time64(_Out_ long long* _Time = 0)	edx:eax = long long time; ecx	0x4	取得当前时间并将时间的高、低 32 位分别存放在 edx 和 eax。;当 _Time 不为 0 时，将时间的低 8 位和高 8 位分别存储在 [_Time] 和 [_Time + 4] 地址处。
61E0E5	_localtime64_s(const long long* _Time, _Out_ tm* _Tm)	eax = 0(成功) | int err(失败); ecx, edx	0x8	将 _Time 指向的八字节的 time_t 类型（即 long long 类型）的时间戳转化为 tm 时间结构。;需要一个大小为 0x24 的内存区域用于存储 *_Tm 的数据。tm 类型的结构如下，其中所有项均为 int 类型：;(+0)秒，取值范围为 [0, 59](+4)分，取值范围为 [0, 59](+8)时，取值范围为 [0, 23];(+C)日，取值范围为 [1, 31](+10)月，从 1 月为 0 开始计算，取值范围为 [0, 11];(+14)年，取当前距离 1900 年经过的年数(+18)星期，从周日为 0 开始计算，取值范围为 [0, 6];(+1C)表示今日是本年中的第几天，取值范围为 [0, 365](+20)是否启用夏令时。;当转换失败时，返回失败的错误原因转换成功时，返回 0。
61E510	strstr(const char* _SubString, char* _String)	eax = char* _Ptr; ecx, edx	0x8	在字符数组 _String 中寻找 _SubString 子串，若找到则返回指向其首次出现的位置的指针，否则返回空指针。
61E7B1	strncmp(unsigned int _MaxCount, const char* _String2, const char* _String1)	eax = int result; ecx, edx	0xC	区分大小写地比较两个字符数组的前 _MaxCount 个字符。;当返回值小于/等于/大于 0 时，表示 _String1 小于/等于/大于 _String2。
61E986	tolower(int _C)	eax = int _Ch; ecx, edx	0x4	将一个字母字符 _C 转化为小写形式。若给定的 _C 不为字母字符，则不作任何处理。
61EA12	__tmainCRTStartUp()	eax, ecx, edx		程序的启动函数，获取进程的启动信息，初始化全局变量和对象，并调用程序开始的 WinMain 函数。
61EBF2	WinMainCRTStartUp()	eax, ecx, edx		程序的入口函数。初始化 __security_cookie，然后跳转至程序的初始化。
61EEFC	__RTDynamicCast(int isReference, void* TargetType, void* SrcType, long VfDelta, void* inptr)	eax = void*? pResult; ecx, edx	0x14	dynamic_cast 运算符的运行时实现，用于多态类型的转换。其中：isReference 表示源数据为引用或指针;SrcType 和 TargetType 分别指向源数据类型和转换的目标数据类型的类型描述符（TypeDescriptor）;VfDelta 为源类型的虚函数表指针在实例中的偏移量inptr 为转换的源数据。无法转换时，返回空指针。
61EFD1	__security_check_cookie(ecx = unsigned int _StackCookie)	此函数不改变任何寄存器		在函数头部取 eax = __security_cookie（[0x699FE8]的值）与 esp 异或，记录结果;在函数结束时取出记录值再次与 esp 异或，然后调用此函数检验其与初始值是否相同。;经此，可以检验函数开始和结束时的堆栈指针是否一致，进而检验函数中是否发生栈溢出。;此函数检验到栈溢出后会自动跳转至 __report_gsfailure，否则会直接返回。
61EFE0	_purecall()	此函数不返回		默认纯虚函数调用的错误处理程序，虚表中纯虚函数的位置通常使用此函数占位。;当调用抽象类的纯虚成员函数时，实际调用的即为此函数。
61F18B	strtok(const char* _Delimiter, char* _String)	eax = char* _Ptr; ecx, edx	0x8	以 _Delimiter 为分隔符分解字符串 _String。;函数会直接改变 _String 字符串，然后返回指向第一个子字符串的指针。;连续多次以相同的 _Delimiter 调用此函数，且非首次调用时令 _String 为 0，可依次获取每个子字符串的指针。
61F2EB	strtime(_Out_ char* _Buffer)	eax = char* _Buffer; ecx, edx	0x4	取得“hh:mm:ss”形式的系统时间字符串，将结果存储在 _Buffer 指向的地址中。
61FECE	fgets(FILE* _Stream, int _MaxCount, _Out_ char* _Buffer)	eax = char*? _Buffer; ecx, edx	0xC	从文件流 _Stream 读取一行字符（遇到换行符则停止）写入 _Buffer 指向的内存区域。;最多读取 _MaxCount - 1 个字符，并自动在读取到的字符串的结尾添加零终止符。;返回与参数 _Buffer 相同的指针如果读取失败（包括未读取到任何字符的情况），则返回空指针。
620521	feof(FILE* _Stream)	eax = int _EndOfFile; ecx, edx	0x4	判断上一次从文件读取内容失败的原因是否为已读取到文件末尾。若是，返回非零值否则，返回零。;此函数不能用于直接检测读取位置是否达到文件末尾，仅在已读取到文件尾后再次尝试读取时 EOF 标记才被设置。
620AC7	_getcwd(int maxlen, _Out_ char* pnbuf)	eax = char* pnbuf; ecx, edx	0x8	将程序目录的绝对路径写入 pnbuf 指向的内存区域，参数 maxlen 表示 pnbuf 可写入的最大字节数。
621083	calloc(unsigned int _Size, unsigned int _Count)	eax = void* _Mem; ecx, edx	0x8	为包含 _Count 个对象（单个对象的大小为 _Size）的数组申请内存空间，并将该内存中的所有数据初始化为 0。
621740	strlen(const char* _Str)	eax = unsigned int _Length, ecx, edx	0x4	计算字符数组 _Str 的长度，即从起始位置至遇到 \0 为止的部分的字节数。
6217CB	_CxxThrowException(_ThrowInfo* pThrowInfo, void* pExceptionObject)	eax, ecx, edx		C++ 的 throw 关键字，抛出异常，生成异常记录并调用运行时环境以开始处理异常。;其中，pExceptionObject 为生成异常的对象，pThrowInfo 为处理异常所需的信息。
624510	memcpy(unsigned int _Size, void* _Src, void* _Dst)	eax = void* _Dst; ecx, edx	0xC	将 _Src 指向的地址开始的 _Size 个字节复制至 _Dst 指向的地址处。不允许 _Src 和 _Dst 有重叠。
626020	memset(unsigned int _Size, int _Val, void* _Dst)	eax = void* _Dst; ecx, edx	0xC	将从 _Dst 指向的地址开始的 _Size 个字节的内存全部填充为 _Val。
628D70	_aulldiv(除数高32位, 除数低32位, 被除数高32位, 被除数低32位)	edx:eax = unsigned long long 商; ecx		计算无符号 64 位整数除法。
62A452	strtol(int _Radix, char** _EndPtr = 0, const char* _String)	eax = long _Long; ecx, edx	0xC	将字符串按 _Radix 进制转换为长整数，出现非法字符或转化结束时将剩余字符的指针存入 [_EndChar] 中。;此函数在转换前会自动跳过开头的空格字符，遇到数字或正负号则开始转换，然后再次遇到非数字字符则停止。
62E8F1	__security_init_cookie()	eax, ecx, edx		程序启动时，初始化 __security_cookie 及 __security_cookie_complement。
631F30	_alloca_probe_16(eax = unsigned int _Size)	eax	(ebp)	按 16 字节对齐地在栈上分配内存。此函数只计算实际分配的内存大小，然后跳转至 _chkstk() 进行分配。
631F46	_alloca_probe_8(eax = unsigned int _Size)	eax	(ebp)	按 8 字节对齐地在栈上分配内存。此函数只计算实际分配的内存大小，然后跳转至 _chkstk() 进行分配。
635B40	_chkstk(eax = unsigned int _Size)	eax	(ebp)	在栈上申请 _Size 大小的内存。检测栈的溢出，保证栈的连续生长，确保有足够的空间用于局部变量。;当申请的局部变量占用堆栈的内存大小超过 4KB(0x1000字节) 时，应在函数入口添加此函数。
6397D0	_ftol2_sse(st(0) = float)	eax = int integer		利用 SSE 相关指令将 st(0) 的浮点数强制转化为整数存储在 eax 中。
6398B0	pow(st(1) = x, st(0) = y)	st(0) = result; eax, edx		计算 x 的 y 次幂。
6398F0	_CIpow(st(1) = x, st(0) = y)	st(0) = result; eax, edx		计算 x 的 y 次幂。
639B40	log10(st(0) = val)	st(0) = result; eax, edx		计算给定数值以 10 为底的对数。
639B80	_CIlog10(st(0) = val)	st(0) = result; eax, edx		计算给定数值以 10 为底的对数。
639DC0	floor(double val)	st(0) = result; eax, edx	0x8	将给定的双浮点数向下取整。
639EFA	_CIatan2(st(1) = x, st(0) = y)	st(0) = result; eax, edx		以弧度制计算 x/y 的反正切值。
639F10	fmod(st(1) = x, st(0) = y)	st(0) = result; eax, edx		计算 x 除以 y 的余数。
639F1A	_CIfmod(st(1) = x, st(0) = y)	st(0) = result; eax, edx		计算 x 除以 y 的余数。
639F50	cos(st(0) = rad)	st(0) = result; eax		以弧度制计算 rad 的余弦值。
639F90	_CIcos(st(0) = rad)	st(0) = result; eax		以弧度制计算 rad 的余弦值。
63A080	_CIsqrt(st(0) = val)	st(0) = result; eax, ecx, ed		计算给定数值的平方根。
63A094	sqrt(st(0) = val)	st(0) = result; eax, ecx, ed		计算给定数值的平方根。
63A140	sin(st(0) = rad)	st(0) = result; eax		以弧度制计算 rad 的正弦值。
63A180	_CIsin(st(0) = rad)	st(0) = result; eax		以弧度制计算 rad 的正弦值。
				
64FC70	`dynamic initializer for 'TimeEarlyDaveEnterEnd''()	eax		变量“TimeEarlyDaveEnterEnd”的动态初始化函数。【代理】[652490]
64FC80	`dynamic initializer for 'TimeEarlyDaveLeaveStart''()	eax		变量“TimeEarlyDaveLeaveStart”的动态初始化函数。【代理】[652494]
64FC90	`dynamic initializer for 'TimeEarlyDaveLeaveEnd''()	eax		变量“TimeEarlyDaveLeaveEnd”的动态初始化函数。【代理】[652498]
64FCA0	`dynamic initializer for 'TimeSeedChoserSlideOnStart''()	eax		变量“TimeSeedChoserSlideOnStart”的动态初始化函数。【代理】[65249C]
64FCB0	`dynamic initializer for 'TimeSeedChoserSlideOnEnd''()	eax		变量“TimeSeedChoserSlideOnEnd”的动态初始化函数。【代理】[6524A0]
64FCC0	`dynamic initializer for 'TimeSeedChoserSlideOffStart''()	eax		变量“TimeSeedChoserSlideOffStart”的动态初始化函数。【代理】[6524A4]
64FCD0	`dynamic initializer for 'TimeSeedChoserSlideOffEnd''()	eax		变量“TimeSeedChoserSlideOffEnd”的动态初始化函数。【代理】[6524A8]
64FCE0	`dynamic initializer for 'TimeSeedBankOnStart''()	eax		变量“TimeSeedBankOnStart”的动态初始化函数。【代理】[6524AC]
64FCF0	`dynamic initializer for 'TimeSeedBankOnEnd''()	eax		变量“TimeSeedBankOnEnd”的动态初始化函数。【代理】[6524B0]
64FD00	`dynamic initializer for 'TimePanLeftStart''()	eax		变量“TimePanLeftStart”的动态初始化函数。【代理】[6524B4]
64FD10	`dynamic initializer for 'TimePanLeftEnd''()	eax		变量“TimePanLeftEnd”的动态初始化函数。【代理】[6524B8]
64FD20	`dynamic initializer for 'TimeSeedBankRightStart''()	eax		变量“TimeSeedBankRightStart”的动态初始化函数。【代理】[6524BC]
64FD30	`dynamic initializer for 'TimeSeedBankRightEnd''()	eax		变量“TimeSeedBankRightEnd”的动态初始化函数。【代理】[6524C0]
64FD40	`dynamic initializer for 'TimeRollSodStart''()	eax		变量“TimeRollSodStart”的动态初始化函数。【代理】[6524C4]
64FD50	`dynamic initializer for 'TimeRollSodEnd''()	eax		变量“TimeRollSodEnd”的动态初始化函数。【代理】[6524C8]
64FD60	`dynamic initializer for 'TimeGraveStoneStart''()	eax		变量“TimeGraveStoneStart”的动态初始化函数。【代理】[6524CC]
64FD70	`dynamic initializer for 'TimeGraveStoneEnd''()	eax		变量“TimeGraveStoneEnd”的动态初始化函数。【代理】[6524D0]
64FD80	`dynamic initializer for 'TimeLawnMowerStar''()	eax, ecx, edx		变量“TimeLawnMowerStar”的动态初始化函数。【代理】[6524D4]
64FDD0	`dynamic initializer for 'TimeReadySetPlantStart''()	eax		变量“TimeReadySetPlantStart”的动态初始化函数。【代理】[6524D8]
64FDE0	`dynamic initializer for 'TimeReadySetPlantEnd''()	eax		变量“TimeReadySetPlantEnd”的动态初始化函数。【代理】[6524DC]
64FDF0	`dynamic initializer for 'TimeFogRollIn''()	eax		变量“TimeFogRollIn”的动态初始化函数。【代理】[6524E0]
64FE00	`dynamic initializer for 'TimeCrazyDaveEnterStart''()	eax		变量“TimeCrazyDaveEnterStart”的动态初始化函数。【代理】[6524E4]
64FE10	`dynamic initializer for 'TimeCrazyDaveEnterEnd''()	eax		变量“TimeCrazyDaveEnterEnd”的动态初始化函数。【代理】[6524E8]
64FE20	`dynamic initializer for 'TimeCrazyDaveLeaveStart''()	eax		变量“TimeCrazyDaveLeaveStart”的动态初始化函数。【代理】[6524EC]
64FE30	`dynamic initializer for 'TimeCrazyDaveLeaveEnd''()	eax		变量“TimeCrazyDaveLeaveEnd”的动态初始化函数。【代理】[6524F0]
64FE40	`dynamic initializer for 'TimeIntroEnd''()	eax		变量“TimeIntroEnd”的动态初始化函数。【代理】[6524F4]
64FE50	`dynamic initializer for 'LostTimeBrainGraphicStart''()	eax		变量“LostTimeBrainGraphicStart”的动态初始化函数。【代理】[6524F8]
64FE60	`dynamic initializer for 'LostTimeBrainGraphicShake''()	eax		变量“LostTimeBrainGraphicShake”的动态初始化函数。【代理】[6524FC]
64FE70	`dynamic initializer for 'LostTimeBrainGraphicCancelShake''()	eax		变量“LostTimeBrainGraphicCancelShake”的动态初始化函数。【代理】[652500]
64FE80	`dynamic initializer for 'LostTimeBrainGraphicEnd''()	eax		变量“LostTimeBrainGraphicEnd”的动态初始化函数。【代理】[652504]
64FE90	`dynamic initializer for 'LostTimeEnd''()	eax		变量“LostTimeEnd”的动态初始化函数。【代理】[652508]
64FEA0	`dynamic initializer for 'TimeIntro_LogoEnd''()	eax		变量“TimeIntro_LogoEnd”的动态初始化函数。【代理】[65250C]
64FEB0	`dynamic initializer for 'TimeIntro_PanRightEnd''()	eax		变量“TimeIntro_PanRightEnd”的动态初始化函数。【代理】[652510]
64FEC0	`dynamic initializer for 'TimeIntro_FadeOut''()	eax		变量“TimeIntro_FadeOut”的动态初始化函数。【代理】[652514]
64FED0	`dynamic initializer for 'TimeIntro_FadeOutEnd''()	eax		变量“TimeIntro_FadeOutEnd”的动态初始化函数。【代理】[652518]
64FEE0	`dynamic initializer for 'TimeIntro_End''()	eax		变量“TimeIntro_End”的动态初始化函数。【代理】[65251C]
64FEF0	`dynamic initializer for 'gTodVertexReservoir''()	eax, ecx		变量“gTodVertexReservoir”的动态初始化函数。【代理】[652520]
64FF10	`dynamic initializer for 'gFilterMap''()	eax, ecx, edx		变量“gFilterMap”的动态初始化函数。【代理】[652524]
64FF40	`dynamic initializer for 'gLawnStringFormats''()	eax, ecx, edx		变量“gLawnStringFormats”的动态初始化函数。【代理】[652528]
650180	`dynamic initializer for 'SAVE_FILE_DATE''()	eax, ecx, edx		变量“SAVE_FILE_DATE”的动态初始化函数。【代理】[65252C]
6501A0	`dynamic initializer for 'gRenderCommandPool''()	eax, ecx, edx		变量“gRenderCommandPool”的动态初始化函数。【代理】[652530]
6501D0	`dynamic initializer for 'gHesitation''()	eax, ecx, edx		变量“gHesitation”的动态初始化函数。【代理】[652534]
650200	`dynamic initializer for 'gTodDefaultStringFormats''()	eax, ecx, edx		变量“gTodDefaultStringFormats”的动态初始化函数。【代理】[652538]
650260	`dynamic initializer for 'ZOMBIE_MINDCONTROLLED_COLOR''()	eax, ecx, edx		变量“ZOMBIE_MINDCONTROLLED_COLOR”的动态初始化函数。【代理】[65253C]
650280	`dynamic initializer for 'Sexy::DIALOG_YES_STRING''()	eax, ecx, edx		变量“Sexy::DIALOG_YES_STRING”的动态初始化函数。【代理】[652540]
6502A0	`dynamic initializer for 'Sexy::DIALOG_NO_STRING''()	eax, ecx, edx		变量“Sexy::DIALOG_NO_STRING”的动态初始化函数。【代理】[652544]
6502C0	`dynamic initializer for 'Sexy::DIALOG_OK_STRING''()	eax, ecx, edx		变量“Sexy::DIALOG_OK_STRING”的动态初始化函数。【代理】[652548]
6502E0	`dynamic initializer for 'Sexy::DIALOG_CANCEL_STRING''()	eax, ecx, edx		变量“Sexy::DIALOG_CANCEL_STRING”的动态初始化函数。【代理】[65254C]
650300	`dynamic initializer for 'Sexy::gSEHCatcher''()	eax, ecx, edx		变量“Sexy::gSEHCatcher”的动态初始化函数。【代理】[652550]
650320	`dynamic initializer for 'gFPSTimer''()	eax, ecx, edx		变量“gFPSTimer”的动态初始化函数。【代理】[652554]
650330	`dynamic initializer for 'Sexy::Color::Black''()	eax, ecx, edx		变量“Sexy::Color::Black”的动态初始化函数。【代理】[652558]
650350	`dynamic initializer for 'Sexy::Color::White''()	eax, ecx, edx		变量“Sexy::Color::White”的动态初始化函数。【代理】[65255C]
650370	`dynamic initializer for 'Sexy::D3DInterface::mErrorString''()	eax, ecx, edx		变量“Sexy::D3DInterface::mErrorString”的动态初始化函数。【代理】[652560]
650380	`dynamic initializer for 'Sexy::GraphicsState::mStaticImage''()	eax, ecx, edx		变量“Sexy::GraphicsState::mStaticImage”的动态初始化函数。【代理】[652564]
6503A0	`dynamic initializer for 'gRenderCritSec''()	eax, ecx, edx		变量“gRenderCritSec”的动态初始化函数。【代理】[652568]
6503C0	`dynamic initializer for 'gRenderCommandPool''()	eax, ecx, edx		变量“gRenderCommandPool”的动态初始化函数。【代理】[65256C]
6503F0	`dynamic initializer for 'Sexy::SEHCatcher::mErrorTitle''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mErrorTitle”的动态初始化函数。【代理】[652570]
650400	`dynamic initializer for 'Sexy::SEHCatcher::mErrorText''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mErrorText”的动态初始化函数。【代理】[652574]
650410	`dynamic initializer for 'Sexy::SEHCatcher::mUserText''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mUserText”的动态初始化函数。【代理】[652578]
650420	`dynamic initializer for 'Sexy::SEHCatcher::mUploadFileName''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mUploadFileName”的动态初始化函数。【代理】[65257C]
650430	`dynamic initializer for 'Sexy::SEHCatcher::mSubmitReportTransfer''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mSubmitReportTransfer”的动态初始化函数。【代理】[652580]
650450	`dynamic initializer for 'Sexy::SEHCatcher::mCrashMessage''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mCrashMessage”的动态初始化函数。【代理】[652584]
650470	`dynamic initializer for 'Sexy::SEHCatcher::mSubmitHost''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mSubmitHost”的动态初始化函数。【代理】[652588]
650480	`dynamic initializer for 'Sexy::SEHCatcher::mSubmitMessage''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mSubmitMessage”的动态初始化函数。【代理】[65258C]
6504A0	`dynamic initializer for 'Sexy::SEHCatcher::mSubmitErrorMessage''()	eax, ecx, edx		变量“Sexy::SEHCatcher::mSubmitErrorMessage”的动态初始化函数。【代理】[652590]
6504C0	`dynamic initializer for 'gPerfInfoSet''()	eax, ecx, edx		变量“gPerfInfoSet”的动态初始化函数。【代理】[652594]
650500	`dynamic initializer for 'gPerfRecordVector''()	eax, ecx, edx		变量“gPerfRecordVector”的动态初始化函数。【代理】[652598]
650510	`dynamic initializer for 'gSexyAllocMap''()	eax, ecx, edx		变量“gSexyAllocMap”的动态初始化函数。【代理】[65259C]
650530	`dynamic initializer for 'Sexy::gAppDataFolder''()	eax, ecx, edx		变量“Sexy::gAppDataFolder”的动态初始化函数。【代理】[6525A0]
650550	`dynamic initializer for 'gMTRand''()	eax, ecx, edx		变量“gMTRand”的动态初始化函数。【代理】[6525A4]
650560	`dynamic initializer for 'Sexy::NumberLocale::gLocaleString''()	eax, ecx, edx		变量“Sexy::NumberLocale::gLocaleString”的动态初始化函数。【代理】[6525A8]
650580	`dynamic initializer for 'Sexy::NumberLocale::gLocaleObject''()	eax, ecx, edx		变量“Sexy::NumberLocale::gLocaleObject”的动态初始化函数。【代理】[6525AC]
6505A0	`dynamic initializer for 'Sexy::NumberLocale::gLocaleNumPunct''()	eax, ecx, edx		变量“Sexy::NumberLocale::gLocaleNumPunct”的动态初始化函数。【代理】[6525B0]
6505C0	`dynamic initializer for 'gStringToIntMap''()	eax, ecx, edx		变量“gStringToIntMap”的动态初始化函数。【代理】[6525B4]
650600	`dynamic initializer for 'Sexy::gSexyCache''()	eax, ecx, edx		变量“Sexy::gSexyCache”的动态初始化函数。【代理】[6525B8]
650620	`dynamic initializer for 'gJ2KCodecKey''()	eax, ecx, edx		变量“gJ2KCodecKey”的动态初始化函数。【代理】[6525BC]
650640	`dynamic initializer for 'ImageLib::gColorFileName''()	eax, ecx, edx		变量“ImageLib::gColorFileName”的动态初始化函数。【代理】[6525C0]
650650	`dynamic initializer for 'ImageLib::gAlphaFileName''()	eax, ecx, edx		变量“ImageLib::gAlphaFileName”的动态初始化函数。【代理】[6525C4]
650660	`dynamic initializer for 'gPakInterface''()	eax, ecx, edx		变量“gPakInterface”的动态初始化函数。【代理】[6525C8]
650680	`dynamic initializer for 'gSmallPrimes''()	eax, ecx, edx		变量“gSmallPrimes”的动态初始化函数。【代理】[6525CC]
650B40	`dynamic atexit destructor for 'gFilterMap''()	eax, ecx, edx		被注册用于在程序退出时对变量“gFilterMap”进行析构的函数。
650B60	`GetIdByVariable'::`2'::`dynamic atexit destructor for 'aMap''()	eax, ecx, edx		被注册用于在程序退出时对变量“`GetIdByVariable'::`2'::aMap”进行析构的函数。
650B70	`dynamic atexit destructor for 'Sexy::DIALOG_YES_STRING''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::DIALOG_YES_STRING”进行析构的函数。
650BA0	`dynamic atexit destructor for 'Sexy::DIALOG_NO_STRING''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::DIALOG_NO_STRING”进行析构的函数。
650BD0	`dynamic atexit destructor for 'Sexy::DIALOG_OK_STRING''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::DIALOG_OK_STRING”进行析构的函数。
650C00	`dynamic atexit destructor for 'Sexy::DIALOG_CANCEL_STRING''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::DIALOG_CANCEL_STRING”进行析构的函数。
650C30	`dynamic atexit destructor for 'Sexy::gSEHCatcher''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::gSEHCatcher”进行析构的函数。
650C80	`dynamic atexit destructor for 'Sexy::D3DInterface::mErrorString''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::D3DInterface::mErrorString”进行析构的函数。
650CB0	`dynamic atexit destructor for 'Sexy::GraphicsState::mStaticImage''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::GraphicsState::mStaticImage”进行析构的函数。
650CC0	`dynamic atexit destructor for 'gRenderCritSec''()	eax, ecx, edx		被注册用于在程序退出时对变量“gRenderCritSec”进行析构的函数。
650CD0	`dynamic atexit destructor for 'Sexy::SEHCatcher::mErrorTitle''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mErrorTitle”进行析构的函数。
650D00	`dynamic atexit destructor for 'Sexy::SEHCatcher::mErrorText''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mErrorText”进行析构的函数。
650D30	`dynamic atexit destructor for 'Sexy::SEHCatcher::mUserText''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mUserText”进行析构的函数。
650D60	`dynamic atexit destructor for 'Sexy::SEHCatcher::mUploadFileName''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mUploadFileName”进行析构的函数。
650D90	`dynamic atexit destructor for 'Sexy::SEHCatcher::mSubmitReportTransfer''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mSubmitReportTransfer”进行析构的函数。
650DA0	`dynamic atexit destructor for 'Sexy::SEHCatcher::mCrashMessage''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mCrashMessage”进行析构的函数。
650DD0	`dynamic atexit destructor for 'Sexy::SEHCatcher::mSubmitHost''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mSubmitHost”进行析构的函数。
650E00	`dynamic atexit destructor for 'Sexy::SEHCatcher::mSubmitMessage''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mSubmitMessage”进行析构的函数。
650E30	`dynamic atexit destructor for 'Sexy::SEHCatcher::mSubmitErrorMessage''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::SEHCatcher::mSubmitErrorMessage”进行析构的函数。
650E60	`dynamic atexit destructor for 'gPerfInfoSet''()	eax, ecx, edx		被注册用于在程序退出时对变量“gPerfInfoSet”进行析构的函数。
650E70	`dynamic atexit destructor for 'gPerfRecordVector''()	eax, ecx, edx		被注册用于在程序退出时对变量“gPerfRecordVector”进行析构的函数。
650EB0	`dynamic atexit destructor for 'gSexyAllocMap''()	eax, ecx, edx		被注册用于在程序退出时对变量“gSexyAllocMap”进行析构的函数。
650EE0	`dynamic atexit destructor for 'Sexy::gAppDataFolder''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::gAppDataFolder”进行析构的函数。
650F10	`dynamic atexit destructor for 'Sexy::NumberLocale::gLocaleString''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::NumberLocale::gLocaleString”进行析构的函数。
650F40	`dynamic atexit destructor for 'Sexy::NumberLocale::gLocaleObject''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::NumberLocale::gLocaleObject”进行析构的函数。
650F50	`dynamic atexit destructor for 'gStringToIntMap''()	eax, ecx, edx		被注册用于在程序退出时对变量“gStringToIntMap”进行析构的函数。
650F60	`dynamic atexit destructor for 'Sexy::gSexyCache''()	eax, ecx, edx		被注册用于在程序退出时对变量“Sexy::gSexyCache”进行析构的函数。
650F70	`dynamic atexit destructor for 'gJ2KCodecKey''()	eax, ecx, edx		被注册用于在程序退出时对变量“gJ2KCodecKey”进行析构的函数。
650FA0	`dynamic atexit destructor for 'ImageLib::gColorFileName''()	eax, ecx, edx		被注册用于在程序退出时对变量“ImageLib::gColorFileName”进行析构的函数。
650FD0	`dynamic atexit destructor for 'ImageLib::gAlphaFileName''()	eax, ecx, edx		被注册用于在程序退出时对变量“ImageLib::gAlphaFileName”进行析构的函数。
651000	`dynamic atexit destructor for 'gPakInterface''()	eax, ecx, edx		被注册用于在程序退出时对变量“gPakInterface”进行析构的函数。
651010	`dynamic atexit destructor for 'gSmallPrimes''()	eax, ecx, edx		被注册用于在程序退出时对变量“gSmallPrimes”进行析构的函数。
195250	Projectile::FindCollisionTargetGridItem(void)	r0 = GridItem*? aGridItem r3,r2,r1计算残留		[TV版专属函数]子弹对墓碑和靶子僵尸的碰撞检测，寻找子弹击中的对战模式中的墓碑或者靶子僵尸。特别的对战模式的墓碑ID和正常关卡的一致，靶子僵尸ID为14。该函数先以Projectile::GetProjectileRect函数获取子弹的矩形范围，遍历所有格子场地物品类型取得墓碑的矩形范围，若子弹的矩形范围和墓碑的矩形范围重合大于12则更新墓碑，并返回GridItem。若当前没有其他碰撞目标时，计算靶子僵尸的中心坐标并判断是否与子弹重合，重合则更新靶子僵尸返回GridItem。若不存在碰撞到的墓碑和靶子僵尸返回0。
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
